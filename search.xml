<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为什么要坚持写博客</title>
    <url>/career/stick-to-writting-blog/</url>
    <content><![CDATA[<p>写博客有很多好处, 时常听到周围的人或网友这样说, 也有时候会有种想写点东西的冲动, 又不知道怎么开始, 只是想一想又放弃了. 但我们还是应该勇敢开始的, 不是吗?</p>
<h2 id="第一个原因"><a href="#第一个原因" class="headerlink" title="第一个原因"></a>第一个原因</h2><p>经常在网上看到大佬的博客, 那真是丰富呀, 上至天文地理, 下到感情人生, 读起来像一本百科全书, 非常羡慕他们有这样一片独立的天地. 再看看自己, 小白一个, 啥啥都不会, 也没有什么文采, 我写东西出来不丢人吗?</p>
<p>不知道大家有没有我一样的疑虑, 有想法不敢去尝试, 羡慕别人却不敢争取. 万事开头难, 我自己为什么要想得那么多? 换一个角度想, 我想写点东西, 没有任何人阻止我, 让我迟迟不能动笔的, 竟然是我自己, 自己的思想禁锢了自己, 我要写东西时, 并没有人会夺走我的鼠标砸掉我的键盘, 所以, 我在害怕担心什么? 不知道怎么开始 还是担心写的不好丢人, 还是怕写错了被指责?</p>
<p>我觉得这是为什么要写博客的第一个原因: 克服自己, 突破思维禁锢, 不要犹豫害怕, 想到什么, 勇敢去做, 迈出第一步!</p>
<h2 id="提高自己"><a href="#提高自己" class="headerlink" title="提高自己"></a>提高自己</h2><p>“我是一个小白, 文采不好, 没有技术”, 这个现状可以是限制我让我不敢开始的绊脚石(我不好所以我别丢人了); 也可以成为我前进的原因和动力(我没有技术, 所以我更应该提高自己, 积累点点滴滴).</p>
<p>看到大佬们闪亮发光的文章, 一篇篇的高端技术解说, 成千上万的粉丝和阅读量时, 我们也应该想到, 万丈高楼平地起. 博客不像别的东西, 大家开始的时候都是一篇一篇累积的; 技术的成长也不是一蹴而就, 一个大佬的背后, 一定肝了非常非常多的文章教程和实战.</p>
<p>开始的时候都难, 那就把学到的新知识和碰到的难点都一点点记录下来, 在学习和解决各种问题的时候就会慢慢变强</p>
<a id="more"></a>

<p>讲述自己学到的知识, 和解决问题的过程, 非常有利于巩固记忆, 在网上看到过一张图:</p>
<img data-src="/career/stick-to-writting-blog/learn.png" class="">

<p>它不一定适用于每个人, 但至少说明一个问题: 一般来说, 主动学习的效率远远高于被动学习. 要想学的快, 让新知识不容易忘记, 光看教程和文章是不行的, 必须要实战和分享, 这样才能最高效的吸收. 写博客在这个金字塔种应该算作”Teach Others”, 虽说开始写的不好, 对别人不一定有帮助, 但对自己的提升还是很有好处的, 在整理回顾并写出来的时候, 那些生疏的知识会被细细的吸收, 就像咀嚼的过程.</p>
<p>对于写的不好的文章, 有这么多网友审阅, 有人会指出不足, 或者给出改进建议, 都可以从中学习, 提升自己.</p>
<p>一点点积累, 慢慢变强, 不积跬步无以至千里, 不积小流无以成江海.</p>
<h2 id="成长记录"><a href="#成长记录" class="headerlink" title="成长记录"></a>成长记录</h2><p>今天有了什么感悟, 后天又学了什么新知识, 或者碰到一个很好玩的脚本, 解决了一个很棘手的问题等, 翻看起来, 一定会非常有意思, 感慨万千.</p>
<p>假设万一自己将来有一天变成心中的大佬了, 成功了, 你不想看看自己一路怎么走来的吗? 哈哈, 即使没有成为大佬, 它也会成为成长路上的一本笔记, 每一页都是曾经走过的路, 看过的风景.</p>
<p>它有时间轴功能, 这可以作为将来对过去的复盘, 可以看看自己过去一段时间到底在干什么, 专注于什么, 学习了什么, 还是都忘记了记录, 空空一片. 根据过去的记录, 更好的调整未来的计划, 让自己在走向理想的路上不要走偏.</p>
<h2 id="帮助别人"><a href="#帮助别人" class="headerlink" title="帮助别人"></a>帮助别人</h2><p>学习工作种90%的问题, 在网上搜索一下, 总会发现, 哇, 竟然有网友也碰到同样的问题, 和这个一样样的, 照着文章解决了问题, 心中会非常感激. 别人的简单记录给我们带来这么大的便利, 我们也要奉献自己的一份力量, 可能刚开始我写的不好, 写的很基础, 可有入门的朋友恰好碰到我这个基础的问题了呢? 用心写出来的东西, 肯定会有价值, 哪怕非常微小.</p>
<img data-src="/career/stick-to-writting-blog/nature.jpg" class="">

<p>勇敢开始, 坚持记录! 共勉!</p>
]]></content>
      <categories>
        <category>career</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>在VS Code下使用Go插件安装失败问题</title>
    <url>/golang/golang-with-vscode/</url>
    <content><![CDATA[<p>对比了几个Golang IDE, 还是VS Code最轻量好用, 但是使用时会提示一堆插件安装失败, 记录一下问题</p>
<p>环境: Win10, VS Code, go1.13.4.windows-amd64</p>
<h2 id="安装Go语言环境"><a href="#安装Go语言环境" class="headerlink" title="安装Go语言环境"></a>安装Go语言环境</h2><p>在<a href="https://golang.google.cn/">官方网站</a>下载安装</p>
<h2 id="VSC安装Go扩展"><a href="#VSC安装Go扩展" class="headerlink" title="VSC安装Go扩展"></a>VSC安装Go扩展</h2><p>VS Code扩展栏搜索<code>Go</code>进行安装</p>
<img data-src="/golang/golang-with-vscode/go-vsc-ext.png" class="" title="插件主页">

<p>这一步比较简单, 一般没有问题, 安装好后编写Go源文件, 提示需要安装一些代码提示工具</p>
<p>在VSC下方状态栏显示有<code>Analysis Tools Missing</code>, 点击该提示, 点击”install”, 出现安装失败提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installing github.com&#x2F;mdempsky&#x2F;gocode FAILED</span><br><span class="line">Installing github.com&#x2F;uudashr&#x2F;gopkgs&#x2F;cmd&#x2F;gopkgs FAILED</span><br><span class="line">Installing github.com&#x2F;ramya-rao-a&#x2F;go-outline FAILED</span><br><span class="line">Installing github.com&#x2F;stamblerre&#x2F;gocode FAILED</span><br><span class="line">Installing github.com&#x2F;rogpeppe&#x2F;godef FAILED</span><br><span class="line">Installing github.com&#x2F;sqs&#x2F;goreturns FAILED</span><br><span class="line">Installing golang.org&#x2F;x&#x2F;lint&#x2F;golint FAILED</span><br></pre></td></tr></table></figure>

<p>大概是<code>golang.org/x/...</code>下的包安装连接失败, 试着打开<code>golang.org</code>果然无法访问</p>
<p>但这些包其实在github上可以下载到, 是golang官方提供的镜像, 项目有<code>[mirror]</code>标志</p>
<h2 id="解决第三方库下载失败问题"><a href="#解决第三方库下载失败问题" class="headerlink" title="解决第三方库下载失败问题"></a>解决第三方库下载失败问题</h2><blockquote>
<p>golang.org被屏蔽了, 但很多第三方包都需要访问该地址, 若不处理, 会经常报错</p>
<p>几种方法任选一个, 推荐度从高到底</p>
</blockquote>
<a id="more"></a>

<h3 id="方法1-设置三方包代理"><a href="#方法1-设置三方包代理" class="headerlink" title="方法1: 设置三方包代理"></a>方法1: 设置三方包代理</h3><p>设置代理方法简单, 而且不用梯子, 不用瞎折腾</p>
<p>在网上找到两个推荐的代理: <a href="https://goproxy.io/">goproxy</a> <a href="https://docs.gomods.io/">Athens</a></p>
<p>我没有安装Docker, 就只介绍下goproxy的用法, 官网有教程, 非常简单</p>
<p>下面是官网给的教程, 我实际使用只用了<code>go env -w GOPROXY=https://goproxy.io,direct</code>这条命令, 之后就能正常使用了</p>
<p>设置两个环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable the go modules feature</span></span><br><span class="line"><span class="variable">$env</span>:GO111MODULE=<span class="string">&quot;on&quot;</span></span><br><span class="line"><span class="comment"># Set the GOPROXY environment variable</span></span><br><span class="line"><span class="variable">$env</span>:GOPROXY=<span class="string">&quot;https://goproxy.io&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果GO版本&gt;=1.13, 可以设置GOPRIVATE环境变量, 控制一些包不使用代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.io,direct</span><br><span class="line"><span class="comment"># Set environment variable allow bypassing the proxy for selected modules</span></span><br><span class="line">go env -w GOPRIVATE=*.corp.example.com</span><br></pre></td></tr></table></figure>

<h3 id="方法2-梯子"><a href="#方法2-梯子" class="headerlink" title="方法2: 梯子"></a>方法2: 梯子</h3><p>这里不介绍怎么搭梯子</p>
<p>如果有梯子, 连上直接使用, 这是最简单的</p>
<h3 id="方法3-自己瞎折腾"><a href="#方法3-自己瞎折腾" class="headerlink" title="方法3: 自己瞎折腾"></a>方法3: 自己瞎折腾</h3><p>不推荐, 弄半天, 不一定弄得好</p>
<p>网上找了好久, 又自己试了半天, 勉强能用吧</p>
<p>转到环境变量中的<code>GOPATH</code>目录下, Win10下可以在PowerShell中运行命令显示目录位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$env</span>:GOPATH</span><br></pre></td></tr></table></figure>

<p>在该目录下新建<code>golang.org/x</code>目录, 并进入, 打开git bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/golang/tools.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/lint.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/sync.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/xerrors.git</span><br></pre></td></tr></table></figure>

<p><strong>cd到<code>GOPATH</code>目录下</strong>, 在powershell运行以下命令, 安装VS Code提示的组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/mdempsky/gocode</span><br><span class="line">go get github.com/uudashr/gopkgs/cmd/gopkgs</span><br><span class="line">go get github.com/ramya-rao<span class="_">-a</span>/go-outline</span><br><span class="line">go get github.com/stamblerre/gocode</span><br><span class="line">go get github.com/rogpeppe/godef</span><br><span class="line">go get github.com/sqs/goreturns</span><br><span class="line">go install golang.org/x/lint/golint</span><br><span class="line">go get github.com/sergi/go-diff/diffmatchpatch</span><br><span class="line">go get honnef.co/go/tools/simple</span><br><span class="line">go get honnef.co/go/tools/staticcheck</span><br><span class="line">go get honnef.co/go/tools/stylecheck</span><br><span class="line">go install golang.org/x/tools/gopls</span><br><span class="line">go get -v github.com/go-delve/delve/cmd/dlv</span><br></pre></td></tr></table></figure>

<p>最后一直提示缺少个<code>gocode-gomod</code>我的天, 然后又把<code>github.com/stamblerre/gocode</code>安装后到GOPATH下的bin目录下<br>并把<code>gocode.exe</code>改名为<code>gocode-gomod.exe</code>, 再安装一下上面的gocode(github.com/mdempsky/gocode)</p>
<p>重新加载VS Code, 没有提示<code>Analysis Tools Missing</code>了, 但提示需要Update, 我这里没有梯子就不升级了, 已经能用了</p>
<p>要是一开始就知道有方法1, 就不会绕到这里了-_-</p>
<img data-src="/golang/golang-with-vscode/install-success.png" class="" title="安装成功">
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SQLite的一些注意点</title>
    <url>/database/about-sqlite/</url>
    <content><![CDATA[<p>SQLite是一个非常轻量的数据库系统, 用C语言实现, 是一个小型, 快速, 可靠, 功能全面的SQL数据库引擎. SQLite内置在许多地方使用.</p>
<p>如果不要求大量的数据并发写入, 且应用程序和数据库没有通过网络分离时, 可以选择适用轻量的SQLite</p>
<p>经测试, 读写千万级别的数据完全没有问题</p>
<p>这里记录一些使用过程中碰到的问题</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>SQLite实际用于存储的数据类型只有5种(NULL, INTEGER, REAL, TEXT, BLOB)</p>
<p><code>NULL</code> 就是NULL</p>
<p><code>INTEGER</code> 存储整数, 根据大小存储为1, 2, 3, 4, 6或者8 bytes</p>
<p><code>REAL</code> 8 bytes大小的IEEE浮点数</p>
<p><code>TEXT</code> 用数据库编码存储的字符串(UTF-8, UTF-16BE or UTF-16LE)</p>
<p><code>BLOB</code> 二进制存储数据</p>
<p>5种怎么够用? 虽说实际存储只有这5种类型, 但是SQLite支持很多其它类型, 然后以上面某一种数据类型实际存储</p>
<a id="more"></a>

<p>下表列出了当创建 SQLite3 表时可使用的各种数据类型名称，同时也显示了相应的亲和类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>亲和类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>INT</code> <code>INTEGER</code> <code>TINYINT</code> <code>SMALLINT</code> <code>MEDIUMINT</code> <code>BIGINT</code> <code>UNSIGNED</code> <code>BIG</code> <code>INT</code> <code>INT2</code> <code>INT8</code></td>
<td><code>INTEGER</code></td>
</tr>
<tr>
<td><code>CHARACTER(20)</code> <code>VARCHAR(255)</code> <code>VARYING</code> <code>CHARACTER(255)</code> <code>NCHAR(55)</code> <code>NATIVE</code> <code>CHARACTER(70)</code> <code>NVARCHAR(100)</code> <code>TEXT</code> <code>CLOB</code></td>
<td><code>TEXT</code></td>
</tr>
<tr>
<td><code>BLOB</code> <code>no</code> <code>datatype</code> <code>specified</code></td>
<td><code>NONE</code></td>
</tr>
<tr>
<td><code>REAL</code> <code>DOUBLE</code> <code>DOUBLE</code> <code>PRECISION</code> <code>FLOAT</code></td>
<td><code>REAL</code></td>
</tr>
<tr>
<td><code>NUMERIC</code> <code>DECIMAL(10</code>,<code>5)</code> <code>BOOLEAN</code> <code>DATE</code> <code>DATETIME</code></td>
<td><code>NUMERIC</code></td>
</tr>
</tbody></table>
<h2 id="database-is-locked"><a href="#database-is-locked" class="headerlink" title="database is locked"></a>database is locked</h2><p>刚开始使用时, 不一会就异常报错了, 异常信息就一个”database is locked”, 查查资料</p>
<p>找到官方网站对多连接和多线程的一些解释说明(<a href="https://sqlite.org/faq.html#q5">链接</a>):</p>
<blockquote>
<p>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.<br>同一数据库可以被多个线程同时打开, 多个线程可以在同一时间做SELECT操作, 但是同一时刻只允许一个线程对数据库做更改</p>
<p>SQLite uses reader/writer locks to control access to the database.<br>SQLite使用读/写锁控制数据库的访问许可(读写锁同时只允许一个写或者多个读, 不允许读写共存)</p>
<p>When SQLite tries to access a file that is locked by another process, the default behavior is to return SQLITE_BUSY. You can adjust this behavior from C code using the sqlite3_busy_handler() or sqlite3_busy_timeout() API functions.<br>当你尝试访问一个被其它线程锁定的SQLite数据库时, 默认行为是返回SQLITE_BUSY, 可以用API函数调整默认行为</p>
<p>SQLite is threadsafe. We make this concession since many users choose to ignore the advice given in the previous paragraph. But in order to be thread-safe, SQLite must be compiled with the SQLITE_THREADSAFE preprocessor macro set to 1.<br>SQLite是线程安全的, 官方表示他们做出这样的让步是因为很多人不看上面的建议, 如果想要使用线程安全的SQLite, 需要改对应的标志宏, 然后自行重新编译</p>
<p>Under Unix, you should not carry an open SQLite database across a fork() system call into the child process.<br>在Unix系统下, 你不应该把一个打开的SQLite连接通过fork()调用带到子线程中</p>
</blockquote>
<p>可见, 官方非常不推荐多线程使用SQLite, 所以平时尽量用<strong>单线程单连接</strong>来使用SQLite, 如果发现必须要使用多线程实现高并发操作, 应该考虑是不是要用MySQL等大型数据库</p>
<p>出现”database is locked”的错误提示是因为我们开了多个连接, 并且用一个连接访问了锁定中的数据库(有连接正在进行写操作), 解决方法是不要每次都重新打开一个连接, 而是在程序初始化时打开一个连接, 运行过程中只使用一个连接, 运行结束时释放该连接. 单线程单连接使用.</p>
<h2 id="复制SQLite数据库文件导致报错"><a href="#复制SQLite数据库文件导致报错" class="headerlink" title="复制SQLite数据库文件导致报错"></a>复制SQLite数据库文件导致报错</h2><p>通过上面的方法解决了运行时报错问题, 但有时我们想看看数据, 直接拷贝运行中程序的SQLite数据库文件, 会导致程序报错, 因为我们复制文件时相当于锁定了该文件, 而程序在不断的读写, 碰到数据库锁定就默认返回了SQLITE_BUSY.</p>
<p>解决方法是, 打开连接后设置一下超时时间(sqlite3_busy_timeout), 一般复制数据库文件不需要多久, 超时时间设置1分钟一般就可以, 可以再设置一下超时后的处理行为(sqlite3_busy_handler), 超时不要崩掉</p>
<h2 id="Upsert"><a href="#Upsert" class="headerlink" title="Upsert"></a>Upsert</h2><p>还在写<code>if exists (select 1 ...) then update ... else insert ... end</code> ?</p>
<p>存在则更新, 否则插入, 很多数据库系统都提供类似操作, 可以使用<strong>数据库引擎 upsert</strong>搜索对应数据库的Upsert方案</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tblGameInfoDaily (RecordDate, RoomID, UserID, Diffs, Bouts, Wins, GiveUps) </span><br><span class="line"><span class="keyword">VALUES</span>(:RecordDate, :RoomID, :UserID, :Diffs, :Bouts, :Wins, :GiveUps) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT(RecordDate, RoomID, UserID) </span><br><span class="line"><span class="keyword">DO</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> Diffs = Diffs + excluded.Diffs, Bouts = Bouts + excluded.Bouts, Wins = Wins + excluded.Wins, GiveUps = GiveUps + excluded.GiveUps</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>ON CONFLICT</code>中的字段, 要么是主键, 要么是UNIQUE KEY, 比如上面表中的三个字段, 其实是一个UNIQUE KEY</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> tblGameInfoDaily(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT,</span><br><span class="line">RecordDate <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">RoomID <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">UserID <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">Diffs <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">Bouts <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">Wins <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">GiveUps <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span>(RecordDate,RoomID,UserID));</span><br></pre></td></tr></table></figure>

<p>在<code>ON CONFLICT</code>之后可以使用<code>excluded.xxx</code>引用传入的数据</p>
<h2 id="数据批量插入"><a href="#数据批量插入" class="headerlink" title="数据批量插入"></a>数据批量插入</h2><p>工作中使用SQLite记录玩家的统计数据, 数据量几万到一百万左右, 需要经常更新或插入, 但是每次数据来只是简单执行一下Upsert, 看了下耗时大概200ms一次操作, 如果碰到高峰期, 请求数据太多, 必然在这里一直堆积</p>
<p>我先用一个缓存结构(list)将短时间内的请求数据都存下, 然后每隔固定时间执行一次批量更新(我这里是1分钟一次)</p>
<ul>
<li>预编译语句</li>
<li>开启事务</li>
<li>循环更新批量数据</li>
<li>提交事务</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sqlite3_exec(db,<span class="string">&quot;begin;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* sql = <span class="string">&quot;insert into t1 values(?,?,?,?)&quot;</span>;</span><br><span class="line">sqlite3_prepare_v2(db,sql,<span class="built_in">strlen</span>(sql),&amp;stmt,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nCount;++i)</span><br><span class="line">&#123;</span><br><span class="line">    sqlite3_reset(stmt);</span><br><span class="line">    sqlite3_bind_int(stmt,<span class="number">1</span>,i);</span><br><span class="line">    sqlite3_bind_int(stmt,<span class="number">1</span>,i*<span class="number">2</span>);</span><br><span class="line">    sqlite3_bind_int(stmt,<span class="number">1</span>,i/<span class="number">2</span>);</span><br><span class="line">    sqlite3_bind_double(stmt,<span class="number">1</span>,i*i);</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_finalize(stmt);</span><br><span class="line">sqlite3_exec(db,<span class="string">&quot;commit;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这里顺便提一下, 使用python的peewee批量插入时有个优化思路是把多条插入数据整合成一条语句</p>
<p>就是原本是循环执行多个<code>INSERT INTO t1 (v1, v2, v3) VALUES (?, ?, ?)</code>, 可以优化为一条语句<code>INSERT INTO t1 (v1, v2, v3) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)</code>一次更新多条数据</p>
<p>需要注意的是, SQLite中的参数个数限制, 默认为999, 就是<code>?</code>的个数不能超过这个值, 详细可见<a href="https://sqlite.org/limits.html">Maximum Number Of Host Parameters In A Single SQL Statement</a></p>
<h2 id="数据不增文件越来越大"><a href="#数据不增文件越来越大" class="headerlink" title="数据不增文件越来越大"></a>数据不增文件越来越大</h2><ul>
<li><p>大量数据删除后, SQLite会留下大量空白数据库页, 但占用的空间不会释放.</p>
</li>
<li><p>频繁的insert/update/delete会让数据库碎片化.</p>
</li>
<li><p>删除的数据只是被标记其存储空间为可再用, 这些数据可能被hacker恢复, 不仅占空间, 而且不安全.</p>
</li>
</ul>
<p>可以在删除/更新大量数据后再执行一下<code>VACUUM</code>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">VACUUM;</span><br></pre></td></tr></table></figure>

<p>该命令会复制数据库中内容到临时文件, 然后清空主数据库, 再从副本中重新载入数据</p>
<p>通过重建数据库, 释放空间, 整理数据, 反碎片化</p>
<p>详细见 <a href="https://sqlite.org/lang_vacuum.html">VACUUM</a></p>
<p><strong>不推荐Aoto-VACUUM</strong></p>
<p>Auto-VACUUM属性必须在数据库文件建立时指定才会有效, 默认该属性为0/“none”, 即不开启</p>
<p>Auto-VACUUM与手动执行的VACUUM不一样, 它只是移动空闲页到数据库末尾, 减小数据库大小, 但这样<strong>会让数据碎片化情况更严重</strong></p>
<p>以下为<a href="https://sqlite.org/pragma.html#pragma_auto_vacuum">官方原文</a></p>
<blockquote>
<p>The default setting for auto-vacuum is 0 or “none”, unless the SQLITE_DEFAULT_AUTOVACUUM compile-time option is used. The “none” setting means that auto-vacuum is disabled.</p>
</blockquote>
<blockquote>
<p>When the auto-vacuum mode is 1 or “full”, the freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages at every transaction commit. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse.</p>
</blockquote>
<h2 id="使用封装好的库"><a href="#使用封装好的库" class="headerlink" title="使用封装好的库"></a>使用封装好的库</h2><p>工作中在C++里使用sqlite3提供的原生接口, 用起来比较吃力, 而且写的代码不好看, 还不安全</p>
<p>同事推荐了个C++的sqlite封装库, <a href="https://github.com/neosmart/CppSQLite">CppSqlite</a>, 用起来舒服多了</p>
<hr>
<p>碰到再加</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>SQLite</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下MinGW-w64安装</title>
    <url>/cpp/win-mingw-w64-install/</url>
    <content><![CDATA[<p>很多时候都必不可少一套GCC/G++编译器</p>
<p>这里我选择MinGW-w64 x86_64-posix-seh</p>
<h2 id="MinGW-amp-MinGW-w64-amp-TDM-GCC"><a href="#MinGW-amp-MinGW-w64-amp-TDM-GCC" class="headerlink" title="MinGW &amp; MinGW-w64 &amp; TDM-GCC"></a>MinGW &amp; MinGW-w64 &amp; TDM-GCC</h2><p>MinGW 只有32位版本  更新较慢 LastUpdate(2018-07-13) 查看日期[2019-11-15]</p>
<p>MinGW-w64 提供32位和64位, 更新快 LastUpdate(11hours ago) 查看日期[2019-11-15]</p>
<p>TDM-GCC 提供32位和64位, 更新较慢 LastUpdate(2015-07-02) 查看日期[2019-11-15]</p>
<p>MinGW-w64的64位和TDM-GCC的64位的区别, 64位的TDM-GCC既能编译64位binary，也能编译32位binary(用-m32参数), 而64位的MinGW-w64只能编译64位binary, 编译32位程序只能再用32位版本的MinGW-w64编辑</p>
<p>看看这个维护活跃度, 还是选择MinGW-w64吧 <a href="https://sourceforge.net/projects/mingw-w64">https://sourceforge.net/projects/mingw-w64</a></p>
<h2 id="MinGW-w64选择"><a href="#MinGW-w64选择" class="headerlink" title="MinGW-w64选择"></a>MinGW-w64选择</h2><blockquote>
<p>以下资料来源于网络, 可以作一个大概了解</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>i686与x86_64 架构选择</p>
<p>32位选择i686 只能编译32位应用</p>
<p>64位选择x86_64 只能编译64位应用</p>
</li>
<li><p>posix与win32 操作系统接口协议</p>
<p>只开发win下运行的程序, 可以选择win32, 这样就不能使用std::thread, 需要使用win的thread接口</p>
<p>同时需要开发其它平台, 选择posix, 可以使用std::thread, 不能使用win的thread接口</p>
<ul>
<li><p>posix: 启用c++11/c11多线程功能. 使depend依赖于libwinpthreads, 这样即使你不直接调用API, 你将分发winpthreads. 使用应用程序分发一个DLL没有什么问题.</p>
</li>
<li><p>win32: 没有C++11多线程功能.</p>
</li>
</ul>
</li>
<li><p>异常处理模型</p>
<p>前面选择32位可以选择dwarf或sjlj</p>
<p>前面选择64位可以选择seh或sjlj</p>
<p>区别:</p>
<ul>
<li>sjlj 古老, 稳定, 性能较慢, 支持32位和64位</li>
<li>seh新发明, 只支持64位, 性能好</li>
<li>dwarf只支持32位, 性能比sjlj好点</li>
</ul>
</li>
</ol>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在MinGW-w64项目主页, 选择files, 在下方选择需要的版本 <a href="https://sourceforge.net/projects/mingw-w64/files/">https://sourceforge.net/projects/mingw-w64/files/</a></p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>将解压的文件夹的bin目录配置到环境变量的PATH中</p>
<p>在命令行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>g++</tag>
        <tag>MinGW-w64</tag>
      </tags>
  </entry>
  <entry>
    <title>使用protobuf3的一些注意点</title>
    <url>/common-library/about-protobuf/</url>
    <content><![CDATA[<p>工作中碰到需求变更, 有时需要改变传输的数据结构, C++结构体增删字段, 还要让lua客户端兼容, 非常吃力, 有时候甚至动态拼接多个结构体, 然后依靠数据长度将一个void*的数据各部分转换为不同的指针, 既复杂又危险</p>
<p>后来为解决这个问题, 引入了Google的protobuf(为结构化数据提供自动高效灵活的支持), 这还真是个好东西, 相对于xml/json/纯结构体, 它的定义文件可读性非常好, 可以添加注释, 使用起来也灵活许多, 而且序列化之后非常小, 可以节省n多流量</p>
<img data-src="/common-library/about-protobuf/why-not-use-xml.png" class="" title="why not use xml">

<p>但是xml/json是自描述, 可读的格式, protobuf结构在序列化之后是不可读的, 需要解析后才能清晰的获取结构中的数据</p>
<p>使用protobuf过程中碰到的问题记录一下</p>
<h2 id="proto3与proto2的区别需要注意"><a href="#proto3与proto2的区别需要注意" class="headerlink" title="proto3与proto2的区别需要注意"></a>proto3与proto2的区别需要注意</h2><p>我们使用的proto3, 记录的都是proto3需要注意的</p>
<h3 id="proto3必须注明版本"><a href="#proto3必须注明版本" class="headerlink" title="proto3必须注明版本"></a>proto3必须注明版本</h3><p>在第一行非空白非注释行，必须写</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>不加这一行, 将以proto2解析</p>
<a id="more"></a>

<h3 id="proto3从语法层面移除了required和optional"><a href="#proto3从语法层面移除了required和optional" class="headerlink" title="proto3从语法层面移除了required和optional"></a>proto3从语法层面移除了required和optional</h3><p>即使proto2中, “required”也是不推荐使用的</p>
<p>proto3默认都是optional, 所以单个值的字段定义, proto2写为</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>而proto3是</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="proto3中的repeated字段默认采用packed编码"><a href="#proto3中的repeated字段默认采用packed编码" class="headerlink" title="proto3中的repeated字段默认采用packed编码"></a>proto3中的repeated字段默认采用packed编码</h3><p>在proto2中需要注明</p>
<h3 id="proto3中没有default选项"><a href="#proto3中没有default选项" class="headerlink" title="proto3中没有default选项"></a>proto3中没有default选项</h3><p>proto3中认为字段默认值只能根据类型由系统决定, 约定为大</p>
<h3 id="proto3中枚举类型第一个字段必须为0"><a href="#proto3中枚举类型第一个字段必须为0" class="headerlink" title="proto3中枚举类型第一个字段必须为0"></a>proto3中枚举类型第一个字段必须为0</h3><p>这是约定</p>
<p>如果业务需求需要从1开始, 可以定义UNKNOWN = 0</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    MOBILE = <span class="number">1</span>;</span><br><span class="line">    HOME = <span class="number">2</span>;</span><br><span class="line">    WORK = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span> [default = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">string</span> email = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="proto3没有分组"><a href="#proto3没有分组" class="headerlink" title="proto3没有分组"></a>proto3没有分组</h3><p>消息嵌套即可</p>
<h2 id="保留字段-protobuf弃用字段处理"><a href="#保留字段-protobuf弃用字段处理" class="headerlink" title="保留字段(protobuf弃用字段处理)"></a>保留字段(protobuf弃用字段处理)</h2><p>工作中碰到弃用的字段直接注释掉了</p>
<p>对于不使用的字段, 直接删除或者注释掉, 以后的用户可能重新使用这个编号或者字段名称而且不会有报错, 可能导致非常隐蔽的bug, 有一种确保不会发生这种情况的方法: 对弃用的字段指定保留标识符(<strong>名称和标识号都指定</strong>), <strong>不要在同一行指定编号和名称</strong></p>
<p>以下为官方原文</p>
<blockquote>
<p>If you update an enum type by entirely removing an enum entry, or commenting it out, future users can reuse the numeric value when making their own updates to the type. This can cause severe issues if they later load old versions of the same .proto, including data corruption, privacy bugs, and so on. One way to make sure this doesn’t happen is to specify that the numeric values (and/or names, which can also cause issues for JSON serialization) of your deleted entries are reserved. The protocol buffer compiler will complain if any future users try to use these identifiers. You can specify that your reserved numeric value range goes up to the maximum possible value using the max keyword.</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>, <span class="number">40</span> to max;</span><br><span class="line">  reserved <span class="string">&quot;FOO&quot;</span>, <span class="string">&quot;BAR&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that you can’t mix field names and numeric values in the same reserved statement.</p>
</blockquote>
<h2 id="proto中的string字段必须UTF-8或者ASCII编码"><a href="#proto中的string字段必须UTF-8或者ASCII编码" class="headerlink" title="proto中的string字段必须UTF-8或者ASCII编码"></a>proto中的string字段必须UTF-8或者ASCII编码</h2><p>工作中碰到使用protobuf解析错误, 原因是字符串编码问题</p>
<p>从ini中读取一段中文, 存入protobuf的string字段中, 服务器发送消息, 客户端解析失败</p>
<p>看了好久才发现, 中文改成英文就解析成功了, 然后去官网查看了下字段说明</p>
<blockquote>
<p>string    A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 2^32.</p>
<p>string字段必须是UTF-8编码或者7bit的ASCII编码</p>
</blockquote>
<p>ini中读取的字符串是GB2312编码, 所以解析出错了</p>
<hr>
<p>碰到再加</p>
]]></content>
      <categories>
        <category>common-library</category>
      </categories>
      <tags>
        <tag>proto3</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code中使用CMake编译调试C++</title>
    <url>/cpp/vscode-cmake-cpp/</url>
    <content><![CDATA[<p>适用于Windows系统</p>
<h2 id="VS-Code的C-环境"><a href="#VS-Code的C-环境" class="headerlink" title="VS Code的C++环境"></a>VS Code的C++环境</h2><ul>
<li><p><a href="https://fetasty.github.io/cpp/win-mingw-w64-install/">安装MingGW</a></p>
</li>
<li><p><code>C/C++</code> 提供基本语言支持, 智能提示</p>
</li>
<li><p><code>CMake</code> 提供CMakeLists文件的智能提示</p>
</li>
<li><p><code>CMake Tools</code> 提供CMake工具链支持</p>
</li>
</ul>
<p>在VS Code设置中可以针对每个扩展进行一些个性化设置</p>
<h2 id="建立项目目录-编写源代码"><a href="#建立项目目录-编写源代码" class="headerlink" title="建立项目目录, 编写源代码"></a>建立项目目录, 编写源代码</h2><p>一般的项目目录结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proj_name&#x2F;</span><br><span class="line">  |- CMakeLists.txt 项目的根cmake文件</span><br><span class="line">  |- LICENSE 项目授权文件</span><br><span class="line">  |- README.MD 项目说明</span><br><span class="line">  |- src&#x2F; 源码目录</span><br><span class="line">    |- module_name&#x2F; 模块源码目录</span><br><span class="line">      |- CMakeLists.txt 模块目录中的cmake文件</span><br><span class="line">    |- CMakeLists.txt src&#x2F;目录中的cmake文件</span><br><span class="line">  |- doc&#x2F; 文档目录</span><br><span class="line">  |- build&#x2F; 构建目录</span><br><span class="line">    |- bin&#x2F; 二进制文件目录</span><br><span class="line">    |- lib&#x2F; 二进制库文件目录</span><br><span class="line">    |- includes&#x2F; 二进制库头文件目录</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="VS-Code中使用CMake调试"><a href="#VS-Code中使用CMake调试" class="headerlink" title="VS Code中使用CMake调试"></a>VS Code中使用CMake调试</h2><p>在编写源文件和CMake文件之后</p>
<p>在项目状态栏 可以看到CMake的一些工具, 可以选择Debug/Release编译环境, 可以选择工具包, 生成文件, 选择生成目标, 或者调试</p>
<p>如果没有看到CMake工具, 先确认CMake Tools正常安装, 或者<code>ctrl + shift + p</code>输入”cmake quick start”看看</p>
<h2 id="GUN风格版本号管理"><a href="#GUN风格版本号管理" class="headerlink" title="GUN风格版本号管理"></a>GUN风格版本号管理</h2><p>一般格式为 主版本号.子版本号[.修正版本号[ build-编译版本号]]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Major.Minor.[.Revision[ Build]]</span><br><span class="line">1.3.10 build-0925</span><br><span class="line">1.3.10</span><br></pre></td></tr></table></figure>

<p>项目最初版本一般为0.1.0</p>
<ul>
<li><p>项目在进行了局部修改或 bug 修正时，主版本号和子版本号都不变，修正版本号加 1</p>
</li>
<li><p>项目在原有的基础上增加了部分功能时，主版本号不变，子版本号加 1，修正版本号复位为 0，因而可以被忽略掉</p>
</li>
<li><p>项目在进行了重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1</p>
</li>
<li><p>如果有编译版本号, 编译版本号一般自动生成, 不人为控制</p>
</li>
</ul>
<h2 id="编写CMakeLists文件"><a href="#编写CMakeLists文件" class="headerlink" title="编写CMakeLists文件"></a>编写CMakeLists文件</h2><p><code>project(myapp [VERSION 3.10.5])</code> 会隐式定义一些cmake变量</p>
<p><code>PROJECT_BINARY_DIR</code> 该变量是构建目录, 也就是<code>cmake xx</code>命令运行目录</p>
<p><code>PROJECT_SOURCE_DIR</code> 该变量是源码目录, 项目根目录</p>
<p><code>PROJECT_VERSION_MAJOR</code> <code>PROJECT_VERSION_MINOR</code> <code>PROJECT_VERSION_PATCH</code> 分别表示Major/Minor/Patch值, 这里是(3/10/5)</p>
<p><code>message(STATUS &quot;&quot; [xx])</code> 可以用于打印一些信息</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;version major: &quot;</span> <span class="variable">$&#123;PROJECT_VERSION_MAJOR&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>有空格的文件名或者路径必须使用双引号包括</strong></p>
<h3 id="项目目录中的CMake"><a href="#项目目录中的CMake" class="headerlink" title="项目目录中的CMake"></a>项目目录中的CMake</h3><p><strong>简单项目</strong></p>
<p>如果项目中比较简单, 没有目录结构, 源文件就在项目根目录, 可以直接一个CMake文件即可</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># myapp/</span></span><br><span class="line"><span class="comment"># 最低要求版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 设置项目名称 版本号</span></span><br><span class="line"><span class="keyword">project</span>(myapp VERSION <span class="number">0.1</span>.<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将源文件列表设置为变量值</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST main.cc func1.cc func2.cc)</span><br><span class="line"><span class="comment"># 根据源文件生成可执行文件 (可执行文件名 源文件列表)</span></span><br><span class="line"><span class="keyword">add_executable</span>(myapp <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 相当于add_executable(myapp main.cc func1.cc func2.cc)</span></span><br><span class="line"><span class="comment"># 生成库文件 库文件名/静态库或者动态库(STATIC|SHARED)/源文件列表</span></span><br><span class="line"><span class="comment"># add_library(mylib STATIC $&#123;SRC_LIST&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>源文件都在src目录中</strong></p>
<p>项目根目录</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># myapp/</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(myapp VERSION <span class="number">0.1</span>.<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 添加子目录, 并指定子目录生成的二进制文件存放位置(相对于build目录 这里是build/bin)</span></span><br><span class="line"><span class="comment"># 构建时, 子目录中的CMakeLists也会被构建</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src bin)</span><br></pre></td></tr></table></figure>

<p>项目的src目录</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># myapp/src/</span></span><br><span class="line"><span class="comment"># 自动扫描给定文件夹中的源文件, 并把源文件列表存到变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(myapp <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># add_library(mylib STATIC $&#123;SRC_LIST&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="引用外部库"><a href="#引用外部库" class="headerlink" title="引用外部库"></a>引用外部库</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(dir1 [dir2 ...])</span><br></pre></td></tr></table></figure>

<p>假设<code>myfun.h</code>在dir1下, 现在就可以在代码中使用<code>#include &quot;myfun.h&quot;</code>引入dir1中的头文件了</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加共享库所在目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(libdir1 [libdir2 ...])</span><br><span class="line"><span class="comment"># 链接共享库 可执行文件名(target 需要先add_executable生成) 库文件名(可省略前缀lib和扩展名.a, 但是要明确表示使用静态库或者动态库, 还是要写出全名)</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">target</span> libname)</span><br></pre></td></tr></table></figure>

<h3 id="引用生成的库"><a href="#引用生成的库" class="headerlink" title="引用生成的库"></a>引用生成的库</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/myfun</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. LIB_MYFUN_SRC_LIST)</span><br><span class="line"><span class="keyword">add_library</span>(myfun STATIC <span class="variable">$&#123;LIB_MYFUN_SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(myfun lib) <span class="comment"># 添加生成静态库</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. MAIN_SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(myapp <span class="variable">$&#123;MAIN_SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp libmyfun.a)</span><br></pre></td></tr></table></figure>

<h3 id="代码中使用CMake中定义的宏"><a href="#代码中使用CMake中定义的宏" class="headerlink" title="代码中使用CMake中定义的宏"></a>代码中使用CMake中定义的宏</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入一个配置头文件，用于处理 CMake 对源码的设置</span></span><br><span class="line"><span class="keyword">configure_file</span> (</span><br><span class="line">  <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/config.h.in&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment"># 是否使用自己的 MathFunctions 库</span></span><br><span class="line"><span class="keyword">option</span> (USE_MYMATH</span><br><span class="line">       <span class="string">&quot;Use provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 是否加入 MathFunctions 库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">  <span class="keyword">include_directories</span> (<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;</span>)</span><br><span class="line">  <span class="keyword">add_subdirectory</span> (<span class="keyword">math</span>)  </span><br><span class="line">  <span class="keyword">set</span> (EXTRA_LIBS <span class="variable">$&#123;EXTRA_LIBS&#125;</span> MathFunctions)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br></pre></td></tr></table></figure>

<p>在项目根目录添加config.h.in文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.h.in</span></span><br><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MAJAR @PROJECT_VERSION_MAJOR@</span></span><br></pre></td></tr></table></figure>

<p>在项目源文件中可以<code>#include &quot;config.h&quot;</code>, 就可以使用其中的宏</p>
<p><a href="https://www.hahack.com/codes/cmake/#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9">CMake入门实战教程</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>VS Code</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>g++生成可执行文件过程简介</title>
    <url>/cpp/gxx-generate-process/</url>
    <content><![CDATA[<p>g++生成可执行文件有四个步骤</p>
<h2 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h2><ul>
<li><p>预处理: 处理条件编译, 头文件展开, 宏展开 (生成<code>.i</code>文件)</p>
</li>
<li><p>编译: 语法解析处理, 生成汇编代码 (生成<code>.s</code>汇编文件)</p>
</li>
<li><p>汇编: 将汇编代码处理为目标机器代码 (生成<code>.o</code>目标文件)</p>
</li>
<li><p>链接: 链接各目标文件, 库文件, 生成二进制可执行程序</p>
</li>
</ul>
<a id="more"></a>

<h2 id="使用g-分阶段处理"><a href="#使用g-分阶段处理" class="headerlink" title="使用g++分阶段处理"></a>使用g++分阶段处理</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -E main.cc &gt; main.i</span><br></pre></td></tr></table></figure>

<p>只进行预处理, 并将结果存到<code>main.i</code>文件中, 可以打开看到各种展开的结果</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -S main.cc &gt; main.s</span><br></pre></td></tr></table></figure>

<p>只进行预处理&amp;编译, 并将结果输出到<code>main.s</code>文件中, 打开可以看到汇编指令</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c main.cc &gt; main.o</span><br></pre></td></tr></table></figure>

<p>进行预处理&amp;编译&amp;汇编, 生成目标文件, 已经是二进制机器码了</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ main.cc -o main</span><br></pre></td></tr></table></figure>

<p>执行预处理&amp;编译&amp;汇编&amp;链接, 生成可执行文件</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索语法</title>
    <url>/other/search-expression/</url>
    <content><![CDATA[<h2 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;如何阅读一本书&quot;</span><br></pre></td></tr></table></figure>

<p>  只搜索包含整个词语的结果, 不会出现只有”阅读”或者”一本书”的结果</p>
<h2 id="排除关键词"><a href="#排除关键词" class="headerlink" title="排除关键词"></a>排除关键词</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何阅读一本书 -孩子</span><br></pre></td></tr></table></figure>

<p>  排除搜索结果中包含”孩子”的结果</p>
<h2 id="包含关键词"><a href="#包含关键词" class="headerlink" title="包含关键词"></a>包含关键词</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何阅读一本书 -孩子 +推荐</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="在特定网站-域名中搜索"><a href="#在特定网站-域名中搜索" class="headerlink" title="在特定网站/域名中搜索"></a>在特定网站/域名中搜索</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何阅读一本书 site:pan.baidu.com</span><br></pre></td></tr></table></figure>

<p>  不要<code>http://</code>, 不加<code>www</code>, 上面的网盘搜索不要使用百度搜索 (Google/duckduckgo/dogedoge)</p>
<h2 id="搜索特定文件类型"><a href="#搜索特定文件类型" class="headerlink" title="搜索特定文件类型"></a>搜索特定文件类型</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何阅读一本书 filetype:pdf</span><br></pre></td></tr></table></figure>

<h2 id="url链接中包含关键字"><a href="#url链接中包含关键字" class="headerlink" title="url链接中包含关键字"></a>url链接中包含关键字</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何阅读 inurl:gov.cn</span><br></pre></td></tr></table></figure>

<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;如何*一本书&quot; filetype:pdf</span><br></pre></td></tr></table></figure>

<h2 id="标题中包含"><a href="#标题中包含" class="headerlink" title="标题中包含"></a>标题中包含</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;如何*一本书&quot; filetype:pdf intitle:大学</span><br></pre></td></tr></table></figure>

<h2 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;如何*一本书&quot; -孩子 filetype:pdf inurl:edu intitle:大学</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">intitle:如何阅读一本书 filetype:pdf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>C++中的静态链接库和动态链接库区别</title>
    <url>/cpp/staticlib-sharedlib-in-cpp/</url>
    <content><![CDATA[<p>稍加总结</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p><strong>静态链接库</strong>是在编译最后一步(链接阶段), 一起打包到可执行文件中</p>
<p><strong>动态链接库</strong>在编译生成阶段没有动作, 而是在程序运行时加载, 加载发生在运行时期, 库文件与执行文件分开, 执行文件依赖于库文件 (不同平台上的动态加载方式并不相同)</p>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>静态库在Windows上为<code>.lib</code>文件, 在Linux上是<code>.a</code>文件</p>
<p>动态库在Windows上为<code>.dll</code>和<code>.lib</code>文件, 在Linux上是<code>.so</code></p>
<a id="more"></a>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>优点:</p>
<ul>
<li><p>被打包到可执行文件中, 可执行文件不再依赖库文件</p>
</li>
<li><p>链接时直接包含库文件, 执行期间代码装载速度快</p>
</li>
</ul>
<p>缺点:</p>
<ul>
<li><p>可执行文件变大 (包含了库文件)</p>
</li>
<li><p>库更新后, 可执行文件也必须重新编译</p>
</li>
<li><p>不可共用, 每个依赖静态库的可执行文件都要包含这个库</p>
</li>
</ul>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>优点:</p>
<ul>
<li><p>多个可执行文件可依赖同一个动态库文件</p>
</li>
<li><p>升级简单, 不需要重新编译可执行文件</p>
</li>
</ul>
<p>缺点:</p>
<ul>
<li><p>运行时加载, 减慢速度</p>
</li>
<li><p>增加程序依赖性, 必须和可执行文件一起</p>
</li>
</ul>
<h2 id="CMake生成"><a href="#CMake生成" class="headerlink" title="CMake生成"></a>CMake生成</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="comment"># STATIC为生存静态库  SHARED生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(mylib STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="CMake使用"><a href="#CMake使用" class="headerlink" title="CMake使用"></a>CMake使用</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(myapp main.cc)</span><br><span class="line"><span class="comment"># 静态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp libmyfun.a)</span><br><span class="line"><span class="comment"># 动态库</span></span><br><span class="line"><span class="comment"># target_link_libraries(myapp libmyfun.so)</span></span><br></pre></td></tr></table></figure>

<p>之后在源码中引入函数声明的头文件, 使用对应函数</p>
<h3 id="代码动态加载"><a href="#代码动态加载" class="headerlink" title="代码动态加载"></a>代码动态加载</h3><p>Windows下和Linux中加载方式不同, 具体可以搜索<code>Windows 动态库使用</code> <code>Linux 动态库使用</code></p>
<p>参考资料: <a href="https://blog.csdn.net/a369189453/article/details/81124685">https://blog.csdn.net/a369189453/article/details/81124685</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>lib</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows上的一些实用小命令/技巧</title>
    <url>/other/tips-on-windows/</url>
    <content><![CDATA[<h2 id="自动关机"><a href="#自动关机" class="headerlink" title="自动关机"></a>自动关机</h2><p>有时候电脑在处理一些任务, 需要一段时间, 但是我不想等, 可以设置一个定时关机, 然后去干自己的事情就好了</p>
<p><code>-s</code> 表示关闭计算机</p>
<p><code>-f</code> 强制执行, 不显示警告</p>
<p><code>-t 7200</code> 定时7200秒(2小时)之后执行</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">shutdown -s -f -t <span class="number">7200</span></span><br></pre></td></tr></table></figure>

<p>突然我又回来了, 又不想让它自动关机了, 可以取消自动关机</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">shutdown -a</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="系统级隐藏"><a href="#系统级隐藏" class="headerlink" title="系统级隐藏"></a>系统级隐藏</h2><p>当然, 这个不是加密, 想看到还是能看到, 但只打开一个显示隐藏文件, 是不会显示的</p>
<p>(查看-&gt;选项-&gt;查看-&gt;取消勾选 隐藏受保护的操作系统文件)</p>
<p>命令格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ATTRIB [+R | -R] [+A | -A ] [+S | -S] [+H | -H] [[drive:] [path] filename] [&#x2F;S [&#x2F;D]]</span><br><span class="line">+ 设置属性</span><br><span class="line">- 清除属性</span><br><span class="line">R 只读文件属性</span><br><span class="line">A 存档文件属性</span><br><span class="line">S 系统文件属性</span><br><span class="line">H 隐藏文件属性</span><br><span class="line">&#x2F;S 处理当前文件夹及其子文件夹中的匹配文件</span><br><span class="line">&#x2F;D 处理文件夹</span><br><span class="line">或者直接运行attrib可以查看当前文件夹下所有文件的属性</span><br><span class="line">attrib &lt;filename&gt;查看指定文件属性</span><br><span class="line">attrib &lt;filename&gt; +S +H +R添加属性</span><br><span class="line">attrib &lt;filename&gt; -S -H -R去除属性</span><br></pre></td></tr></table></figure>

<h3 id="U盘设置自定义图标"><a href="#U盘设置自定义图标" class="headerlink" title="U盘设置自定义图标"></a>U盘设置自定义图标</h3><p>准备一个自己的ico图标my.ico放在根目录</p>
<p>u盘根目录中新建文件autorun.inf</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[autorun]</span></span><br><span class="line"><span class="attr">icon</span>=my.ico</span><br></pre></td></tr></table></figure>

<p>之后命令行隐藏这两个文件</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">attrib</span> my.ico +S +H +R</span><br><span class="line"><span class="built_in">attrib</span> autorun.inf +S +H +R</span><br></pre></td></tr></table></figure>

<h3 id="U盘病毒常用隐藏方法"><a href="#U盘病毒常用隐藏方法" class="headerlink" title="U盘病毒常用隐藏方法"></a>U盘病毒常用隐藏方法</h3><p>U盘中毒时, 可能会隐藏U盘下所有文件, 只显示病毒本体, 引诱用户点击</p>
<p>看到U盘异常时, 先去掉U盘中所有文件和文件夹隐藏属性</p>
<p>Windows默认隐藏文件后缀名, 建议默认打开后缀名显示</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">attrib</span> autorun.inf -a -s -r -h # 去掉autorun.inf的四种属性</span><br><span class="line"><span class="built_in">attrib</span> *.* -a -s -r -h # 还原所有被隐藏的文件</span><br><span class="line"><span class="built_in">attrib</span> /d /s +a -s -h -r # 还原所有被隐藏文件夹</span><br></pre></td></tr></table></figure>

<h2 id="命令行关闭进程"><a href="#命令行关闭进程" class="headerlink" title="命令行关闭进程"></a>命令行关闭进程</h2><p>碰到过一个应用, 会开启2个进程, 互相保护, 任务管理器中只能一个个关, 但是关一个另一个马上新开一个进程..</p>
<p>Windows任务管理器详细信息中有每个进程的进程名和进程PID</p>
<p>可以存为bat后缀文件双击运行</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">taskkill</span> /im ThunderPlatform.exe # 通过进程名关闭进程</span><br><span class="line"><span class="built_in">taskkill</span> /pid <span class="number">4472</span> # 通过PID关闭进程</span><br></pre></td></tr></table></figure>

<h2 id="显示所有windows工具-上帝模式"><a href="#显示所有windows工具-上帝模式" class="headerlink" title="显示所有windows工具 (上帝模式)"></a>显示所有windows工具 (上帝模式)</h2><p>新建文件夹, 命名为 <code>上帝模式.&#123;ED7BA470-8E54-465E-825C-99712043E01C&#125;</code></p>
<h2 id="一些特殊字符的快速输入"><a href="#一些特殊字符的快速输入" class="headerlink" title="一些特殊字符的快速输入"></a>一些特殊字符的快速输入</h2><p>有些字符很常用, 但找起来不容易</p>
<p>按住Alt, 键入对应字符的<strong>Unicode编码十进制数字</strong>, 然后松开Alt</p>
<p><code>191</code> <code>¿</code></p>
<p><code>41420</code> <code>√</code></p>
<p><code>215</code> <code>×</code></p>
<p><code>169</code> <code>©</code></p>
<p><code>153</code> <code>™</code></p>
<p>更多的字符编码可以查阅<a href="https://unicode-table.com/">Unicode Table</a>, 找到对应字符的HTML Code后面的十进制数字 (不一定全部管用)</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序&amp;优化</title>
    <url>/algorithm/quick-sort/</url>
    <content><![CDATA[<p>快速排序是一种不稳定的排序方法, 一般情况下的复杂度为$O(n\log n)$, 效率主要取决于每次选取的中枢值是不是能比较平均的划分数列</p>
<h2 id="简单快速排序"><a href="#简单快速排序" class="headerlink" title="简单快速排序"></a>简单快速排序</h2><p>最基本的快排思路比较简单, 首先选取一个中枢值(pivot), 然后对其它数据进行划分, 小于pivot的放左边, 不小于pivot的数字放右边, 然后递归对两边数据划分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单快排 [start, end)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SimpleQuickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">end</span> - start &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span>; &#125; <span class="comment">// 递归退出条件</span></span><br><span class="line">  <span class="comment">// 以start位置的值作为中枢</span></span><br><span class="line">  <span class="keyword">int</span> pivot = arr[start]; <span class="comment">// start位置的值暂存在pivot中, arr[start]可以作为一个空位使用</span></span><br><span class="line">  <span class="keyword">int</span> i = start;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="built_in">end</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 一趟划分</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="comment">// 从右往左找到一个&lt;pivot的值, 填在i所在的空位, j所在位置变成空位</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt;= pivot) &#123; --j; &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从左往右找到一个&gt;=pivot的值, 填在j所在空位, i位置变成空位</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; pivot) &#123; ++i; &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        --j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在这里必有 i == j 且指向空位, 此时将pivot填入该位置</span></span><br><span class="line">  <span class="comment">// assert(i == j);</span></span><br><span class="line">  arr[i] = pivot;</span><br><span class="line">  <span class="comment">// [start, i)都是&lt;pivot的值, 而(i, end)都是&gt;=pivot的值, 递归划分; (i位置必定是pivot, 它在正确位置)</span></span><br><span class="line">  <span class="comment">// 这里需要注意无法退出的递归, 要保证递归后的规模一定小于当前规模 (考虑循环完后i是否可能等于start或者end)</span></span><br><span class="line">  SimpleQuickSort(arr, start, i);</span><br><span class="line">  SimpleQuickSort(arr, i + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>简单测试一下:</p>
<ul>
<li><p>先排100个数字看看正确性</p>
<img data-src="/algorithm/quick-sort/simple-quicksort-test1.png" class="" title="正确性">
</li>
<li><p>100w随机数(生成范围0-1000000)排序用时, 还挺快的</p>
<img data-src="/algorithm/quick-sort/simple-quicksort-test2.png" class="" title="100w随机数">
</li>
<li><p>100w有较多重复数字时(生成范围0-100)</p>
<img data-src="/algorithm/quick-sort/simple-quicksort-test3.png" class="" title="100w重复率高的数字">

<p>可以看到效率明显下降了</p>
</li>
<li><p>100w的有序数列(0, 1, … 100w-1)<br>emm… 100w的有序数列直接跑半天没结果, 改成了10w有序数列</p>
<img data-src="/algorithm/quick-sort/simple-quicksort-test4.png" class="" title="10w有序数字">

<p>这效率下降的不是一星半点了</p>
</li>
</ul>
<h2 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h2><p>网上搜索得到几种快排的优化方法:</p>
<ol>
<li><p><strong>三值取中</strong> 中枢值单纯选择最左位置, 效果可能不佳, 从start, mid, end - 1三个位置取中位数, 可以选出较好的中枢</p>
</li>
<li><p><strong>等值聚集</strong> 与中枢pivot相等的数字单纯划分到一边, 也会导致划分不平衡, 增加迭代次数, 特别是重复数字较多的时候; 所以最好把相等的数字单独处理</p>
</li>
<li><p><strong>少数插排</strong> 插入排序复杂度为$O(n^2)$, 但是在数据量较少时, 快排的效率不如插入排序好, 可以在快速排序划分到较小区块时使用插入排序</p>
</li>
</ol>
<p>只接使用start位置作为中枢值, 在数列有序时, 这种做法每次都是最不平均的划分, 直接让算法退化为$O(n^2)$, 随机取中枢值好一点, 但是有较高随机性, 相比而言, 三值取中是一个比较好的选取中枢的方法; 在数据比较有序时, 插入排序可以避免不必要的交换; 在数据重复量比较大时, 等值聚集和插入排序都可以节省大量时间, 让数据规模迅速缩小.</p>
<p>选取这三种优化方法, 改进一下快排:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序 [start, end)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">end</span> - start &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = arr[i];</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">for</span> (; j &gt; start &amp;&amp; value &lt; arr[j - <span class="number">1</span>]; --j) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快排 + 三值取中 + 等值聚集 + 少数插排 [start, end)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">end</span> - start &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="comment">// 少数插排 我这里设置为10, 数据量不超过10时使用插入排序</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">end</span> - start &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    InsertionSort(arr, start, <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 三值取中 中位数放在start位置</span></span><br><span class="line">  <span class="keyword">int</span> mid = start + ((<span class="built_in">end</span> - start) &gt;&gt; <span class="number">1</span>); <span class="comment">// +的优先级高于&gt;&gt;, 要注意下</span></span><br><span class="line">  <span class="keyword">if</span> (arr[<span class="built_in">end</span> - <span class="number">1</span>] &lt; arr[start]) &#123; <span class="built_in">std</span>::swap(arr[<span class="built_in">end</span> - <span class="number">1</span>], arr[start]); &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[<span class="built_in">end</span> - <span class="number">1</span>] &lt; arr[mid]) &#123; <span class="built_in">std</span>::swap(arr[<span class="built_in">end</span> - <span class="number">1</span>], arr[mid]); &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[start] &lt; arr[mid]) &#123; <span class="built_in">std</span>::swap(arr[start], arr[mid]); &#125;</span><br><span class="line">  <span class="comment">// 划分 与pivot相等的值移动到两端</span></span><br><span class="line">  <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">  <span class="keyword">int</span> i = start;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="built_in">end</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> leq = <span class="number">0</span>; <span class="comment">// i从左向右碰到的==pivot的元素个数</span></span><br><span class="line">  <span class="keyword">int</span> req = <span class="number">0</span>; <span class="comment">// j从右向左碰到的==pivot的元素个数</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pivot &lt; arr[j]) &#123; --j; &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从右向左碰到==pivot的元素, 移动到右边, 并增加计数, j向左移动</span></span><br><span class="line">        <span class="built_in">std</span>::swap(arr[j], arr[<span class="built_in">end</span> - <span class="number">1</span> - req]);</span><br><span class="line">        ++req;</span><br><span class="line">        --j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; pivot) &#123; ++i; &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pivot &lt; arr[i]) &#123;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        --j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从左向右碰到==pivot的元素, 移动到左边, 增加计数, i向右移动</span></span><br><span class="line">        <span class="built_in">std</span>::swap(arr[i], arr[start + leq]);</span><br><span class="line">        ++leq;</span><br><span class="line">        ++i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// assert(i == j);</span></span><br><span class="line">  arr[i] = pivot;</span><br><span class="line">  <span class="comment">// 等值聚集 将移动到两端的与pivot相等的值移动到中间位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; leq; ++k) &#123; <span class="built_in">std</span>::swap(arr[start + k], arr[i - <span class="number">1</span> - k]); &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; req; ++k) &#123; <span class="built_in">std</span>::swap(arr[<span class="built_in">end</span> - <span class="number">1</span> - k], arr[i + <span class="number">1</span> + k]); &#125;</span><br><span class="line">  <span class="comment">// 递归处理</span></span><br><span class="line">  QuickSort(arr, start, i - leq); <span class="comment">// &lt;pivot的元素</span></span><br><span class="line">  QuickSort(arr, i + <span class="number">1</span> + req, <span class="built_in">end</span>); <span class="comment">// &gt;pivot的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单测试: </p>
<p>从上到下依次为 100w随机数(0-1000000), 100w较多重复数字(0-10), 100w有序数字(0, 1, … 100w-1), 100w倒序数字</p>
  <img data-src="/algorithm/quick-sort/quicksort.png" class="" title="quicksort结果">

<p>从测试结果可以看出来, 优化后的快排效果还是很不错的, 在绝大多数数情况下都能达到$O(n\log n)$ (极少情况: 比如设计一个数组, 让上述的三值取中每次都取到一个最不平衡的中枢值, 让排序的每次划分都是不理想的)</p>
<p>测试环境:</p>
<p>Win10 &amp; gcc8.1.0 &amp; RelWithDebInfo &amp; QN8H &amp; RAM8G</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>查资料时发现快排其实有很多种实现方法, 其中有一个”三轴双向”的快排实现也比较有意思</p>
<ol>
<li><p>使用i, k, j三个指向变量, 初始时<code>i = start</code>, <code>k = start + 1</code>, <code>j = end - 1</code>, <code>pivot = arr.at(start)</code></p>
</li>
<li><p>保持i指向第一个等于pivot的位置, i之前的元素都是小于pivot, k指向最后一个等于pivot的元素下一位置, j之后的元素都是大于pivot</p>
</li>
<li><p>判断k位置的元素, 若小于pivot, 则swap(i, k), 然后<code>i++</code>, <code>k++</code>, 再次执行本步骤; 若等于pivot, 则<code>k++</code>, 再次执行本步骤; 若大于pivot, 则转第4步</p>
</li>
<li><p>判断j位置的元素, 若小于pivot, 则swap(j, k), 然后<code>j--</code>, 转第3步; 若等于pivot, 则swap(j, k), 然后<code>j--</code>, <code>k++</code>, 再次执行本步; 若大于pivot, 则<code>j--</code>, 再次执行本步骤</p>
</li>
<li><p>第3步和第4步循环直到k &gt; j退出, 因为k, j指向的其实都是未扫描元素, <code>k == j</code>时, 指向的元素并未扫描</p>
</li>
<li><p>递归处理<code>[start, i)</code>和<code>[j+1, end)</code>, <code>[i, k)</code>部分则是等于pivot的元素</p>
</li>
</ol>
<p>还有双轴快排, 选取两个值作为中枢, 比较次数变多, 交换次数变少, 因为现在的硬件情况是CPU性能比较强悍, 远超过RAM的速度, 所以把较多的任务交给CPU处理, 而尽量少的使用内存也可以有意想不到的效果, 有兴趣的朋友可以看看</p>
<p><a href="https://www.cnblogs.com/nullzx/p/5880191.html">图文并茂的参考资料</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉堆&amp;堆排序</title>
    <url>/algorithm/binary-heap/</url>
    <content><![CDATA[<h2 id="二叉堆的性质"><a href="#二叉堆的性质" class="headerlink" title="二叉堆的性质"></a>二叉堆的性质</h2><ul>
<li><p>二叉堆是完全二叉树(除了最底层外其它层节点个数达到最大, 最底层节点都集中在最左边)</p>
</li>
<li><p>一般存储在数组结构中, 父子节点之间依靠下标关联</p>
</li>
<li><p>堆分为最大堆和最小堆, 最大堆就是所有父节点值都不小于它的任意子节点值, 头节点为最大值; 最小堆相反. (以下默认最大堆)</p>
</li>
<li><p><strong>从0开始存储的二叉堆, 节点i的子节点为<code>(i&lt;&lt;1)+1</code>和<code>(i&lt;&lt;1)+2</code>, 节点i的父节点为<code>(i-1)&gt;&gt;1</code></strong></p>
</li>
<li><p>n个节点的二叉堆, 最后一个非叶节点下标为<code>(n&gt;&gt;1)-1</code></p>
</li>
<li><p>高为h的满二叉树有$2^h-1$个节点, 第i(1, 2…h)层有$2^{h-1}$个节点</p>
</li>
</ul>
<a id="more"></a>

<h2 id="二叉堆构建维护"><a href="#二叉堆构建维护" class="headerlink" title="二叉堆构建维护"></a>二叉堆构建维护</h2><p>二叉堆的建立和维护主要有三个操作ShiftUp, ShiftDown, Heapify</p>
<ul>
<li><p>ShiftUp(i) 从节点i开始循环向上调整, 若<code>父节点值</code>小于<code>i节点值</code>则交换父节点与i, i=父节点; 直到<code>父节点值</code>不小于<code>i节点值</code>, 或者i为0. 该操作复杂度为$O(\log n)$</p>
</li>
<li><p>ShiftDown(i) 从节点i开始循环向下调整, 若<code>i节点值</code>小于<code>较大子节点值</code>则交换i和较大的子节点, i=较大子节点; 直到<code>i节点值</code>不小于<code>较大子节点值</code>, 或者i为叶子节点. 操作复杂度为$O(\log n)$</p>
</li>
<li><p>Heapify(arr) 从现有数组构造二叉堆, 具体做法是从最后一个非叶节点直到节点0, 对每个节点做ShiftDown调整. 该过程复杂度为$O(n)$</p>
</li>
</ul>
<p>上述的ShiftUp和ShiftDown中的交换操作可以优化为赋值操作, 建堆使用Heapify相对于逐个插入元素并ShiftUp的好处是, Heapify只对非叶节点调整, 逐个插入元素需要对每个节点都做ShiftUp调整, 可以省去一半节点的调整操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ShiftUp 从将i节点向上调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShiftUp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> value = arr.at(i);</span><br><span class="line">  <span class="comment">// 如果i节点值比父节点大, 则arr[i] = arr[parent], i = parent</span></span><br><span class="line">  <span class="comment">// 循环直到i节点值不大于父节点, 或者i为0</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> parent = (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parent_value = arr.at(parent);</span><br><span class="line">    <span class="keyword">if</span> (!(parent_value &lt; value)) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    arr.at(i) = arr.at(parent);</span><br><span class="line">    i = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  arr.at(i) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ShiftDown 堆大小为size, 将i节点向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShiftDown</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">2</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> value = arr.at(i);</span><br><span class="line">  <span class="keyword">while</span> (i &lt; (<span class="built_in">size</span> &gt;&gt; <span class="number">1</span>)) &#123; <span class="comment">// 最后一个非叶节点为 (size&gt;&gt;1)-1</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = (i&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左节点</span></span><br><span class="line">    <span class="keyword">int</span> right = (i&lt;&lt;<span class="number">1</span>) + <span class="number">2</span>; <span class="comment">// 右节点</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="built_in">size</span> &amp;&amp; arr.at(<span class="built_in">max</span>) &lt; arr.at(right)) &#123; <span class="built_in">max</span> = right; &#125;</span><br><span class="line">    <span class="comment">// i与较大的子节点比较, arr.at(i)经过一次循环变成空位, 应该使用value</span></span><br><span class="line">    <span class="keyword">if</span> (!(value &lt; arr.at(<span class="built_in">max</span>))) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="comment">// 若i节点值小于最大子节点, 则arr[i] = arr[max], i = max; 直到i节点不小于子节点或者i为叶子节点</span></span><br><span class="line">    arr.at(i) = arr.at(<span class="built_in">max</span>);</span><br><span class="line">    i = <span class="built_in">max</span>; <span class="comment">// i变成空位</span></span><br><span class="line">  &#125;</span><br><span class="line">  arr.at(i) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Heapify 将现有的数组arr调整为堆 (原位建堆)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对每个非叶节点(size&gt;&gt;1)-1到0, 执行ShiftDown调整</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = (arr.<span class="built_in">size</span>()&gt;&gt;<span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    ShiftDown(arr, arr.<span class="built_in">size</span>(), i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉堆的应用"><a href="#二叉堆的应用" class="headerlink" title="二叉堆的应用"></a>二叉堆的应用</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>作为优先队列使用, 主要有两个操作</p>
<ol>
<li><p>插入节点</p>
<p>插入新节点到二叉堆数组末端, 对该节点做ShiftUp调整即可</p>
</li>
<li><p>取头节点</p>
<p>头节点值赋值给其它变量(取出), 将数组末尾元素赋值给头节点, 删除末尾元素, 长度减1, 并对头节点做ShiftDown调整</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert 假设arr前size个节点是堆, 将节点插入到下标size处, 对该节点ShiftUp调整, ++size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span>&amp; <span class="built_in">size</span>, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  arr.insert(arr.cbegin() + <span class="built_in">size</span>, value);</span><br><span class="line">  ShiftUp(arr, <span class="built_in">size</span>);</span><br><span class="line">  ++<span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PopHead 取头节点, 先拿到头节点的值, 将未节点赋值给头节点, erase末节点, --size, 再ShiftDown(0) (顺序不能错)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PopHead</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span>&amp; <span class="built_in">size</span>, <span class="keyword">int</span>&amp; head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> head = arr.at(<span class="number">0</span>);</span><br><span class="line">  arr.at(<span class="number">0</span>) = arr.at(<span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">  arr.erase(arr.cbegin() + <span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">  --<span class="built_in">size</span>;</span><br><span class="line">  ShiftDown(arr, <span class="built_in">size</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序和归并排序都是渐进最优的, 任何情况下的复杂度都是$O(n\log n)$</p>
<p>堆排序是一种不稳定的排序方法, 使用原位堆排序可以省去空间的开销</p>
<p>具体操作是先原位Heapify构造堆, 然后循环执行以下步骤:</p>
<p>交换堆的头尾节点, 将堆大小减1(不移除末尾元素), 对头节点进行ShiftDown调整</p>
<p>直到堆大小变成1, 排序完成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HeapSort</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">  Heapify(arr);</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = arr.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">size</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(arr.at(<span class="number">0</span>), arr.at(<span class="built_in">size</span> - <span class="number">1</span>));</span><br><span class="line">    --<span class="built_in">size</span>;</span><br><span class="line">    ShiftDown(arr, <span class="built_in">size</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序简单测试(100w随机数, 100w高重复率数字, 100w有序数字, 100w倒序数字):</p>
<img data-src="/algorithm/binary-heap/heapsort.png" class="" title="堆排序">

<p>测试环境:</p>
<p>Win10 &amp; gcc8.1.0 &amp; RelWithDebInfo &amp; QN8H &amp; RAM8G</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Sort</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序(非递归&amp;不回写)</title>
    <url>/algorithm/merge-sort/</url>
    <content><![CDATA[<blockquote>
<p>归并排序和堆排序是两种渐进最优排序算法, 任何情况下的复杂度都是$O(n\log n)$</p>
</blockquote>
<p>MergeSort是分治思想的实现, 把大问题划分为小的容易解决的问题逐步解决, 主要操作是Merge(把两个有序的数列合并为一个有序数列)</p>
<p>它需要一个相同长度的数组作为临时空间使用, 空间复杂度为$O(n)$</p>
<p>MergeSort是一种<strong>稳定的排序算法</strong></p>
<a id="more"></a>

<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>简单的递归式归并排序非常容易, 网上随便搜一大堆, 大致如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LENGTH = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> temp[LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 合并[start, mid)和[mid, end)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; <span class="built_in">end</span>; ++i) &#123; temp[i] = arr[i]; &#125;</span><br><span class="line">  <span class="keyword">int</span> left = start;</span><br><span class="line">  <span class="keyword">int</span> right = mid;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= mid) &#123; arr[i] = temp[right++]; &#125; <span class="comment">// 左边用尽</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= <span class="built_in">end</span>) &#123; arr[i] = temp[left++]; &#125; <span class="comment">// 右边用尽</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (temp[right] &lt; temp[left]) &#123; arr[i] = temp[right++]; &#125; <span class="comment">// 右边较小</span></span><br><span class="line">    <span class="keyword">else</span> &#123; arr[i] = temp[left++]; &#125; <span class="comment">// 左边不大于右边</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序arr, [start, end)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = start + ((<span class="built_in">end</span> - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    MergeSort(arr, start, mid);</span><br><span class="line">    MergeSort(arr, mid, <span class="built_in">end</span>);</span><br><span class="line">    Merge(arr, start, mid, <span class="built_in">end</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[LENGTH];</span><br><span class="line">  <span class="comment">// 在arr中放随机数</span></span><br><span class="line">  MergeSort(arr, <span class="number">0</span>, LENGTH);</span><br><span class="line">  <span class="comment">// 检查排序结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化的思路:</p>
<ol>
<li><p>需要使用的临时数组在开始就申请好, 而不是每次merge操作都用一个临时数组, 上面已经作到了</p>
</li>
<li><p>自底向上归并 上面的自上而下的归并需要递归处理, 而递归又使用栈空间, 增加空间和性能消耗</p>
</li>
<li><p>不回写 上面的归并, 每次都从arr拷贝到temp, 再从temp归并到arr, 额外操作很多; 其实可以不回写, 第一次直接从arr归并到temp, 下一次再从temp归并到arr, 减少额外的操作</p>
</li>
<li><p>可以考虑数字较少时改用插入排序</p>
</li>
</ol>
<p>自底向上归并思路如图:</p>
<img data-src="/algorithm/merge-sort/mergesort-think.png" class="" title="mergesort-think">

<h2 id="无栈-amp-非递归-amp-不回写的归并"><a href="#无栈-amp-非递归-amp-不回写的归并" class="headerlink" title="无栈&amp;非递归&amp;不回写的归并"></a>无栈&amp;非递归&amp;不回写的归并</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以步长step从src合并到dis</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; src, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dis, <span class="keyword">int</span> <span class="built_in">step</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = src.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 每次循环合并[i, i + step)和[i + step, i + 2*step);</span></span><br><span class="line">  <span class="comment">// i + step &lt; size说明 [i + step, size)不为空, 还需要合并; i每次增加2*step</span></span><br><span class="line">  <span class="keyword">for</span> (; i + <span class="built_in">step</span> &lt; <span class="built_in">size</span>; i += (<span class="built_in">step</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// mid, end作为分割位, 不能更改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mid = i + <span class="built_in">step</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">end</span> = (mid + <span class="built_in">step</span> &lt; <span class="built_in">size</span>) ? (mid + <span class="built_in">step</span>) : <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int</span> left = i; <span class="comment">// [left, mid)为左边剩下的</span></span><br><span class="line">    <span class="keyword">int</span> right = mid; <span class="comment">// [right, end)为右边剩下的</span></span><br><span class="line">    <span class="comment">// 合并 [i, mid), [mid, end)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">end</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &gt;= mid) &#123; dis.at(j) = src.at(right++); &#125; <span class="comment">// 左边用尽</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= <span class="built_in">end</span>) &#123; dis.at(j) = src.at(left++); &#125; <span class="comment">// 右边用尽</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (src.at(right) &lt; src.at(left)) &#123; dis.at(j) = src.at(right++); &#125; <span class="comment">// 右边较小</span></span><br><span class="line">      <span class="keyword">else</span> &#123; dis.at(j) = src.at(left++); &#125; <span class="comment">// 左边不大于右边</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 剩下未处理的数据也要复制过去 (很重要)</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; <span class="built_in">size</span>; ++i) &#123; dis.at(i) = src.at(i); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(arr)</span></span>; <span class="comment">// 临时数组</span></span><br><span class="line">  <span class="keyword">bool</span> to_temp = <span class="literal">false</span>; <span class="comment">// 是否合并到临时数组</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>; <span class="comment">// 步长从1开始, 每次乘2</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">step</span> &lt; arr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    to_temp = !to_temp;</span><br><span class="line">    <span class="comment">// 三元表达式后两个参数是类型相同的左值, 因此表达式值也是左值</span></span><br><span class="line">    Merge(to_temp ? arr : temp, to_temp ? temp : arr, <span class="built_in">step</span>);</span><br><span class="line">    <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_temp) &#123; <span class="comment">// 最后一次合并到临时数组, 则拷贝回来</span></span><br><span class="line">    arr.assign(temp.cbegin(), temp.cend());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意各边界条件的处理, 还有未处理数据的复制, 最后一次归并如果是归并到临时数组了, 需要拷贝回来; 我粗心大意的错了好几次才调对</p>
<p>下面是简单测试的结果(100w随机数, 100w高重复率数字, 100w有序数字, 100w倒序数字):</p>
<img data-src="/algorithm/merge-sort/mergesort.png" class="" title="mergesort">

<p>测试环境:</p>
<p>Win10 &amp; gcc8.1.0 &amp; RelWithDebInfo &amp; QN8H &amp; RAM8G</p>
<p>参考资料:</p>
<p><a href="https://www.cnblogs.com/dlutxm/archive/2011/11/04/2236594.html">归并排序非递归+不回写优化实现</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的值类型/引用类型和参数传递</title>
    <url>/golang/golang-param-pass/</url>
    <content><![CDATA[<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>Go里边函数传参只有值传递一种方式</strong>(调用函数时将实际参数复制一份传递到函数中, 函数中对参数进行修改将不会影响实际参数)</p>
<p>刚开始听到这个结论, 觉得不可思议, 因为实际给函数传递一个slice/map/chan类型的参数, 在函数内改变该参数的值会影响到函数外的变量值, 这看起来像是引用传递</p>
<p>实际上, slice, map, channel都是<strong>结构体类型的值传递</strong>, 但是<strong>结构体中包含指向实际数据的指针</strong>, 所以它们是值传递, 而并非引用传递</p>
<a id="more"></a>

<h2 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h2><p>Go语言中的slice, map, channel都是引用类型, 这个引用和Python相似, 和C++不同</p>
<h3 id="C-中的引用"><a href="#C-中的引用" class="headerlink" title="C++中的引用"></a>C++中的引用</h3><p>C语言中没有引用类型, 但C++中实现了引用类型, 这个引用是编译器通过指针实现的, 让引用用起来像”别名”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="comment">// b为引用, 编译后其实是用指针实现</span></span><br><span class="line">    b = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">change(a);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中, 如果编译后进行反编译查看汇编代码, 会发现底层是将int变量地址(int*)作为参数传递, C++中的引用是编译器通过指针实现, 是编译器实现的一个语法糖</p>
<h3 id="Go和Python中的引用"><a href="#Go和Python中的引用" class="headerlink" title="Go和Python中的引用"></a>Go和Python中的引用</h3><p>Go和Python中的引用其实是struct中包含指针, 当赋值/传递参数时, 会发生struct的复制, struct中的指针被一起复制, 主要数据没有发生复制, 两个struct中的指针指向同一块内存, 用起来和”引用”一样</p>
<p>底层实现我也没有深入研究, 这里看看Go语言的slice结构(<a href="https://github.com/golang/go/blob/master/src/runtime/slice.go">slice源码</a>), 就能理解了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slice</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice其实是一个包含指针的结构体, 现在说Go语言中只有值传递就很好理解了, 当传递一个slice参数, 其实是结构体的值传递, 结构体中的指针指向同一内存区域, 所以函数中的数据操作也会影响函数外的slice值</p>
<h2 id="Go语言中的常见引用类型和值类型"><a href="#Go语言中的常见引用类型和值类型" class="headerlink" title="Go语言中的常见引用类型和值类型"></a>Go语言中的常见引用类型和值类型</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型进行赋值/参数传递时, 实际时将内存中的值进行了拷贝, <strong>数据/结构体是值类型也进行了拷贝</strong></p>
<ul>
<li><p>int, float, bool, string 等基本类型</p>
</li>
<li><p>数组, 结构体</p>
</li>
<li><p>指针</p>
</li>
</ul>
<p>再次提醒, Go中的string/数组是值类型, 赋值时进行了拷贝, 拷贝后的变量修改不会影响原变量的值, 这和C++中的完全不同, 如果你和我一样之前是使用C++语言, 这里要特别注意</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>记住Go语言中的引用类型其实是包含指针的struct, 该struct还是值类型</p>
<ul>
<li>slice, map, chan等</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//数组</span></span><br><span class="line">b := a</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[99 2 3 4 5]</span></span><br><span class="line">c := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//slice, 这里想一下slice的struct结构</span></span><br><span class="line">d := c</span><br><span class="line">d[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[99 2 3 4 5]</span></span><br><span class="line">fmt.Println(d) <span class="comment">//[99 2 3 4 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h2><p>Go语言如果需要在函数中修改传入的实际参数的变量值, 应该使用指针接收者</p>
<p>也就是说对于<code>func (a *T) test() &#123;&#125;</code>, 函数接收者可以是T类型, 并且函数中对a的修改会影响函数外的变量值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T struct</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a T)</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a.x = <span class="number">100</span></span><br><span class="line">    a.y = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *T)</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a.x = <span class="number">99</span></span><br><span class="line">    a.y = <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := T&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(v) <span class="comment">//&#123;1 2&#125;</span></span><br><span class="line">    v.test1()</span><br><span class="line">    fmt.Println(v) <span class="comment">//&#123;1 2&#125;, 接收者传入是以值传递, struct复制</span></span><br><span class="line">    v.test2()</span><br><span class="line">    fmt.Println(v) <span class="comment">//&#123;99 99&#125;, 接收者传入是指针值传递, 指针复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于需要指针函数的函数, 则只能接受指针类型参数;<br>而接收者类型为指针时, 接收者可以是指针也可以是值, 传入值参数自动解释为指针(&amp;v);<br>接收者类型为值类型时, 接收者可以是值也可以是指针, 传入指针类型自动解释为值类型(*p).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T struct</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(a *T)</span></span> &#123;</span><br><span class="line">    a.x = <span class="number">1</span></span><br><span class="line">    a.y = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *T)</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a.x = <span class="number">2</span></span><br><span class="line">    a.y = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a T)</span> <span class="title">test3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a.x = <span class="number">3</span></span><br><span class="line">    a.y = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := T&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">	p := &amp;v</span><br><span class="line">	fmt.Println(v) <span class="comment">//&#123;0 0&#125;</span></span><br><span class="line">	test1(p)</span><br><span class="line">	<span class="comment">// test1(v) //编译出错</span></span><br><span class="line">	fmt.Println(v) <span class="comment">//&#123;1 1&#125;</span></span><br><span class="line">	p.test2()</span><br><span class="line">	fmt.Println(v) <span class="comment">//&#123;2 2&#125;</span></span><br><span class="line">	v = T&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">	fmt.Println(v) <span class="comment">//&#123;0 0&#125;</span></span><br><span class="line">	v.test2()      <span class="comment">//自动解释为(&amp;v).test2()</span></span><br><span class="line">	fmt.Println(v) <span class="comment">//&#123;2 2&#125;</span></span><br><span class="line">	v.test3()</span><br><span class="line">	p.test3()      <span class="comment">//自动解释为(*p).test3()</span></span><br><span class="line">	fmt.Println(v) <span class="comment">//&#123;2 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料:</p>
<p><a href="https://zhuanlan.zhihu.com/p/84580859">一文理清 Go 引用的常见疑惑</a></p>
<p><a href="https://www.cnblogs.com/hoodlum1980/archive/2012/06/19/2554270.html">C++中引用的底层实现</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/algorithm/hash-table/</url>
    <content><![CDATA[<h2 id="概念和定义"><a href="#概念和定义" class="headerlink" title="概念和定义"></a>概念和定义</h2><ul>
<li><p>简单理解: HashTable(哈希表/散列表)是存储[key, value]键值对的结构, 可以根据关键码key值直接访问对应位置value的数据结构, 可以达到$O(1)$的搜索效率, 是一种以空间换搜索速度的数据结构.</p>
</li>
<li><p>实现: 哈希表用数组实现, 对于给定的key, 通过特定的哈希函数计算出key的HashCode(哈希码), 再对哈希码取余得到数组下标, 数组长度保持为$2^n$可以让下标的计算简化($a%b=a&amp;(b-1)$ (其中$b=2^n$)), 因为位运算效率远高于取模运算.</p>
</li>
<li><p>冲突处理: 对于插入的两个键值对, 如果两个key不同, 但是计算的HashCode一样, 就需要进行冲突处理, 一般是用链表处理, Java中也有用红黑树处理冲突.</p>
</li>
<li><p>Hash函数: 开发者应该设计合理的Hash函数, 让不同的key计算出的HashCode尽量不相同, 减少冲突.</p>
</li>
<li><p>扩容: 哈希表的数组不应该填充太满, 否则冲突概率增加, 查找效率降低; 一般可以将增长因子定义为0.75, 当数组的使用率大于0.75时, 则将容量扩大一倍, 再将所有元素重新散列, 填充到新数组</p>
</li>
</ul>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K, V&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Put</span><span class="params">(<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> V&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> K&amp; key, V&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span></span>;</span><br><span class="line">    ~HashTable() &#123; <span class="keyword">delete</span>[] list_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetIndex</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Resize</span><span class="params">()</span></span>;</span><br><span class="line">    Node&lt;K, V&gt;** list_; <span class="comment">// 初始化为Node&lt;K, V&gt;* [], 初始容量为DEFAULT_CAPACITY</span></span><br><span class="line">    <span class="keyword">int</span> len_;</span><br><span class="line">    <span class="keyword">int</span> cap_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h2><p>根据key计算对应HashCode的函数, 设计Hash函数时需要遵循一些原则:</p>
<ul>
<li><p>key1 == key2(值相等)时, 计算的HashCode1和HashCode2必须相等</p>
</li>
<li><p>key1 != key2(值不等)时, 计算的HashCode1和HashCode2应该尽可能不相等</p>
</li>
</ul>
<p>最好的Hash函数应该保证key的值和HashCode对应相等或不等</p>
<p>如果key是一个结构体, 可能判断key值相等只需要其中一部分字段对应相等, 所以Java中默认使用对象地址计算Hash值有时并不适用, 需要对自己的结构重写equals和hashCode函数</p>
<p>如何计算HashCode, 可以参考一下Java的Arrays中的源码, hashCode初始为0, 对于整型值(int, long, short, char等), 将原hashCode乘以31再加上整型值; 对于bool值, 如果为true, 则算做1231, false算做1237; 对于float, double则转变为对应的整数值, 将浮点数的符号位-阶码-尾数统统看成10进制整数的二进制表示(具体可以搜索<em>doubleToLongBits</em>, <em>floatToLongBits</em>)</p>
<p>定义一个结构体MyKey, 假设其中只有key1, key2, key3三个字段是关键字段, 值判断和HashCode计算只依赖这三个字段, 我们设计一个简单的hash函数<br><strong>一般将算术和关系操作符定义非成员函数，而将赋值操作符定义为成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MYKEY_KEY2_LEN = <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyKey</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key1;</span><br><span class="line">    <span class="keyword">char</span> key2[MYKEY_KEY2_LEN];</span><br><span class="line">    <span class="keyword">bool</span> key3;</span><br><span class="line">    <span class="keyword">int</span> d1;</span><br><span class="line">    <span class="keyword">int</span> d2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 假设MyKey判断相等只需要key1, key2, key3三个字段</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyKey&amp; left, <span class="keyword">const</span> MyKey&amp; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left.key1 != right.key1) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MYKEY_KEY2_LEN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.key2[i] != right.key2[i]) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left.key3 != right.key3) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算hashCode也应该与值的相等判断保持一致, 只使用key1, key2, key3计算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> MyKey&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result += key.key1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MYKEY_KEY2_LEN; i++) &#123;</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="keyword">int</span>)(key.key2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">31</span> * result + (key.key3 ? <span class="number">1231</span> : <span class="number">1237</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p>我们已经定义了简单的哈希函数, 可以计算出key的哈希值, 接下来就是将对应的键值对插入到哈希表中.</p>
<p>对于给定的[key, value]键值对, 插入时先计算下标, 如果下标位置已存在值, 则进行冲突处理.</p>
<h3 id="下标计算"><a href="#下标计算" class="headerlink" title="下标计算"></a>下标计算</h3><p>我们将数组初始大小定义为$2^n$, 并且数组增大每次扩大一倍, 数组大小始终为$2^n$, 可以使用公式($a%b=a&amp;(b-1)$(其中$b=2^n$))简化下标计算</p>
<h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><p>如果计算的下标位置已经有键值对, 则判断桶中的所有key是否与插入的key值相等, 如果有相等值, 则插入失败/替换value; 如果没有相等值, 只是哈希码冲突, 则添加在队列中. 想做的好一点, 可以在桶中元素较多时采用红黑树存储.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">HashTable</span>&lt;K, V&gt;:</span>:GetIndex(<span class="keyword">const</span> K&amp; key) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash(key) &amp; cap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">HashTable</span>&lt;K, V&gt;:</span>:Put(<span class="keyword">const</span> K&amp; key, <span class="keyword">const</span> V&amp; value) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = GetIndex(key);</span><br><span class="line">    <span class="comment">// 循环链表, 插入节点, 或者碰到key相等时替换</span></span><br><span class="line">    <span class="comment">// 如果插入节点, 需要先判断len与cap, 看len/cap是否达到临界比例, 一般为0.75, 达到该比例则扩容数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>如果当前的<code>数据量/容量</code>大于0.75(一般选用该值作为临界比例), 则新建一个容量为<code>2*cap</code>的新数组, 将原数组中的所有键值对重新hash到新数组, 并销毁原数组</p>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>根据给定key计算下标, 遍历下标所在位置的链表, 找到key值相等的键值对, 得到value; 如果没有找到, 则返回默认值或者空值</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>知识共享许可协议</title>
    <url>/other/creative-commons-license/</url>
    <content><![CDATA[<p>开源软件源码使用开源许可证, 而自己的其他作品例如图像, 视频, 文章则可以使用CC协议(知识共享许可协议)</p>
<p>创作共享协议允许作者选择不同的授权条款和根据不同国家的著作权法制定的版权协议, 版权持有人可以指定以下的条件:</p>
<ul>
<li>姓名标示(by): 您可以自由复制, 散布, 展示及演出本作品；您必须按照莞作者或授权人所指定的方式, 保留其姓名标示</li>
<li>非商业性(nc): 您可以自由复制, 散布, 展示及演出本作品；您不得为商业目的而使用本作品</li>
<li>禁止改作(nd): 你可以自由复制, 散布, 展示及演出本作品；您不得改变, 转变或改作本作品</li>
<li>相同方式分享(sa): 你可以自由复制, 散布, 展示及演出本作品；若您改变, 转变或改作本作品, 仅在遵守与本著作相同的授权条款下, 您才能散布由本作品产生的衍生作品</li>
</ul>
<p>这些不同条件共有16种组合模式, 其中有11种是有效的. 其它有4种组合由于同时包括互相排斥的”nd”和”sa”而无效; 1种没有以上任何条件的协议, 它相当于公有领域. 在CC 2.0以上的版本, 又有5种没有署名条款的协议被列为淘汰, 因为98%的授权者都要求署名. </p>
<p><code>CC-BY-SA 4.0</code> 表示 署名-相同方式共享 CC 4.0协议<br><code>CC-BY-NC-SA 4.0</code> 表示 署名-非商用-相同方式共享 CC 4.0协议</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>FFmpeg基础教程</title>
    <url>/other/ffmpeg-basic/</url>
    <content><![CDATA[<blockquote>
<p>转载:   <a href="http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html</a><br>作者： <a href="http://www.ruanyifeng.com/">阮一峰</a><br>日期： <a href="http://www.ruanyifeng.com/blog/2020/01/">2020年1月14日</a></p>
</blockquote>
<p><a href="https://www.ffmpeg.org/">FFmpeg</a> 是视频处理最常用的开源软件。</p>
<p>它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p>
<p>FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具。本文介绍 FFmpeg 命令行如何处理视频，比桌面视频处理软件更简洁高效。</p>
<p>如果你还没安装，可以根据<a href="https://www.ffmpeg.org/download.html">官方文档</a> 先完成安装。</p>
<a id="more"></a>

<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>介绍 FFmpeg 用法之前，需要了解一些视频处理的基本概念。</p>
<h3 id="1-1-容器"><a href="#1-1-容器" class="headerlink" title="1.1 容器"></a>1.1 容器</h3><p>视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。</p>
<p>常见的容器格式有以下几种。一般来说，视频文件的后缀名反映了它的容器格式。</p>
<blockquote>
<ul>
<li>MP4</li>
<li>MKV</li>
<li>WebM</li>
<li>AVI</li>
</ul>
</blockquote>
<p>下面的命令查看 FFmpeg 支持的容器。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -formats</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-2-编码格式"><a href="#1-2-编码格式" class="headerlink" title="1.2 编码格式"></a>1.2 编码格式</h3><p>视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。</p>
<p>常用的视频编码格式如下。</p>
<blockquote>
<ul>
<li>H.262</li>
<li>H.264</li>
<li>H.265</li>
</ul>
</blockquote>
<p>上面的编码格式都是有版权的，但是可以免费使用。此外，还有几种无版权的视频编码格式。</p>
<blockquote>
<ul>
<li>VP8</li>
<li>VP9</li>
<li>AV1</li>
</ul>
</blockquote>
<p>常用的音频编码格式如下。</p>
<blockquote>
<ul>
<li>MP3</li>
<li>AAC</li>
</ul>
</blockquote>
<p>上面所有这些都是有损的编码格式，编码后会损失一些细节，以换取压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。</p>
<p>下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -codecs</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-3-编码器"><a href="#1-3-编码器" class="headerlink" title="1.3 编码器"></a>1.3 编码器</h3><p>编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。</p>
<p>以下是一些 FFmpeg 内置的视频编码器。</p>
<blockquote>
<ul>
<li>libx264：最流行的开源 H.264 编码器</li>
<li>NVENC：基于 NVIDIA GPU 的 H.264 编码器</li>
<li>libx265：开源的 HEVC 编码器</li>
<li>libvpx：谷歌的 VP8 和 VP9 编码器</li>
<li>libaom：AV1 编码器</li>
</ul>
</blockquote>
<p>音频编码器如下。</p>
<blockquote>
<ul>
<li>libfdk-aac</li>
<li>aac</li>
</ul>
</blockquote>
<p>下面的命令可以查看 FFmpeg 已安装的编码器。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -encoders</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、FFmpeg-的使用格式"><a href="#二、FFmpeg-的使用格式" class="headerlink" title="二、FFmpeg 的使用格式"></a>二、FFmpeg 的使用格式</h2><p>FFmpeg 的命令行参数非常多，可以分成五个部分。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg &#123;1&#125; &#123;2&#125; -i &#123;3&#125; &#123;4&#125; &#123;5&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令中，五个部分的参数依次如下。</p>
<blockquote>
<ol>
<li>全局参数</li>
<li>输入文件参数</li>
<li>输入文件</li>
<li>输出文件参数</li>
<li>输出文件</li>
</ol>
</blockquote>
<p>参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">[全局参数] \</span><br><span class="line">[输入文件参数] \</span><br><span class="line">-i [输入文件] \</span><br><span class="line">[输出文件参数] \</span><br><span class="line">[输出文件]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-y \ <span class="comment"># 全局参数</span></span><br><span class="line">-c:a libfdk_aac -c:v libx264 \ <span class="comment"># 输入文件参数</span></span><br><span class="line">-i input.mp4 \ <span class="comment"># 输入文件</span></span><br><span class="line">-c:v libvpx-vp9 -c:a libvorbis \ <span class="comment"># 输出文件参数</span></span><br><span class="line">output.webm <span class="comment"># 输出文件</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。</p>
<p>如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。因此，上面的命令可以简单写成下面的样子。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i input.avi output.mp4</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、常用命令行参数"><a href="#三、常用命令行参数" class="headerlink" title="三、常用命令行参数"></a>三、常用命令行参数</h2><p>FFmpeg 常用的命令行参数如下。</p>
<blockquote>
<ul>
<li><code>-c</code>：指定编码器</li>
<li><code>-c copy</code>：直接复制，不经过重新编码（这样比较快）</li>
<li><code>-c:v</code>：指定视频编码器</li>
<li><code>-c:a</code>：指定音频编码器</li>
<li><code>-i</code>：指定输入文件</li>
<li><code>-an</code>：去除音频流</li>
<li><code>-vn</code>： 去除视频流</li>
<li><code>-preset</code>：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。</li>
<li><code>-y</code>：不经过确认，输出时直接覆盖同名文件。</li>
</ul>
</blockquote>
<h2 id="四、常见用法"><a href="#四、常见用法" class="headerlink" title="四、常见用法"></a>四、常见用法</h2><p>下面介绍 FFmpeg 几种常见用法。</p>
<h3 id="4-1-查看文件信息"><a href="#4-1-查看文件信息" class="headerlink" title="4.1 查看文件信息"></a>4.1 查看文件信息</h3><p>查看视频文件的元信息，比如编码格式和比特率，可以只使用<code>-i</code>参数。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i input.mp4</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令会输出很多冗余信息，加上<code>-hide_banner</code>参数，可以只显示元信息。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i input.mp4 -hide_banner</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-2-转换编码格式"><a href="#4-2-转换编码格式" class="headerlink" title="4.2 转换编码格式"></a>4.2 转换编码格式</h3><p>转换编码格式（transcoding）指的是，  将视频文件从一种编码转成另一种编码。比如转成 H.264 编码，一般使用编码器<code>libx264</code>，所以只需指定输出文件的视频编码器即可。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i [input.file] -c:v libx264 output.mp4</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是转成 H.265 编码的写法。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i [input.file] -c:v libx265 output.mp4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-3-转换容器格式"><a href="#4-3-转换容器格式" class="headerlink" title="4.3 转换容器格式"></a>4.3 转换容器格式</h3><p>转换容器格式（transmuxing）指的是，将视频文件从一种容器转到另一种容器。下面是 mp4  转 webm 的写法。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i input.mp4 -c copy output.webm</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，只是转一下容器，内部的编码格式不变，所以使用<code>-c copy</code>指定直接拷贝，不经过转码，这样比较快。</p>
<h3 id="4-4-调整码率"><a href="#4-4-调整码率" class="headerlink" title="4.4 调整码率"></a>4.4 调整码率</h3><p>调整码率（transrating）指的是，改变编码的比特率，一般用来将视频文件的体积变小。下面的例子指定码率最小为964K，最大为3856K，缓冲区大小为 2000K。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-minrate 964K -maxrate 3856K -bufsize 2000K \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-5-改变分辨率（transsizing）"><a href="#4-5-改变分辨率（transsizing）" class="headerlink" title="4.5 改变分辨率（transsizing）"></a>4.5 改变分辨率（transsizing）</h3><p>下面是改变视频分辨率（transsizing）的例子，从 1080p 转为 480p 。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-vf scale=480:-1 \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-6-提取音频"><a href="#4-6-提取音频" class="headerlink" title="4.6 提取音频"></a>4.6 提取音频</h3><p>有时，需要从视频里面提取音频（demuxing），可以像下面这样写。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-vn -c:a copy \</span><br><span class="line">output.aac</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>-vn</code>表示去掉视频，<code>-c:a copy</code>表示不改变音频编码，直接拷贝。</p>
<h3 id="4-7-添加音轨"><a href="#4-7-添加音轨" class="headerlink" title="4.7 添加音轨"></a>4.7 添加音轨</h3><p>添加音轨（muxing）指的是，将外部音频加入视频，比如添加背景音乐或旁白。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-i input.aac -i input.mp4 \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，有音频和视频两个输入文件，FFmpeg 会将它们合成为一个文件。</p>
<h3 id="4-8-截图"><a href="#4-8-截图" class="headerlink" title="4.8 截图"></a>4.8 截图</h3><p>下面的例子是从指定时间开始，连续对1秒钟的视频进行截图。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-y \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-ss 00:01:24 -t 00:00:01 \</span><br><span class="line">output_%3d.jpg</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果只需要截一张图，可以指定只截取一帧。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-ss 01:23:45 \</span><br><span class="line">-i input \</span><br><span class="line">-vframes 1 -q:v 2 \</span><br><span class="line">output.jpg</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>-vframes 1</code>指定只截取一帧，<code>-q:v 2</code>表示输出的图片质量，一般是1到5之间（1 为质量最高）。</p>
<h3 id="4-9-裁剪"><a href="#4-9-裁剪" class="headerlink" title="4.9 裁剪"></a>4.9 裁剪</h3><p>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]</span><br><span class="line">$ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是实际的例子。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -ss 00:01:50 -i [input] -t 10.5 -c copy [output]</span><br><span class="line">$ ffmpeg -ss 2.5 -i [input] -to 10 -c copy [output]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>-c copy</code>表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。</p>
<h3 id="4-10-为音频添加封面"><a href="#4-10-为音频添加封面" class="headerlink" title="4.10 为音频添加封面"></a>4.10 为音频添加封面</h3><p>有些视频网站只允许上传视频文件。如果要上传音频文件，必须为音频添加封面，将其转为视频，然后上传。</p>
<p>下面命令可以将音频文件，转为带封面的视频文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-loop 1 \</span><br><span class="line">-i cover.jpg -i input.mp3 \</span><br><span class="line">-c:v libx264 -c:a aac -b:a 192k -shortest \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令中，有两个输入文件，一个是封面图片<code>cover.jpg</code>，另一个是音频文件<code>input.mp3</code>。<code>-loop 1</code>参数表示图片无限循环，<code>-shortest</code>参数表示音频文件结束，输出视频就结束。</p>
<h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul>
<li><a href="https://github.com/leandromoreira/ffmpeg-libav-tutorial#chapter-3---transcoding">FFmpeg libav tutorial</a></li>
<li><a href="https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#split-and-merge-smoothly">Digital video introduction</a></li>
<li><a href="http://slhck.info/ffmpeg-encoding-course/">FFmpeg encoding and editing course</a></li>
<li><a href="http://dragonquest64.blogspot.com/2019/10/making-slideshows-wffmpeg.html">Making Slideshows w/FFMpeg</a></li>
<li><a href="https://itsfoss.com/ffmpeg/">The Complete Guide for Using ffmpeg in Linux</a></li>
<li><a href="https://bernd.dev/2020/04/adding-subtitles/">Adding subtitles to your videos the easy way</a></li>
</ul>
<p>（完）</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>开源许可证</title>
    <url>/other/open-source-license/</url>
    <content><![CDATA[<blockquote>
<p>转载:   <a href="http://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html">http://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html</a><br>作者： <a href="http://www.ruanyifeng.com/">阮一峰</a><br>日期： <a href="http://www.ruanyifeng.com/blog/2017/10/">2017年10月11日</a></p>
</blockquote>
<p>作为一个开发者，如果你打算开源自己的代码，千万不要忘记，选择一种开源许可证（license）。</p>
<p>许多开发者对开源许可证了解很少，不清楚有哪些许可证，应该怎么选择。本文介绍开源许可证的基本知识，主要参考了 OpenSource.com （<a href="https://opensource.com/article/17/9/9-open-source-software-rules-startups">1</a>，<a href="https://opensource.com/article/17/9/open-source-licensing">2</a>）。</p>
<a id="more"></a>

<h2 id="一、什么是开源许可证"><a href="#一、什么是开源许可证" class="headerlink" title="一、什么是开源许可证"></a>一、什么是开源许可证</h2><p>开源许可证是一种法律许可。通过它，版权拥有人明确允许，用户可以免费地使用、修改、共享版权软件。</p>
<p>版权法默认禁止共享，也就是说，没有许可证的软件，就等同于保留版权，虽然开源了，用户只能看看源码，不能用，一用就会侵犯版权。所以软件开源的话，必须明确地授予用户开源许可证。</p>
<h2 id="二、开源许可证的种类"><a href="#二、开源许可证的种类" class="headerlink" title="二、开源许可证的种类"></a>二、开源许可证的种类</h2><p>目前，国际公认的开源许可证共有<a href="https://opensource.org/licenses/alphabetical">80多种</a>。它们的共同特征是，都允许用户免费地使用、修改、共享源码，但是都有各自的使用条件。</p>
<p>如果一种开源许可证没有任何使用条件，连保留作者信息都不需要，那么就等同于放弃版权了。这时，软件可以直接声明进入”公共领域”（public domain）。</p>
<p>根据使用条件的不同，开源许可证分成两大类。</p>
<blockquote>
<ul>
<li>宽松式（permissive）许可证</li>
<li>Copyleft 许可证</li>
</ul>
</blockquote>
<h2 id="三、宽松式许可证"><a href="#三、宽松式许可证" class="headerlink" title="三、宽松式许可证"></a>三、宽松式许可证</h2><h3 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h3><p>宽松式许可证（permissive license）是最基本的类型，对用户几乎没有限制。用户可以修改代码后闭源。</p>
<p>它有三个基本特点。</p>
<p><strong>（1）没有使用限制</strong></p>
<p>用户可以使用代码，做任何想做的事情。</p>
<p><strong>（2）没有担保</strong></p>
<p>不保证代码质量，用户自担风险。</p>
<p><strong>（3）披露要求（notice requirement）</strong></p>
<p>用户必须披露原始作者。</p>
<h3 id="3-2-常见许可证"><a href="#3-2-常见许可证" class="headerlink" title="3.2 常见许可证"></a>3.2 常见许可证</h3><p>常见的宽松式许可证有四种。它们都允许用户任意使用代码，区别在于要求用户遵守的条件不同。</p>
<p><strong>（1）BSD（二条款版）</strong></p>
<p>分发软件时，必须保留原始的许可证声明。</p>
<p><strong>（2） BSD（三条款版）</strong></p>
<p>分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。</p>
<p><strong>（3）MIT</strong></p>
<p>分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。</p>
<p><strong>（4）Apache 2</strong></p>
<p>分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。</p>
<h2 id="四、Copyleft-许可证"><a href="#四、Copyleft-许可证" class="headerlink" title="四、Copyleft 许可证"></a>四、Copyleft 许可证</h2><h3 id="4-1-Copyleft-的含义"><a href="#4-1-Copyleft-的含义" class="headerlink" title="4.1 Copyleft 的含义"></a>4.1 Copyleft 的含义</h3><p>Copyleft 是<a href="http://www.ruanyifeng.com/blog/2005/03/post_112.html">理查德·斯托曼</a>发明的一个词，作为 Copyright （版权）的反义词。</p>
<p>Copyright 直译是”复制权”，这是版权制度的核心，意为不经许可，用户无权复制。作为反义词，Copyleft 的含义是不经许可，用户可以随意复制。</p>
<p>但是，它带有前提条件，比宽松式许可证的限制要多。</p>
<blockquote>
<ul>
<li>如果分发二进制格式，必须提供源码</li>
<li>修改后的源码，必须与修改前保持许可证一致</li>
<li>不得在原始许可证以外，附加其他限制</li>
</ul>
</blockquote>
<p>上面三个条件的核心就是：修改后的 Copyleft 代码不得闭源。 </p>
<h3 id="4-2-常见许可证"><a href="#4-2-常见许可证" class="headerlink" title="4.2 常见许可证"></a>4.2 常见许可证</h3><p>常见的 Copyleft 许可证也有四种（对用户的限制从最强到最弱排序）。</p>
<p><strong>（1）Affero GPL (AGPL)</strong></p>
<p>如果云服务（即 SAAS）用到的代码是该许可证，那么云服务的代码也必须开源。</p>
<p><strong>（2）GPL</strong></p>
<p>如果项目包含了 GPL 许可证的代码，那么整个项目都必须使用 GPL 许可证。</p>
<p><strong>（3）LGPL</strong></p>
<p>如果项目采用动态链接调用该许可证的库，项目可以不用开源。</p>
<p><strong>（4）Mozilla（MPL）</strong></p>
<p>只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</p>
<h2 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h2><p>本节回答一些开源许可证的常见问题。</p>
<h3 id="5-1-什么叫分发（distribution）？"><a href="#5-1-什么叫分发（distribution）？" class="headerlink" title="5.1 什么叫分发（distribution）？"></a>5.1 什么叫分发（distribution）？</h3><p>除了 Affero GPL (AGPL) ，其他许可证都规定只有在”分发”时，才需要遵守许可证。换言之，如果不”分发”，就不需要遵守。</p>
<p>简单说，分发就是指将版权作品从一个人转移到另一个人。这意味着，如果你是自己使用，不提供给他人，就没有分发。另外，这里的”人”也指”法人”，因此如果使用方是公司，且只在公司内部使用，也不需要遵守许可证。</p>
<p>云服务（SaaS）是否构成”分发”呢？答案是不构成。所以你使用开源软件提供云服务，不必提供源码。但是，Affero GPL (AGPL) 许可证除外，它规定云服务也必须提供源码。</p>
<h3 id="5-2-开源软件的专利如何处理？"><a href="#5-2-开源软件的专利如何处理？" class="headerlink" title="5.2 开源软件的专利如何处理？"></a>5.2 开源软件的专利如何处理？</h3><p>某些许可证（Apache 2 和 GPL v3）包含明确的条款，授予用户许可，使用软件所包含的所有专利。</p>
<p>另一些许可证（BSD、MIT 和 GPL v2）根本没提到专利。但是一般认为，它们默认给予用户专利许可，不构成侵犯专利。</p>
<p>总得来说，除非有明确的”保留专利”的条款，使用开源软件都不会构成侵犯专利。</p>
<h3 id="5-3-什么是披露要求？"><a href="#5-3-什么是披露要求？" class="headerlink" title="5.3 什么是披露要求？"></a>5.3 什么是披露要求？</h3><p>所有的开源许可证都带有”披露要求”（notice requirement），即要求软件的分发者必须向用户披露，软件里面有开源代码。</p>
<p>一般来说，你只要在软件里面提供完整的原始许可证文本，并且披露原始作者，就满足了”披露要求”。</p>
<h3 id="5-4-GPL-病毒是真的吗？"><a href="#5-4-GPL-病毒是真的吗？" class="headerlink" title="5.4  GPL 病毒是真的吗？"></a>5.4  GPL 病毒是真的吗？</h3><p>GPL 许可证规定，只要你的项目包含了 GPL 代码，整个项目就都变成了 GPL。有人把这种传染性比喻成”GPL 病毒”。</p>
<p>很多公司希望避开这个条款，既使用 GPL 软件，又不把自己的专有代码开源。理论上，这是做不到的。因为 GPL 的设计目的，就是为了防止出现这种情况。</p>
<p>但是实际上，不遵守 GPL，最坏情况就是被起诉。如果你向法院表示无法履行 GPL 的条件，法官只会判决你停止使用 GPL  代码（法律上叫做”停止侵害”），而不会强制要求你将源码开源，因为《版权法》里面的”违约救济”没有提到违约者必须开源，只提到可以停止侵害和赔偿损失。</p>
<p>（完）</p>
<p>附上一张图助于理解</p>
<img data-src="/other/open-source-license/open-source-license.png" class="" title="常见开源协议">]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>软件版本号管理</title>
    <url>/other/software-version-code/</url>
    <content><![CDATA[<h2 id="GNU-风格版本号"><a href="#GNU-风格版本号" class="headerlink" title="GNU 风格版本号"></a>GNU 风格版本号</h2><p><code>主版本号 . 子版本号 [. 修正版本号[ build- 编译版本号 ]]</code></p>
<p>示例1：1.2</p>
<p>示例2：1.2.0</p>
<p>示例3：1.2.0 build-1234</p>
<a id="more"></a>


<h2 id="版本号管理策略"><a href="#版本号管理策略" class="headerlink" title="版本号管理策略"></a>版本号管理策略</h2><ul>
<li>初始版本号可以为0.1或0.1.0</li>
<li>主版本号(major): 改动很大, 不兼容低版本, 或局部修正累积较多, 主版本号加1, 其余版本号归0</li>
<li>次版本号(minor): 增加部分功能, 兼容同一大版本的API和用法, 次版本号加1, 修订号归0</li>
<li>修订号(patch): 局部修改, 或者bug修正</li>
</ul>
<h2 id="先行版本号"><a href="#先行版本号" class="headerlink" title="先行版本号"></a>先行版本号</h2><p>修订版本号后面可能会有先行版本号 例如<code>1.0.0-alpha</code> <code>1.0.0-beta.4</code> <code>2.0.0-rc.2</code></p>
<ul>
<li><code>Alpha</code> 内部测试版, 很多bug, 一般只有内部测试人员使用</li>
<li><code>Beta</code> 测试版本, bug相对较少, 还需要改进</li>
<li><code>RC</code> Release Canditate 候选版本, 与beta版本不同的是, beta版本可能会一直加入新功能, 但rc版本几乎不会加入新功能, 主要着重于除错</li>
<li><code>GA</code> General Availability 稳定版本, 官方推荐广泛使用了</li>
<li><code>Release</code> 最终正式版本, 标准版, 软件封面一般是符号R </li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>C#中的事件与委托实例的区别</title>
    <url>/csharp/csharp-event-and-delegate/</url>
    <content><![CDATA[<p>区别概括为两点:</p>
<ol>
<li><p>允许的操作: 事件只允许通过 <code>+=</code> 和 <code>-=</code> 来订阅和取消订阅; 但是委托实例除了<code>+=</code>和<code>-=</code>, 还可以使用<code>=</code>直接赋值操作</p>
</li>
<li><p>调用的位置: 事件只能在所在类的内部调用(事件的调用也称做触发), 而委托实例在类外部也可以调用</p>
</li>
</ol>
<hr>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">TwoNumOpe</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>; <span class="comment">// 委托</span></span><br><span class="line"><span class="keyword">public</span> TwoNumOpe Func = <span class="literal">null</span>; <span class="comment">// 委托实例</span></span><br></pre></td></tr></table></figure>

<p>为了便于区分, 本文中将<strong>委托</strong>和<strong>委托实例</strong>区分称呼</p>
<p><strong>委托</strong>是一种自定义类型, 而委托类型的变量我们称为<strong>委托实例</strong></p>
<p>基本用法不再赘述, 这里着重介绍事件与委托实例的区别, 也就是以下两个变量的区别</p>
<a id="more"></a>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">TwoNumOpe</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TwoNumOpe delegateFun;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> TwoNumOpe eventFun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个测试类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">TwoNumOpe</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> TwoNumOpe delegateFun = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> TwoNumOpe eventFun = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestEvent</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventFun != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            eventFun(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestDelegate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (delegateFun != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            delegateFun(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>委托实例测试</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&quot;</span>, a, b, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Multi</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&quot;</span>, a, b, a * b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.delegateFun += Add;</span><br><span class="line">        t.delegateFun += Multi;</span><br><span class="line">        t.delegateFun(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 允许外部调用</span></span><br><span class="line">        t.delegateFun = Add; <span class="comment">// 允许直接覆盖原有的值</span></span><br><span class="line">        t.delegateFun(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 + 4 &#x3D; 7</span><br><span class="line">3 * 4 &#x3D; 12</span><br><span class="line">3 + 4 &#x3D; 7</span><br></pre></td></tr></table></figure>

<p>事件测试</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&quot;</span>, a, b, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Multi</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&quot;</span>, a, b, a * b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.eventFun += Add;</span><br><span class="line">        t.eventFun += Multi;</span><br><span class="line">        <span class="comment">//t.eventFun(3, 4); // 编译错误</span></span><br><span class="line">        <span class="comment">//t.eventFun = Add; // 编译错误</span></span><br><span class="line">        t.TestEvent(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 + 4 &#x3D; 7</span><br><span class="line">3 * 4 &#x3D; 12</span><br></pre></td></tr></table></figure>

<p>一般来说, 委托实例用于形参, 传递函数; 而事件则用于订阅/取消订阅的场景, 以避免直接覆盖或者在外部调用(触发)的混乱用法.</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的内置宏定义</title>
    <url>/cpp/cpp-buildin-macro/</url>
    <content><![CDATA[<p>在一些日志库中看到代码中使用了 <code>__FILE__</code> <code>__LINE__</code> (文件名, 行号)这样的宏定义, 好奇C++中到底提供了哪些可以使用的内置宏定义呢</p>
<p>在网上查了一些资料, 这里稍作总结</p>
<p>在C++的<a href="https://zh.cppreference.com/w/cpp/preprocessor/replace">文本替换宏</a>文档中, 可以看到有一些宏预定义在每一个翻译单元中(一定可用). 然而有的宏定义不一定存在, 可能与具体的实现, 编译器, 系统都有关系</p>
<a id="more"></a>

<h2 id="必定可用的预定义宏"><a href="#必定可用的预定义宏" class="headerlink" title="必定可用的预定义宏"></a>必定可用的预定义宏</h2><ul>
<li><code>__cplusplus</code> 表示所用C++标准版本, 展开成值 199711L(C++11 前) 、 201103L(C++11) 、 201402L(C++14) 、 201703L(C++17) 或 202002L(C++20)</li>
<li><code>__FILE__</code> 展开成当前文件名，作为字符串字面量</li>
<li><code>__LINE__</code> 展开成源文件行号，整数常量</li>
<li><code>__DATE__</code> 展开成翻译日期，形式为 “Mmm dd yyyy” 的字符串。如果月中日期数小于 10 则 “dd” 的首字符为空格。月份名如同以 <code>std::asctime()</code> 生成</li>
<li><code>__TIME__</code> 展开成翻译时间，形式为 “hh:mm:ss” 的字符串字面量</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li><code>_WIN32</code> windows系统, 写64位程序时还会同时存在<code>_WIN64</code> (vs 2019 验证)</li>
<li><code>__unix__</code> <code>__linux__</code> Linux (未验证)</li>
<li><code>__APPLE__</code> Mac OS (未验证)</li>
</ul>
<h2 id="编译器类型"><a href="#编译器类型" class="headerlink" title="编译器类型"></a>编译器类型</h2><ul>
<li><code>_MSC_VER</code> Visual Studio</li>
<li><code>__GNUC__</code> GCC/G++</li>
</ul>
<h2 id="预编译器中设置的宏"><a href="#预编译器中设置的宏" class="headerlink" title="预编译器中设置的宏"></a>预编译器中设置的宏</h2><p>比如vs2019中, 新建一个C++项目, 在项目属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义 可以看到当前配置下的预制宏</p>
<ul>
<li><code>_DEBUG</code> Debug配置</li>
<li><code>NDEBUG</code> Release配置</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中Console类常用方法总结</title>
    <url>/csharp/csharp-console-function/</url>
    <content><![CDATA[<p>学习了泰课C#入门课程后需要做一个控制台应用程序, 发现课程中使用了许多之前没有用过的控制台方法, 这里将常用的方法稍微总结一下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.CursorVisible = <span class="literal">false</span>;  <span class="comment">// 隐藏光标</span></span><br><span class="line">Console.Clear();                <span class="comment">// 清空控制台</span></span><br><span class="line">Console.SetWindowSize(x, y);    <span class="comment">// 设置控制台窗口大小 (窗口大小不能超过缓存区大小)</span></span><br><span class="line">Console.SetBufferSize(x, y);    <span class="comment">// 设置控制台缓存区大小 (缓存区大于窗口大小时会在窗口上出现控制拉杆)</span></span><br><span class="line">Console.SetCursorPosition(x, y);            <span class="comment">// 设置光标位置, 之后输出就从光标位置输出</span></span><br><span class="line">Console.ForegroundColor = ConsoleColor.Red; <span class="comment">// 设置前景色, 之后输出的颜色将以该颜色输出; (同样有背景色设置)</span></span><br><span class="line">Console.Title = <span class="string">&quot;My Title&quot;</span>;                 <span class="comment">// 设置控制台标题</span></span><br><span class="line"><span class="keyword">var</span> key = Console.ReadKey().Key;            <span class="comment">// 读取一个按键输入</span></span><br><span class="line">Console.ReadKey(<span class="literal">true</span>);                      <span class="comment">// 读取输入, 但控制台不显示 (可用于控制台游戏的即时输入)</span></span><br><span class="line">Console.Write(<span class="string">&quot;&quot;</span>);                          <span class="comment">// 输出字符串</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&quot;</span>);                      <span class="comment">// 输出字符串后换行</span></span><br></pre></td></tr></table></figure>

<p>常用的接口就这些, 如果还需要别的功能, 可以去Console类中去看一看, 在Visual Studio 2019中, 按住Ctrl点击Console类就可以看到类的接口</p>
<p>要是看不懂英文注释, 可以去 <a href="https://docs.microsoft.com/zh-cn">Microsoft中文文档</a> 搜索查看</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的扩展方法</title>
    <url>/csharp/csharp-extend-method/</url>
    <content><![CDATA[<p>扩展方法可以为现有的非静态和变量类型添加新方法</p>
<p>可以动态扩展方法, 不需要改写原来的类代码或者继承来添加方法, 也可以为其他程序集中别人封装的类添加自己需要的额外方法</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>一定要写在静态类中</li>
<li>一定是一个静态方法</li>
<li>第一个参数为扩展目标</li>
<li>第一个参数使用this修饰</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为int类型扩展一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">&quot;我的值是: &#123;0&#125;&quot;</span>, <span class="keyword">value</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddValue</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">this</span> <span class="keyword">int</span> <span class="keyword">value</span>, <span class="keyword">int</span> other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">value</span> += other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">99</span>;</span><br><span class="line">        i.SpeakValue();</span><br><span class="line">        i.AddValue(<span class="number">2</span>);</span><br><span class="line">        i.SpeakValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>如果需要改变原变量的值, 可以使用<code>ref this</code></li>
<li>如果扩展的方法名与原有的方法重名, 那么使用时会使用原有的方法</li>
</ul>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的logging使用</title>
    <url>/python/python-logging/</url>
    <content><![CDATA[<p>正式项目中, 我们不能一直使用print打印日志, 有时候需要将日志输出到文件, 或者控制日志等级, 在调试时打印所有等级日志, 在正式发布版本中不打印Debug和Info等级日志, 就需要用到日志模块, 这里介绍Python自带的logging模块</p>
<p>logging模块线程安全</p>
<a id="more"></a>

<h2 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取logger对象, 不传入名字返回默认的root的logger, 使用相同名字返回相同的logger对象</span></span><br><span class="line">my_logger = logging.getLogger(<span class="string">&quot;mylog&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置等级</span></span><br><span class="line">my_logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义日志格式</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;[%(asctime)s][%(levelname)s] - &#x27;</span>\</span><br><span class="line">    <span class="string">&#x27;%(filename)s[line:%(lineno)d] - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义console日志处理器</span></span><br><span class="line">output_console = logging.StreamHandler() <span class="comment"># 控制台</span></span><br><span class="line">output_console.setFormatter(formatter) <span class="comment"># 设置处理器使用的日志格式</span></span><br><span class="line">output_console.setLevel(logging.INFO) <span class="comment"># 设置处理器处理的日志等级</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件日志处理器</span></span><br><span class="line">output_file = logging.FileHandler(filename=<span class="string">r&quot;E:\log\test.log&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">output_file.setFormatter(formatter)</span><br><span class="line">output_file.setLevel(logging.WARNING)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将处理器添加到logger</span></span><br><span class="line">my_logger.addHandler(output_console)</span><br><span class="line">my_logger.addHandler(output_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用logger</span></span><br><span class="line">my_logger.debug(<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">my_logger.info(<span class="string">&#x27;info test&#x27;</span>)</span><br><span class="line">my_logger.warning(<span class="string">&#x27;warning test&#x27;</span>)</span><br><span class="line">my_logger.error(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">my_logger.critical(<span class="string">&#x27;critical&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现错误时打印调用栈</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 传入exc_info</span></span><br><span class="line">    logger.error(<span class="string">&quot;错误&quot;</span>, exc_info=e)</span><br></pre></td></tr></table></figure>

<h2 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h2><p>如果只是简单使用root的logger, 则使用<code>logging.basicConfig()</code>函数简单配置即可</p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>filename</em></td>
<td align="left">使用指定的文件名而不是 StreamHandler 创建 FileHandler。</td>
</tr>
<tr>
<td align="left"><em>filemode</em></td>
<td align="left">如果指定了 <em>filename</em>，则用此 <a href="https://docs.python.org/zh-cn/3/library/functions.html#filemodes">模式</a> 打开该文件。 默认模式为 <code>&#39;a&#39;</code>。</td>
</tr>
<tr>
<td align="left"><em>format</em></td>
<td align="left">处理器使用的指定格式字符串。</td>
</tr>
<tr>
<td align="left"><em>datefmt</em></td>
<td align="left">使用指定的日期/时间格式，与 <a href="https://docs.python.org/zh-cn/3/library/time.html#time.strftime"><code>time.strftime()</code></a> 所接受的格式相同。</td>
</tr>
<tr>
<td align="left"><em>style</em></td>
<td align="left">如果指定了 <em>format</em>，将为格式字符串使用此风格。 <code>&#39;%&#39;</code>, <code>&#39;&#123;&#39;</code> 或 <code>&#39;$&#39;</code> 分别对应于 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting">printf 风格</a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/string.html#string.Template"><code>string.Template</code></a>。 默认为 <code>&#39;%&#39;</code>。</td>
</tr>
<tr>
<td align="left"><em>level</em></td>
<td align="left">设置根记录器级别去指定 <a href="https://docs.python.org/zh-cn/3/library/logging.html#levels">level</a>.</td>
</tr>
<tr>
<td align="left"><em>stream</em></td>
<td align="left">使用指定的流初始化 StreamHandler。 请注意此参数与 <em>filename</em> 是不兼容的 - 如果两者同时存在，则会引发 <code>ValueError</code>。</td>
</tr>
<tr>
<td align="left"><em>handlers</em></td>
<td align="left">如果指定，这应为一个包含要加入根日志记录器的已创建处理程序的可迭代对象。 任何尚未设置格式描述符的处理程序将被设置为在此函数中创建的默认格式描述符。 请注意此参数与 <em>filename</em> 或 <em>stream</em> 不兼容 —— 如果两者同时存在，则会引发 <code>ValueError</code>。</td>
</tr>
<tr>
<td align="left"><em>force</em></td>
<td align="left">如果将此关键字参数指定为 true，则在执行其他参数指定的配置之前，将移除并关闭附加到根记录器的所有现有处理器。</td>
</tr>
</tbody></table>
<h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><p>分为5个等级, 从低到高为 DEBUG, INFO, WARNING, ERROR, CRITICAL, 设定一个等级后, 只有等于或者高于该等级的日志才会输出</p>
<h2 id="日志格式化"><a href="#日志格式化" class="headerlink" title="日志格式化"></a>日志格式化</h2><p><a href="https://docs.python.org/zh-cn/3/library/logging.html#logrecord-attributes">LogRecord官方文档</a></p>
<table>
<thead>
<tr>
<th align="left">属性名称</th>
<th align="left">格式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">args</td>
<td align="left">不需要格式化。</td>
<td align="left">合并到 <code>msg</code> 以产生 <code>message</code> 的包含参数的元组，或是其中的值将被用于合并的字典（当只有一个参数且其类型为字典时）。</td>
</tr>
<tr>
<td align="left">asctime</td>
<td align="left"><code>%(asctime)s</code></td>
<td align="left">表示 <a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> 何时被创建的供人查看时间值。 默认形式为 ‘2003-07-08 16:49:45,896’ (逗号之后的数字为时间的毫秒部分)。</td>
</tr>
<tr>
<td align="left">created</td>
<td align="left"><code>%(created)f</code></td>
<td align="left"><a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> 被创建的时间（即 <a href="https://docs.python.org/zh-cn/3/library/time.html#time.time"><code>time.time()</code></a> 的返回值）。</td>
</tr>
<tr>
<td align="left">exc_info</td>
<td align="left">不需要格式化。</td>
<td align="left">异常元组 (例如 <code>sys.exc_info</code>) 或者如未发生异常则为 <code>None</code>。</td>
</tr>
<tr>
<td align="left">文件名</td>
<td align="left"><code>%(filename)s</code></td>
<td align="left"><code>pathname</code> 的文件名部分。</td>
</tr>
<tr>
<td align="left">funcName</td>
<td align="left"><code>%(funcName)s</code></td>
<td align="left">函数名包括调用日志记录.</td>
</tr>
<tr>
<td align="left">levelname</td>
<td align="left"><code>%(levelname)s</code></td>
<td align="left">消息文本记录级别 (<code>&#39;DEBUG&#39;</code>, <code>&#39;INFO&#39;</code>, <code>&#39;WARNING&#39;</code>, <code>&#39;ERROR&#39;</code>, <code>&#39;CRITICAL&#39;</code>).</td>
</tr>
<tr>
<td align="left">levelno</td>
<td align="left"><code>%(levelno)s</code></td>
<td align="left">消息数字记录级别 (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>).</td>
</tr>
<tr>
<td align="left">lineno</td>
<td align="left"><code>%(lineno)d</code></td>
<td align="left">发出日志记录调用所在的源行号（如果可用）。</td>
</tr>
<tr>
<td align="left">message</td>
<td align="left"><code>%(message)s</code></td>
<td align="left">记入日志的消息，即 <code>msg % args</code> 的结果。 这是在发起调用 <a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.Formatter.format"><code>Formatter.format()</code></a> 时设置的。</td>
</tr>
<tr>
<td align="left">module</td>
<td align="left"><code>%(module)s</code></td>
<td align="left">模块 (<code>filename</code> 的名称部分)。</td>
</tr>
<tr>
<td align="left">msecs</td>
<td align="left"><code>%(msecs)d</code></td>
<td align="left"><a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> 被创建的时间的毫秒部分。</td>
</tr>
<tr>
<td align="left">msg</td>
<td align="left">不需要格式化。</td>
<td align="left">在原始日志记录调用中传入的格式字符串。 与 <code>args</code> 合并以产生 <code>message</code>，或是一个任意对象 (参见 <a href="https://docs.python.org/zh-cn/3/howto/logging.html#arbitrary-object-messages">使用任意对象作为消息</a>)。</td>
</tr>
<tr>
<td align="left">名称</td>
<td align="left"><code>%(name)s</code></td>
<td align="left">用于记录调用的日志记录器名称。</td>
</tr>
<tr>
<td align="left">pathname</td>
<td align="left"><code>%(pathname)s</code></td>
<td align="left">发出日志记录调用的源文件的完整路径名（如果可用）。</td>
</tr>
<tr>
<td align="left">process</td>
<td align="left"><code>%(process)d</code></td>
<td align="left">进程ID（如果可用）</td>
</tr>
<tr>
<td align="left">processName</td>
<td align="left"><code>%(processName)s</code></td>
<td align="left">进程名（如果可用）</td>
</tr>
<tr>
<td align="left">relativeCreated</td>
<td align="left"><code>%(relativeCreated)d</code></td>
<td align="left">以毫秒数表示的 LogRecord 被创建的时间，即相对于 logging 模块被加载时间的差值。</td>
</tr>
<tr>
<td align="left">stack_info</td>
<td align="left">不需要格式化。</td>
<td align="left">当前线程中从堆栈底部起向上直到包括日志记录调用并导致创建此记录的堆栈帧的堆栈帧信息（如果可用）。</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left"><code>%(thread)d</code></td>
<td align="left">线程ID（如果可用）</td>
</tr>
<tr>
<td align="left">threadName</td>
<td align="left"><code>%(threadName)s</code></td>
<td align="left">线程名（如果可用）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Log</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的抽象类</title>
    <url>/csharp/csharp-abstract-class/</url>
    <content><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li>抽象类使用关键字<code>abstract</code>修饰</li>
<li>不能被实例化</li>
<li>可以包含抽象方法</li>
<li>继承抽象类的非抽象类必须重写其中的其他抽象方法</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Thing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> name; <span class="comment">// 抽象类可以有正常成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h2><ul>
<li>使用<code>abstract</code>修饰的方法</li>
<li>只能在抽象类中申明</li>
<li>没有方法体</li>
<li>不能是私有的 (public/protected)</li>
<li>继承后必须使用<code>override</code>实现</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Fruits</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Bad</span>(<span class="params"></span>)</span>; <span class="comment">// 抽象方法(纯虚方法)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">Fruits</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bad</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象方法与虚方法(virtual)的区别:</p>
<ul>
<li>虚方法可以选择是否写逻辑, 抽象方法没有方法体</li>
<li>虚方法在子类中可以选择重写; 但抽象方法在子类中必须实现</li>
<li>虚方法可以在子类中使用<code>base</code>调用</li>
</ul>
<h2 id="如何选择普通类还是抽象类"><a href="#如何选择普通类还是抽象类" class="headerlink" title="如何选择普通类还是抽象类"></a>如何选择普通类还是抽象类</h2><ul>
<li>不希望实例化的类, 相对比较抽象的类</li>
<li>父类中的行为不太需要被实现, 只希望子类定义具体的规则</li>
</ul>
<p>抽象类主要在系统整体框架设计时使用</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的结构体和类的区别</title>
    <url>/csharp/csharp-class-and-struct/</url>
    <content><![CDATA[<h2 id="区别之处"><a href="#区别之处" class="headerlink" title="区别之处"></a>区别之处</h2><ul>
<li>结构体是值类型, 类是引用类型</li>
<li>结构体存在栈上, 类存在堆中</li>
<li>结构体成员不能使用protected访问修饰符 (结构体具备封装特性, 但不具备继承和多态的特性)</li>
<li>结构体成员变量申明不能指定默认初始值, 但类可以</li>
<li>结构体不能申明无参构造函数, 而类可以</li>
<li>结构体申明有参构造函数之后, 默认的无参构造函数不会被顶掉</li>
<li>结构体不能申明析构函数</li>
<li>结构体不能被继承</li>
<li>结构体需要在构造函数中初始化所有成员变量, 类随意</li>
<li>结构体不能被static修饰(不存在静态结构体), 而类可以</li>
<li>结构体不能在自己内部申明自身类型的变量(循环初始化), 而类可以 (值类型变量在栈上存储的是本身, 引用类型变量在栈上存储的是引用, 可以为null)</li>
</ul>
<h2 id="结构体特别之处"><a href="#结构体特别之处" class="headerlink" title="结构体特别之处"></a>结构体特别之处</h2><ul>
<li>结构体可以实现接口</li>
</ul>
<h2 id="如何选择结构体和类"><a href="#如何选择结构体和类" class="headerlink" title="如何选择结构体和类"></a>如何选择结构体和类</h2><ul>
<li>想要使用继承和多态直接使用类</li>
<li>对象是数据集合时, 优先考虑结构体, 比如位置坐标等</li>
<li>从值类型和引用类型赋值时的区别上考虑<ul>
<li>比如经常赋值传递的对象, 改变赋值对象时不希望原对象跟着变化, 就使用结构体, 比如坐标旋转等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#的垃圾回收</title>
    <url>/csharp/csharp-gc/</url>
    <content><![CDATA[<h2 id="值与引用"><a href="#值与引用" class="headerlink" title="值与引用"></a>值与引用</h2><p>C#中的变量类型分为值类型和引用类型 (指针类型这里不讨论)</p>
<p>程序内存空间分为栈和堆</p>
<p>一般我们申请的变量都是在栈上的, 不过值类型的变量在栈上直接存储了变量的值, 而引用类型变量在栈上存储的是内存地址(指向堆上的实际数据)</p>
<p>需要注意的是, 如果值类型变量作为类的成员变量使用时, 因为类是引用类型, 其空间分配在堆中, 它的成员变量虽然是值类型但空间还是和类一样分配在堆中</p>
<a id="more"></a>

<h2 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h2><h3 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h3><p>栈空间是属于每个线程独有的, 不同线程的栈互相独立互不影响, 栈空间一般比较小(1-2M), 使用是先进后出, 函数运行的执行环境(包含参数, 局部变量, 函数地址等数据的数据结构–栈帧)会存在栈顶, 栈是从高地址向低地址使用的</p>
<p>每次发生函数调用, 都会产生一个函数的独立栈帧, 寄存器ebp指向当前栈帧的底部(高地址), 寄存器esp指向当前栈帧的顶部(低地址)</p>
<p>注意: ebp指向当前位于系统栈最上边一个栈帧的底部, 而不是系统栈底部, 栈帧底部和栈底是不同概念</p>
<p>栈空间中的变量不需要用户管理, 当函数执行完毕返回上一个栈帧时当前栈帧自动弹出释放空间; <strong>栈空间比较小, 但存取速度快, 数据自动管理, 不会产生内存碎片</strong></p>
<h3 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h3><p>堆空间是属于进程的内存空间, 同一进程中的所有线程共享使用, 空间相对于栈空间会大很多, 一般比较大的对象比如类对象或者比较大的数组都是分配在堆空间中, <strong>堆空间的使用是运行时动态分配, 在栈中的变量只存储指向堆中实际变量的内存地址</strong></p>
<p>堆空间比较大, 但是使用起来比栈空间要慢, 一般由用户自己管理释放(比如C/C++), 也有很多实现了垃圾回收(GC)的语言可以自动管理释放(比如Java/C#)</p>
<h2 id="常见垃圾回收算法"><a href="#常见垃圾回收算法" class="headerlink" title="常见垃圾回收算法"></a>常见垃圾回收算法</h2><p>垃圾回收(GC, Garbage Collect), 就是遍历堆空间中所有动态分配的对象, 通过识别它们是否被引用来确定哪些对象是垃圾, 哪些对象仍要被使用</p>
<p><strong>没有任何变量/对象引用的内容就会被识别为垃圾回收掉</strong></p>
<p>常见的垃圾回收算法:</p>
<ul>
<li>引用计数<ul>
<li>对象每次被引用时对引用次数加1, 每次引用变量被删除时引用次数减1, 当引用计数为0时删除对象</li>
<li>(迅速, 不用标记, 计数器带来额外开销, 无法解决循环引用问题)</li>
</ul>
</li>
<li>标记清除<ul>
<li>从根出发, 遍历全部堆对象, 然后对所有可达的对象进行标记, 然后清除所有未标记对象</li>
<li>(速度快, 容易产生内存碎片)</li>
</ul>
</li>
<li>标记整理<ul>
<li>从根出发, 标记所有可达对象, 将未标记对象清除, 对现有对象的空间合并</li>
<li>(没有内存碎片, 合并空间时所有引用整理对象的线程都会挂起, 可能导致卡顿)</li>
</ul>
</li>
<li>标记复制回收<ul>
<li>开辟两个相等的空间, 每次只使用其中一块, 标记可达对象, 复制到另一块空间, 当复制完成后, 指向原有对象的指针指向新对象, 复制完成后释放原有空间</li>
<li>(没有内存碎片, 效率高, 需要额外内存空间)</li>
</ul>
</li>
<li>分代算法<ul>
<li>Java中将内存分为新生代, 年老代和永久代</li>
<li>新生代: 使用标记复制回收, 因为很多对象都是临时使用, 很快回收, 复制回收区域大小是9:1</li>
<li>年老代: 当新生代里复制一定次数还没有被回收时则放到年老代</li>
<li>永生代: 在年老代一定时间没有被回收则放入永生代, 使用复制整理回收</li>
<li>(复制整理回收的效果好, 但是整理过程中发生GC, 可能卡顿)</li>
</ul>
</li>
</ul>
<h2 id="C-中的垃圾回收"><a href="#C-中的垃圾回收" class="headerlink" title="C#中的垃圾回收"></a>C#中的垃圾回收</h2><p>C#中的内存空间分为0代内存, 1代内存, 2代内存 (分代算法)</p>
<ul>
<li>新分配的对象放在0代内存中</li>
<li>内存回收时, 先从根(静态字段, 方法参数等)标记所有可达对象, 不可达对象认为是垃圾</li>
<li>复制整理 (0代-&gt;1代, 1代-&gt;2代) 执行时挂起托管代码线程</li>
<li>大对象(83kb左右)会直接分配在第二代内存, 为了减少性能损耗, 大对象不会复制搬迁</li>
</ul>
<p><strong>对象在垃圾回收时被清除时才会调用其中的析构函数</strong> (不是过了作用域就自动调用)</p>
<h3 id="垃圾生么时候回收"><a href="#垃圾生么时候回收" class="headerlink" title="垃圾生么时候回收"></a>垃圾生么时候回收</h3><ul>
<li>0代内存满时, 自动回收0代内存, 并复制搬迁到1代内存中</li>
<li>1代内存满时, 自动回收0代和1代内存, 1代内存内容复制搬迁到2代内存</li>
<li>2代内存满时, 自动回收所有代内存</li>
<li>用户主动调用<code>System.GC.Collect()</code></li>
</ul>
<p><strong>何时主动调用垃圾回收</strong></p>
<p>垃圾回收不能频繁调用, 一般都是在场景加载显示Loading条时主动调用</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的万物之父object</title>
    <url>/csharp/csharp-object/</url>
    <content><![CDATA[<h2 id="object中的静态方法"><a href="#object中的静态方法" class="headerlink" title="object中的静态方法"></a>object中的静态方法</h2><h3 id="static-Equals"><a href="#static-Equals" class="headerlink" title="static Equals"></a>static Equals</h3><ul>
<li>判断两个对象是否相等</li>
<li>最终判断权交给左边的对象的Equals方法</li>
<li>不管值类型引用类型都会按照左侧对象的Equals方法比较</li>
</ul>
<h3 id="static-ReferenceEquals"><a href="#static-ReferenceEquals" class="headerlink" title="static ReferenceEquals"></a>static ReferenceEquals</h3><ul>
<li>比较两个对象是否是相同的引用, 用于比较引用类型对象</li>
<li>值类型对象返回值始终都是false</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="keyword">object</span>.ReferenceEquals(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="object中的成员方法"><a href="#object中的成员方法" class="headerlink" title="object中的成员方法"></a>object中的成员方法</h2><h3 id="GetType"><a href="#GetType" class="headerlink" title="GetType"></a>GetType</h3><p>在反射中是非常重要的方法, 返回Type类对象, 表示对象运行时的类型, 结合反射相关知识可以做很多对象操作</p>
<h3 id="MemberwiseClone-protected"><a href="#MemberwiseClone-protected" class="headerlink" title="MemberwiseClone (protected)"></a>MemberwiseClone (protected)</h3><p>该方法用于获取对象的浅拷贝对象, 会返回一个新对象, 但是新对象中的引用变量会和老对象指向同一位置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Test <span class="title">Clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MemberwiseClone() <span class="keyword">as</span> Test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="object中的虚方法"><a href="#object中的虚方法" class="headerlink" title="object中的虚方法"></a>object中的虚方法</h2><h3 id="virtual-Equals"><a href="#virtual-Equals" class="headerlink" title="virtual Equals"></a>virtual Equals</h3><p>和object中的静态方法不同, 这是个成员方法</p>
<ul>
<li>默认的实现还是比较两者是否为同一个引用, 相当于ReferenceEquals</li>
<li>微软在所有值类型基类<code>System.ValueType</code>中重写了该方法, 用来比较值相等</li>
<li>我们可以重写该方法, 定义自己的相等比较规则</li>
</ul>
<h3 id="virtual-GetHashCode"><a href="#virtual-GetHashCode" class="headerlink" title="virtual GetHashCode"></a>virtual GetHashCode</h3><p>获取对象的哈希值, 由算法计算出, 表示对象的唯一编码</p>
<h3 id="virtual-ToString"><a href="#virtual-ToString" class="headerlink" title="virtual ToString"></a>virtual ToString</h3><p>该方法返回当前对象表示的字符串, 可以重写该方法定义自己的对象转字符串规则, 当我们直接打印该对象时, 默认使用的就是ToString返回值</p>
<p>默认的ToString返回类的完整类型名</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 中的运算符重载</title>
    <url>/csharp/csharp-override-operator/</url>
    <content><![CDATA[<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> +(Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point();</span><br><span class="line">        p.x = p1.x + p2.x;</span><br><span class="line">        p.y = p1.y + p2.y;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ul>
<li>一定是一个公共静态方法</li>
<li>运算符重载中的参数至少有一个参数类型是所在的类类型</li>
<li>条件运算符必须成对实现 <code>&lt;</code>和<code>&gt;</code> <code>&gt;=</code>和<code>&lt;=</code> <code>==</code>和<code>!=</code></li>
<li>一个符号可以有多个重载</li>
<li>不能使用ref和out</li>
</ul>
<p>不可重载的运算符</p>
<ul>
<li>逻辑与<code>&amp;&amp;</code> 逻辑或<code>||</code></li>
<li>索引符<code>[]</code></li>
<li>强制运算符<code>()</code></li>
<li>点<code>.</code> 三目运算符<code>?:</code> 赋值符号<code>=</code></li>
</ul>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象七大原则</title>
    <url>/design-patterns/principles-of-OO/</url>
    <content><![CDATA[<p>总体目标: 高内聚, 低耦合; 减少模块间交互复杂度</p>
<h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p><strong>一个类只处理自己应该处理的内容, 不能啥都写在一起</strong></p>
<p>类被修改的几率很大, 因此一个类只应该专注于一件事情</p>
<p>不同的类负责不同的事情, 避免超大类, 导致修改时”牵一发而动全身”</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>对拓展开放, 对修改关闭</strong></p>
<p>模块的行为可以被拓展, 而模块的源码应该尽量少的修改</p>
<p>继承就是最典型的开闭原则的体现, 不修改父类源码, 但可以通过添加新的子类扩展父类</p>
<h3 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h3><p><strong>父类容器装子类</strong></p>
<p>任何需要父类对象的地方, 都可以使用子类对象代替</p>
<p>可以统一接口, 不用关心具体是什么类, 也就是多态的应用</p>
<a id="more"></a>

<h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><p><strong>依赖抽象(接口), 而不依赖具体实现</strong></p>
<img data-src="/design-patterns/principles-of-OO/dip.png" class="">

<p>将行为抽象出来成为接口, 尽量不要依赖具体类, 可以减小耦合</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>尽量少用别的类和自己关联</strong></p>
<p>最少知识原则 (不要陌生人说话)</p>
<p>一个对象中的成员, 要尽可能少的直接和其它类建立关系</p>
<h3 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h3><p><strong>尽量一个接口一个行为, 不要一个接口n个行为</strong></p>
<p>不应该强迫别人依赖他们不需要使用的方法</p>
<p>一个接口不需要提供太多的行为, 一个接口应该尽量只提供一个对外的功能, 让别人去选择需要实现/依赖什么样的行为, 而不是把所有行为都封装到一个接口中</p>
<p>举例: 飞行接口, 走路接口, 跑步接口等, 虽然都是移动行为, 但是我们应该将它们分为不同接口, 让别的类选择使用</p>
<h3 id="合成复用"><a href="#合成复用" class="headerlink" title="合成复用"></a>合成复用</h3><p><strong>除非设计上需要继承, 否则尽量用组合复用</strong></p>
<p>尽量使用对象组合, 而不是继承来达到复用的目的</p>
<p>继承关系是强耦合, 组合关系是低耦合</p>
<p>注意: 不能盲目的使用合成复用原则, 应该先遵守迪米特法则</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>比如”合成复用”和”迪米特法则”其实是冲突的, 具体怎样使用还是要看具体情况</p>
<ul>
<li>整理UML类图, 按照自己的想法把需要的类都整理出来</li>
<li>将七大原则截图放在旁边, 基于原则去优化修改类图<ul>
<li>拆分职责不单一, 包含内容过多的类</li>
<li>对于依赖或者关联过于复杂的类, 看看是否可以抽象行为接口, 减少耦合</li>
<li>“计算机科学中的所有问题都可以通过增加一个间接层来解决”</li>
<li>尽量复用代码 “不要重复! 在一个系统中, 每条知识必须唯一, 清晰, 权威的表达”</li>
<li>不要过度设计, 在可以的情况下, 尽量减少层次 “简单是可靠的前提”</li>
</ul>
</li>
<li>保证整体目标: 高内聚, 低耦合</li>
</ul>
<p><strong>不要总想着一步到位, 不要一开始就追求完美</strong></p>
<p><strong>优秀的人从来都是先完成, 再完善, 最后才去追求完美</strong></p>
<p>很多时候, 你都还没开始去做就想着做的怎么怎么完美了, 后面啥也没干成, 就放一边去了, 不管做的怎么样, 先把事情干起来, 先完成再说</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的索引器</title>
    <url>/csharp/csharp-indexer/</url>
    <content><![CDATA[<p>索引器可以让C#对象像数组一样通过索引访问其中的元素</p>
<p><strong>索引器定义</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] dataArr;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dataArr == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">default</span>(T); &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= dataArr.Length) &#123; <span class="keyword">return</span> <span class="keyword">default</span>(T); &#125;</span><br><span class="line">            <span class="keyword">return</span> dataArr[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dataArr == <span class="literal">null</span>) &#123; dataArr = <span class="keyword">new</span> T[<span class="number">10</span>]; &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= dataArr.Length) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">            dataArr[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用索引器</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyList类中省略了具体实现, 这里只表示使用方法</span></span><br><span class="line">MyList&lt;<span class="keyword">int</span>&gt; mList = <span class="keyword">new</span> MyList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">mList[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">Console.WriteLine(mList[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>索引器可以重载</strong></p>
<p><strong>索引器可以只有get或者只有set</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">this</span>[<span class="keyword">string</span> key, <span class="keyword">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的接口</title>
    <url>/csharp/csharp-interface/</url>
    <content><![CDATA[<h2 id="接口申明"><a href="#接口申明" class="headerlink" title="接口申明"></a>接口申明</h2><p><strong>接口是抽象行为的”基类”</strong>, 接口命名规范是大写I开头并且使用大驼峰(帕斯卡命名)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFly</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>(<span class="params"></span>)</span>; <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 未实现的属性(不是自动属性)</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">this</span>[<span class="keyword">int</span> index] &#123; <span class="keyword">get</span>; &#125; <span class="comment">// 索引器</span></span><br><span class="line">    <span class="keyword">event</span> Action DoSomething; <span class="comment">// 事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>不包含成员变量</li>
<li>只能包含<strong>方法, 属性, 索引器, 事件</strong></li>
<li><strong>成员不能被实现</strong></li>
<li>成员可以不用写访问修饰符, 不能是私有的</li>
<li>接口不能继承类, 但是可以继承另一个接口 (行为合并)</li>
<li>实现接口方法时可以添加virtual关键字, 让子类可以重写</li>
</ol>
<h2 id="接口的使用规范"><a href="#接口的使用规范" class="headerlink" title="接口的使用规范"></a>接口的使用规范</h2><p>接口用来继承</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> : <span class="title">IFLy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">// 实现接口, 但是允许子类重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 自动属性, 实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">this</span>[<span class="keyword">int</span> index] &#123; <span class="keyword">get</span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action DoSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>类可以继承多个接口</li>
<li>类继承接口后必须实现接口中所有成员</li>
</ol>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>接口是用来继承的</li>
<li>接口不能被直接实例化, 但是可以作为容器存储对象(里氏替换/多态)</li>
</ol>
<p>接口可以继承接口, 但接口不需要去实现, 当类继承后自己实现所有内容</p>
<h2 id="显式实现接口"><a href="#显式实现接口" class="headerlink" title="显式实现接口"></a>显式实现接口</h2><p>当一个类继承两个接口, 但是接口中存在两个同名方法时, 如果该方法需要针对两个接口分别实现, 则需要使用显式实现</p>
<p>注意: 显式实现接口时不能写访问修饰符</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">IAtk</span>, <span class="title">ISuperAtk</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Atk</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">// 两个接口同一个实现方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是一般来说, 两个接口代表的不应该是同一个行为表现</p>
<p>下面是显式分别实现的方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">IAtk</span>, <span class="title">ISuperAtk</span> &#123;</span><br><span class="line">    <span class="comment">// 显式实现接口不能写访问修饰符</span></span><br><span class="line">    <span class="keyword">void</span> IAtk.Atk() &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> ISuperAtk.Atk() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Player p = <span class="keyword">new</span> Player();</span><br><span class="line"><span class="comment">// 无法直接用父类调用Atk方法</span></span><br><span class="line">(p <span class="keyword">as</span> IAtk).Atk();</span><br><span class="line">(p <span class="keyword">as</span> ISuperAtk).Atk();</span><br><span class="line"><span class="comment">// 但是也可以在Player类中实现一个自己的Atk方法, 自己实现的Atk方法与显式实现接口中的方法无关</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图</title>
    <url>/UML/uml-class-diagram/</url>
    <content><![CDATA[<p>UML类图的几种关系总是忘记, 在这里再总结一下常用的几种画法, 对于不常用的聚合和组合关系这里就不讨论了, 记不住用的也少</p>
<p>一般来说常用的类图关系就以下几种: <strong>依赖</strong>, <strong>泛化</strong>, <strong>实现</strong>, <strong>关联</strong></p>
<img data-src="/UML/uml-class-diagram/uml.png" class="">

<a id="more"></a>

<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖, 就是一个类会使用到另一个类(use a), 虚线箭头</p>
<p>以下情况下, A类依赖B类:</p>
<ul>
<li>A类方法中使用B类类型的局部变量</li>
<li>A类中的方法使用B类类型的参数</li>
</ul>
<h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><p>泛化, 就是继承关系(is a), 实线空心箭头</p>
<p>A类继承于B类, 就是泛化关系, A指向B, A是B的泛化</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现, 就是实现接口(is a), 虚线空心箭头</p>
<p>A类实现接口B, A指向B</p>
<h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>关联是类与类之间的一种结构化关系(has a), 实线</p>
<p>通常是一个类将另一个类对象作为属性</p>
<p>关联可以是双向的, 实线无箭头</p>
<p>关联也可以是单向, 实线箭头</p>
<p><strong>多重性关联</strong></p>
<p>表示一个类的对象与另一个类对象关联的个数, 有一对一, 有一对多, 或者多对多</p>
<ul>
<li><code>1</code> 表示只与该类的一个对象有关联</li>
<li><code>0..*</code> 表示与该类的0个或者多个对象有关联</li>
<li><code>1..*</code> 表示与该类的1个或者多个对象有关联</li>
<li><code>0..1</code> 表示与该类对象没有关系, 或者1个对象有关联</li>
<li><code>m..n</code> 表示与该类对象最少m个, 最多n个对象有关系</li>
</ul>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的匿名函数和lambda表达式</title>
    <url>/csharp/csharp-anonymous-func/</url>
    <content><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数就是没有名字的函数</p>
<p><strong>匿名函数必须配合委托/事件使用</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action a = <span class="keyword">delegate</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">&quot;匿名函数&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; f = <span class="keyword">delegate</span>(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">$&quot;值为<span class="subst">&#123;a&#125;</span>&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>匿名函数一般作为函数参数传递或者作为函数返回值</p>
<p>如果一个委托中存储了多个匿名函数, 是没有办法指定移除某一个匿名函数的, 只能全部清除才能移除其中的匿名函数 (<code>-=</code>一个逻辑相同的匿名函数是不行的)</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式理解为匿名函数的简写, 它除了写法不一样外, 使用上和匿名函数一模一样, 都是和委托或者事件配合使用的</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action a = () =&gt; &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;lambda&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Action&lt;<span class="keyword">int</span>&gt; a1 = (<span class="keyword">value</span>) =&gt; &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; f = (<span class="keyword">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>内层的函数可以引用包含在它外层的函数的变量</p>
<p>即使外层函数的执行已经终止</p>
<p>注意: <strong>该变量提供的值并非变量创建时的值, 而是在父函数范围内的最终值</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 这里就形成闭包</span></span><br><span class="line">        action = () =&gt; &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>); <span class="comment">// 打印10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里实例上面的注意事项</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            action += () =&gt; &#123;</span><br><span class="line">                Console.WriteLine(i); <span class="comment">// 打印?</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        action(); <span class="comment">// 后面的i在循环完之后, 已经变成了10, 后面打印的全都是10, 如果想要打印0到9 (运行时的值), 可以用临时变量或者参数传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想让闭包中使用的外部变量值是运行时的值, 可以使用临时变量存储或者当作参数传递给lamdba表达式中</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的委托和事件</title>
    <url>/csharp/csharp-delegate-and-event/</url>
    <content><![CDATA[<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托是函数的容器, 可以用来存储传递函数</p>
<p>委托的本质是一个类, 用来定义函数的类型</p>
<h3 id="委托的使用"><a href="#委托的使用" class="headerlink" title="委托的使用"></a>委托的使用</h3><p>可以申明在namespace或者class语句块中, 一般写在namespace中</p>
<p>访问修饰符不写默认是public, 在别的命名空间中也能使用, private则不能在其他命名空间中使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相同命名空间中的委托不可以重名</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyFun</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">MyFun1</span>(<span class="params"><span class="keyword">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>委托一般用于:</p>
<ul>
<li>类的成员变量</li>
<li>函数参数</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">MyFun f = <span class="keyword">new</span> MyFun(fun);</span><br><span class="line">MyFun f1 = fun;</span><br><span class="line">f.Invoke();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyFun f;</span><br><span class="line">    <span class="keyword">public</span> MyFun2 f2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">MyFun fun, MyFun2 fun2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 传入函数可以作为回调函数</span></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123; fun(); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; fun2(<span class="number">-1</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="委托存储多个函数-多播委托"><a href="#委托存储多个函数-多播委托" class="headerlink" title="委托存储多个函数 (多播委托)"></a>委托存储多个函数 (多播委托)</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Fun&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">MyFun f = Fun; <span class="comment">// 不能一开始就 +=, 但是可以开始赋值为null, 之后+=</span></span><br><span class="line">f += Fun;</span><br><span class="line">f(); <span class="comment">// 打印两次 Fun</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Fun1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">f += Fun1;</span><br><span class="line">f(); <span class="comment">// 一次调用多个函数 (可以用于观察者模式)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MyFun callbacks = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFun</span>(<span class="params">MyFun fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        callbacks += fun;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveFun</span>(<span class="params">MyFun fun</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        callbacks -= fun; <span class="comment">// 如果找不到并不会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearFun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        callbacks = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CallBack</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callbacks != <span class="literal">null</span>) &#123; callbacks(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统定义好的委托"><a href="#系统定义好的委托" class="headerlink" title="系统定义好的委托"></a>系统定义好的委托</h3><p>委托支持泛型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> T <span class="title">TestFun</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; (<span class="params">K v</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>System空间中提供了<code>Action</code>和<code>Func</code>两种泛型委托, <code>Action</code>是没有返回值的, <code>Func</code>有返回值</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Action f1 = <span class="literal">null</span>;   <span class="comment">// 无参无返回值委托</span></span><br><span class="line">    <span class="keyword">private</span> Action&lt;<span class="keyword">int</span>&gt; f2 = <span class="literal">null</span>; <span class="comment">// 一个int参数的无返回委托</span></span><br><span class="line">    <span class="keyword">private</span> Action&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; f3 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ... Action有n个泛型重载</span></span><br><span class="line">    <span class="keyword">private</span> Fun&lt;<span class="keyword">string</span>&gt; f4 = <span class="literal">null</span>; <span class="comment">// 返回string的无参委托</span></span><br><span class="line">    <span class="keyword">private</span> Fun&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; f5 = <span class="literal">null</span>; <span class="comment">// 返回string, 一个int参数</span></span><br><span class="line">    <span class="comment">// ... Fun有n个泛型重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是基于委托的存在</p>
<p>事件是委托的安全包裹</p>
<p>可以让委托的使用更具有安全性</p>
<p>事件是一种特殊的变量类型</p>
<h3 id="事件的使用"><a href="#事件的使用" class="headerlink" title="事件的使用"></a>事件的使用</h3><ol>
<li><strong>事件只能作为成员变量存在于类和接口以及结构体中</strong>, 不能作为局部变量使用</li>
<li>事件和委托使用基本相同, 只有细微区别</li>
</ol>
<p><strong>事件相对于委托的区别</strong></p>
<ul>
<li>事件不能在类外部赋值 (虽然不能在类外直接赋值, 但是可以调用 <code>+=</code> <code>-=</code>)</li>
<li>事件不能在类外部直接调用 (<code>f.Invoke()</code>或者<code>f()</code>)</li>
</ul>
<p>相当于事件的变量只能在类外部使用<code>+=</code>和<code>-=</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action myFun;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件的作用"><a href="#事件的作用" class="headerlink" title="事件的作用"></a>事件的作用</h3><p>事件相当于对委托进行了一次封装, 让其更加安全</p>
<ul>
<li>防止外部随意置空委托</li>
<li>防止外部随意调用委托</li>
</ul>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的装箱拆箱</title>
    <url>/csharp/csharp-packing-and-unpacking/</url>
    <content><![CDATA[<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> obj = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">value</span> = (<span class="keyword">int</span>)obj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">object</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestFun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.45</span>, <span class="string">&quot;string&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="发生条件"><a href="#发生条件" class="headerlink" title="发生条件"></a>发生条件</h2><ul>
<li>装箱: 值类型存储为object时</li>
<li>拆箱: 将object转为值类型</li>
</ul>
<h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><p>把值类型用引用类型存储, 装箱时会将栈内存迁移到堆内存中, 会有性能消耗</p>
<h2 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h2><p>把引用类型存储的值取出来, 堆内存迁移到栈内存</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>好处: 不确定类型时可以方便参数的存储和传递</li>
<li>坏处: 存在内存迁移, 增加性能消耗</li>
</ul>
<p>装箱拆箱不是说不能用, 而是尽量少用, 避免频繁装箱拆箱造成大量的性能消耗</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的协变和逆变</title>
    <url>/csharp/csharp-covariance-and-inverter/</url>
    <content><![CDATA[<h2 id="什么是协变逆变"><a href="#什么是协变逆变" class="headerlink" title="什么是协变逆变"></a>什么是协变逆变</h2><p><strong>主要用于泛型重载之间相互装载时使用</strong></p>
<p>基本原理就是<strong>子类对象可以作为父类使用</strong></p>
<p>只有<strong>泛型接口</strong>和<strong>泛型委托</strong>能使用</p>
<p>协变和逆变是用来修饰泛型类型的</p>
<ul>
<li>协变: <code>out</code> 只能用于返回值  父类泛型委托装子类泛型委托对象</li>
<li>逆变: <code>in</code> 只能用于参数     子类泛型委托装父类泛型委托对象</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="返回值和参数"><a href="#返回值和参数" class="headerlink" title="返回值和参数"></a>返回值和参数</h3><ol>
<li>用<code>out</code>修饰的泛型只能作为返回值类型</li>
<li>用<code>in</code>修饰的泛型只能作为参数类型</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;(<span class="params"></span>)</span>; <span class="comment">// T只能作为返回值类型</span></span><br><span class="line"><span class="comment">// delegate void TestOut&lt;out T&gt;(T v); // 报错, out修饰的类型不能作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>; <span class="comment">// T只能作为参数类型</span></span><br><span class="line"><span class="comment">// 同样, in修饰的类型不能作为返回值类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">TestFun</span>(<span class="params"></span>)</span>; <span class="comment">// T作为返回值可以, 作为参数不行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>父类总是能被子类替代</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Base</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span> : <span class="title">Base</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用协变</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> T <span class="title">Test</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line">Test&lt;A&gt; ta = () =&gt; &#123; <span class="keyword">return</span> <span class="keyword">new</span> A(); &#125;</span><br><span class="line"><span class="comment">// Test&lt;Base&gt; tb = ta; // 这里会报错, 虽然返回的A对象其实可以作为Base使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协变</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line">Test&lt;A&gt; toa = () =&gt; &#123; <span class="keyword">return</span> <span class="keyword">new</span> A(); &#125;</span><br><span class="line">Test&lt;Base&gt; tob = toa; <span class="comment">// 这里不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用逆变</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;(<span class="params">T v</span>)</span>;</span><br><span class="line">Test&lt;Base&gt; tb = (<span class="keyword">value</span>) =&gt; &#123;&#125;; <span class="comment">// value是Base类型</span></span><br><span class="line"><span class="comment">// Test&lt;A&gt; ta = tb; // 报错, 虽然传入的A参数可以作为Base传给value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆变</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T v</span>)</span>;</span><br><span class="line">TestIn&lt;Base&gt; tib = (<span class="keyword">value</span>) =&gt; &#123;&#125;;</span><br><span class="line">TestIn&lt;A&gt; tia = tib; <span class="comment">// 不会报错</span></span><br><span class="line"></span><br><span class="line">tia(<span class="keyword">new</span> A());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的多线程</title>
    <url>/csharp/csharp-multi-threads/</url>
    <content><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统进行资源分配和调度的基本单位</p>
<p>进程之间独立运行, 具有独立的内存空间, 进程间也可以相互访问</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统调度的最小单位</p>
<p>线程包含在进程之中, 是进程中的实际运作单位</p>
<p>一个进程中可以并发执行多个线程</p>
<h2 id="多线程使用"><a href="#多线程使用" class="headerlink" title="多线程使用"></a>多线程使用</h2><ul>
<li>线程执行的代码需要封装到一个静态static函数之中</li>
<li>线程的启动 <code>t.Start()</code></li>
<li>设置后台线程:<br>主线程结束时, 整个程序也就结束了, 即使还有还有后台线程, 后台线程不会防止应用程序被终止掉, 如果不设置为后台线程, 可能导致进程无法正常关闭(默认开启的为前台线程); (一般来说, 我们应该优雅的关闭所有线程, 而不是强制退出)</li>
<li>关闭线程<ul>
<li>非循环的线程, 不用刻意去关闭, 等自然运行完毕即可</li>
<li>死循环线程, 可以设置运行标志位, 循环判断标志位退出</li>
<li>通过线程提供的方法关闭 <code>t.Abort()</code> .Net core会报错 (不推荐)</li>
</ul>
</li>
<li>线程休眠<br>休眠函数在哪个线程中执行, 则休眠哪个线程, 单位为毫秒数<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 休眠1s</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> isRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (isRunning)</span><br><span class="line">    &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用静态函数创建线程</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(NewThreadLogic);</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br><span class="line"><span class="comment">// 设置后台线程</span></span><br><span class="line">t.IsBackground = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 主线程</span></span><br><span class="line">Console.ReadKey();</span><br><span class="line">isRunning = <span class="literal">false</span>;</span><br><span class="line">Console.ReadKey();</span><br><span class="line">t.Join(); <span class="comment">// 主线程阻塞, 等待t线程结束再继续执行</span></span><br></pre></td></tr></table></figure>

<h2 id="多线程函数的参数传递"><a href="#多线程函数的参数传递" class="headerlink" title="多线程函数的参数传递"></a>多线程函数的参数传递</h2><p>其实Thread的构造方法有两种</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span>(<span class="params">ParameterizedThreadStart start</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span>(<span class="params">ThreadStart start</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>跟进去看, 会发现, 这个start参数是两种不同的委托类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ParameterizedThreadStart</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ThreadStart</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>因此, <code>Thread</code>的构造其实可以传入一个代一个<code>object</code>参数的函数, 之后<code>Thread</code>类对象的<code>Start</code>函数其实有重载的实现, 一个是无参的, 一个接受一个object对象作为线程函数的参数, 对于需要传递多个参数的, 可以用struct封装起来传递, 也可以使用<code>Tuple</code>传递</p>
<h2 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h2><p>进程间的内存是互相独立的, 但同一个进程中的线程间共享进程的内存</p>
<p>所以需要注意, 当多线程同时操作同一片内存区域时可能有数据同步问题</p>
<p>可以通过加锁方式避免问题, <code>lock(引用类型对象)</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">object</span> obj = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>(obj)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.SetCurorPosition(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">        Console.ForgroundColor = ConsoleColor.Red;</span><br><span class="line">        Console.Write(<span class="string">&quot;⚪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>(obj)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.SetCurorPosition(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        Console.ForgroundColor = ConsoleColor.Blue;</span><br><span class="line">        Console.Write(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程作用"><a href="#多线程作用" class="headerlink" title="多线程作用"></a>多线程作用</h2><p>用于处理一些复杂耗时的逻辑, 比如寻路, 网络通信等等, 避免主线程卡顿</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#反射</title>
    <url>/csharp/csharp-reflect/</url>
    <content><![CDATA[<h2 id="基础认识"><a href="#基础认识" class="headerlink" title="基础认识"></a>基础认识</h2><h3 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h3><p>程序集是编译器编译得到的一个产物</p>
<p>我们写的一个代码集合编译成一个程序集可以方便的提供给他人使用</p>
<p>在Windows系统中, 一般是后缀为<code>.dll</code>或者<code>.exe</code>的格式</p>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>元数据就是用来描述数据的数据</p>
<p>程序中的类, 类中的函数, 变量等信息就是程序的元数据</p>
<p>有关程序以及类型的数据被称为元数据, 保存在程序集中</p>
<h3 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h3><p>程序在运行时可以查看其它程序集或者自身的元数据, 这种行为叫做反射</p>
<p>反射可以在程序编译后获得信息, 提高了程序的扩展性和灵活性</p>
<ul>
<li>运行时得到元数据, 以及元数据特性</li>
<li>运行时实例化对象, 操作对象</li>
<li>运行时创建对象, 执行对象的操作</li>
</ul>
<a id="more"></a>

<h2 id="反射使用"><a href="#反射使用" class="headerlink" title="反射使用"></a>反射使用</h2><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Type是反射功能的基础, 是访问元数据的主要方式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="keyword">int</span> i</span>): <span class="title">this</span>(<span class="params"></span>)</span> &#123; <span class="keyword">this</span>.i = i; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取Type"><a href="#获取Type" class="headerlink" title="获取Type"></a>获取Type</h4><ol>
<li>使用object中的<code>GetType()</code>方法</li>
<li>使用<code>typeof(类型)</code></li>
<li>使用<code>Type.GetType(&quot;完整的类型名&quot;)</code></li>
</ol>
<p>一般来说, 同一个程序集中可以使用1和2获取Type, 但不同程序集之间可以通过3来获取Type</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 使用object中的GetType()可以获取对象的Type</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;</span><br><span class="line">Type type1 = a.GetType(); <span class="comment">// 不管值类型还是引用类型都可以获得Type</span></span><br><span class="line"><span class="comment">// 2. typeof(类型)</span></span><br><span class="line">Type type2 = <span class="keyword">typeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 3. 通过类名 (必须包含命名空间)</span></span><br><span class="line">Type type3 = Type.GetType(<span class="string">&quot;Sytem.Int32&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面的type1, type2, type3其实指向同一个地址, 每一个类型的类型信息只有一份</p>
<h4 id="获取程序集"><a href="#获取程序集" class="headerlink" title="获取程序集"></a>获取程序集</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(type1.Assembly);</span><br></pre></td></tr></table></figure>

<h4 id="获取类中的所有公共成员"><a href="#获取类中的所有公共成员" class="headerlink" title="获取类中的所有公共成员"></a>获取类中的所有公共成员</h4><p>需要引用命名空间 <code>System.Reflection</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">MemberInfo[] infos = t.GetMembers(); <span class="comment">// 获取所有公共成员</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; infos.Length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(infos[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取公共构造函数并调用"><a href="#获取公共构造函数并调用" class="headerlink" title="获取公共构造函数并调用"></a>获取公共构造函数并调用</h4><ul>
<li>获取所有公共构造 <code>GetConstructors()</code><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ConstructorInfo[] ctors = t.GetConstructors(); <span class="comment">// 公共构造</span></span><br></pre></td></tr></table></figure></li>
<li>获取其中一个公共构造<ul>
<li>得到构造函数传入Type数组, 顺序是参数顺序</li>
<li>执行构造函数传入object数组, 按顺序传入参数<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]); <span class="comment">// 取得无参构造</span></span><br><span class="line">Test obj = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test; <span class="comment">// 没有参数传入null就行</span></span><br><span class="line">Console.WriteLine(obj.i);</span><br><span class="line"></span><br><span class="line">ConstructorInfo info2 = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="keyword">int</span>)&#125;);</span><br><span class="line">obj = info2.Invoke(<span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="number">2</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(obj.i);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="获取类的公共成员变量"><a href="#获取类的公共成员变量" class="headerlink" title="获取类的公共成员变量"></a>获取类的公共成员变量</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有公共成员变量</span></span><br><span class="line">FieldInfo[] fields = t.GetFields();</span><br><span class="line"><span class="comment">// 指定名称的公共成员变量</span></span><br><span class="line">FieldInfo infoJ = t.GetField(<span class="string">&quot;j&quot;</span>);</span><br><span class="line"><span class="comment">// 通过反射获取和设置对象的值</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.j = <span class="number">99</span>;</span><br><span class="line">Console.WriteLine(infoJ.GetValue(test)); <span class="comment">// 通过FieldInfo获取对象中的成员变量值</span></span><br><span class="line"><span class="comment">// 通过反射设置指定对象的某个变量</span></span><br><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(infoJ.GetValue(test));</span><br></pre></td></tr></table></figure>

<h4 id="获取类的公共成员方法"><a href="#获取类的公共成员方法" class="headerlink" title="获取类的公共成员方法"></a>获取类的公共成员方法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Type strType = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span><br><span class="line"><span class="comment">// 获取所有公共方法</span></span><br><span class="line">MethodInfo[] methods = strType.GetMethods();</span><br><span class="line"><span class="comment">// 获取指定公共方法</span></span><br><span class="line">MethodInfo subStr = strType.GetMethod(<span class="string">&quot;Substring&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="keyword">int</span>), <span class="keyword">typeof</span>(<span class="keyword">int</span>) &#125;);</span><br><span class="line"><span class="comment">// 调用方法, 注意: 如果是静态方法, Invoke第一个参数传入null</span></span><br><span class="line"><span class="keyword">string</span> str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">object</span> result = subStr.Invoke(str, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="number">7</span>, <span class="number">5</span>&#125;);</span><br><span class="line">Console.WriteLine(result);</span><br></pre></td></tr></table></figure>

<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>使用Type对象可以取得类的所有元信息</p>
<ul>
<li>取枚举<ul>
<li><code>GetEnumName</code></li>
<li><code>GetEnumNames</code></li>
</ul>
</li>
<li>得事件<ul>
<li><code>GetEvent</code></li>
<li><code>GetEvents</code></li>
</ul>
</li>
<li>得接口<ul>
<li><code>GetInterface</code></li>
<li><code>GetInterfaces</code></li>
</ul>
</li>
<li>得属性<ul>
<li><code>GetProperty</code></li>
<li><code>GetProperties</code></li>
</ul>
</li>
</ul>
<p>等等</p>
<h3 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h3><p>程序集类, 主要用来加载其他程序集, 加载后可以使用其他程序集中的信息</p>
<p>如果使用的不是自己程序集中的内容, 需要先加载程序集 (比如<code>dll</code>库文件)</p>
<h4 id="三种加载程序集的函数"><a href="#三种加载程序集的函数" class="headerlink" title="三种加载程序集的函数"></a>三种加载程序集的函数</h4><ul>
<li>一般用于加载在同一文件夹的其它程序集<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Assembly assembly1 = Assembly.Load(<span class="string">&quot;程序集名称&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>一般用于加载不在同一个文件夹下的程序集<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Assembly assembly2 = Assembly.LoadFrom(<span class="string">&quot;包含程序集清单的文件的名称或者路径&quot;</span>);</span><br><span class="line">Assembly assembly3 = Assembly.LoadFile(<span class="string">&quot;要加载的文件的完全限定路径&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tank.dll</span></span><br><span class="line">Assembly assembly = Assembly.LoadFrom(<span class="string">@&quot;D:\Lesson1\bin\Tank&quot;</span>);</span><br><span class="line"><span class="comment">// 得到程序集中所有Type</span></span><br><span class="line">Type[] types = assembly.GetTypes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.Length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(types[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到Type对象之后再使用反射使用其它程序集中的类</span></span><br><span class="line">Type icon = assembly.GetType(<span class="string">&quot;Lesson1.Icon&quot;</span>); <span class="comment">// 完全限定的类名</span></span><br><span class="line">MemberInfo[] members = icon.GetMembers();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; members.Length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(members[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过反射实例化一个icon对象</span></span><br><span class="line"><span class="comment">// 首先得到枚举Type, 得到可以传入的参数</span></span><br><span class="line">Type moveDir = assembly.GetType(<span class="string">&quot;Lesson1.E_MoveDir&quot;</span>);</span><br><span class="line">FieldInfo right = moveDir.GetField(<span class="string">&quot;Right&quot;</span>);</span><br><span class="line"><span class="comment">// 实例化Icon对象</span></span><br><span class="line"><span class="keyword">object</span> iconObj = Activator.CreateInstance(icon, <span class="number">10</span>, <span class="number">5</span>, right.GetValue(<span class="literal">null</span>));</span><br><span class="line"><span class="comment">// 得到对象中的方法</span></span><br><span class="line">MethodInfo move = icon.GetMethod(<span class="string">&quot;Move&quot;</span>);</span><br><span class="line">MethodInfo draw = icon.GetMethod(<span class="string">&quot;Draw&quot;</span>);</span><br><span class="line">MethodInfo clear = icon.GetMethod(<span class="string">&quot;Clear&quot;</span>);</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Console.Clear();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    clear.Invoke(iconObj, <span class="literal">null</span>);</span><br><span class="line">    move.Invoke(iconObj, <span class="literal">null</span>);</span><br><span class="line">    draw.Invoke(iconObj, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建类库文件"><a href="#创建类库文件" class="headerlink" title="创建类库文件"></a>创建类库文件</h4><p>vs新建工程时选择类库项目, 生成dll文件</p>
<h3 id="Activator"><a href="#Activator" class="headerlink" title="Activator"></a>Activator</h3><p>用于快速实例化对象的类, 通过Type实例化对象比较麻烦, 需要先取得Type对象, 通过Type对象传入各种信息获取对应的构造函数, 再用Invoke调用构造函数取得对象</p>
<p>通过Activator可以快速将Type实例化为对象</p>
<p>Activator是System命名空间中的类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Type testType = <span class="keyword">typeof</span>(Test);</span><br><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line">Test testObj = Activator.CreateInstance(testType) <span class="keyword">as</span> Test;</span><br><span class="line"><span class="comment">// 有参构造</span></span><br><span class="line">testObj = Activator.CreateInstance(testType, <span class="number">99</span>) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(testObj.j);</span><br></pre></td></tr></table></figure>

<p>如果填的参数和类的所有构造的参数列表不对应, 则直接报错</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的泛型和泛型约束</title>
    <url>/csharp/csharp-generic/</url>
    <content><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型实现了类型参数化, 达到代码复用目的</p>
<p>泛型相当于类型占位符</p>
<h3 id="泛型类和泛型接口"><a href="#泛型类和泛型接口" class="headerlink" title="泛型类和泛型接口"></a>泛型类和泛型接口</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>,<span class="title">K</span>,<span class="title">M</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T v1;</span><br><span class="line">    <span class="keyword">public</span> K v2;</span><br><span class="line">    <span class="keyword">public</span> M v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ITest</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">ITest</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Value &#123; <span class="keyword">get</span> =&gt; v; <span class="keyword">set</span> &#123; v = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span>(<span class="keyword">int</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">default</span>(<span class="keyword">string</span>); <span class="comment">// null</span></span><br><span class="line"><span class="keyword">default</span>(T); <span class="comment">// 获得泛型类型的默认值</span></span><br></pre></td></tr></table></figure>

<p>普通类中的泛型方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 用泛型类型做一些逻辑判断</span></span><br><span class="line">        T t = <span class="keyword">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">string</span> v</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>,<span class="title">K</span>&gt;(<span class="params">T v1, K v2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类中的泛型方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">T t</span>)</span> &#123;&#125; <span class="comment">// 不是泛型类, 因为类型变量是属于类的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K v</span>)</span> &#123;&#125; <span class="comment">// 与类的泛型变量不同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Test&lt;<span class="keyword">int</span>&gt; t = <span class="keyword">new</span> Test&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">t.TestFun(<span class="number">10</span>); <span class="comment">// 使用非泛型方法</span></span><br><span class="line">t.TestFun&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>); <span class="comment">// 使用泛型方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><ol>
<li>不同类型对象的相同逻辑处理可以选择泛型</li>
<li>泛型可以一定程度避免装箱拆箱</li>
<li>不确定泛型类型时, 想获取默认值, 可以使用<code>default(占位符)</code></li>
</ol>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>让泛型的类型有一定约束</p>
<h3 id="泛型约束类型"><a href="#泛型约束类型" class="headerlink" title="泛型约束类型"></a>泛型约束类型</h3><p>关键字 <code>where</code></p>
<ol>
<li>值类型                   <code>where T:struct</code></li>
<li>引用类型                 <code>where T:class</code></li>
<li>存在无参公共构造函数      <code>where T:new()</code></li>
<li>某个类本身或者其派生类    <code>where T:类名</code></li>
<li>某个接口的派生类型        <code>where T:接口名</code></li>
<li>另一个泛型类型本身或者派生类型 <code>where T:V</code></li>
</ol>
<p>上面的4,5,6类似, 要求泛型是后面的类型或其子类</p>
<h3 id="泛型约束使用"><a href="#泛型约束使用" class="headerlink" title="泛型约束使用"></a>泛型约束使用</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">struct</span> <span class="comment">// T只允许是值类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K <span class="keyword">value</span></span>) <span class="keyword">where</span> K : <span class="title">new</span>(<span class="params"></span>) <span class="comment">// K必须有公共的无参构造函数</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>&lt;<span class="title">M</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> M : class <span class="comment">// M必须是引用类型</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun2</span>&lt;<span class="title">P</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> P : GameObject <span class="comment">// P必须是GameObject或者其子类类型</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型约束组合使用"><a href="#泛型约束组合使用" class="headerlink" title="泛型约束组合使用"></a>泛型约束组合使用</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">class Test&lt;T, K&gt; where T : class , new() where K : struct</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的特殊语法</title>
    <url>/csharp/csharp-special/</url>
    <content><![CDATA[<h3 id="var隐式类型"><a href="#var隐式类型" class="headerlink" title="var隐式类型"></a>var隐式类型</h3><p>var可以表示任意类型的临时变量 (自动推导类型), 可以用于简化复杂类型, 但是尽量不要影响代码的理解</p>
<ul>
<li>var不能作为类的成员, 只能用于临时变量中, 也就是语句块中</li>
<li>var变量必须初始化</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;111&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Test();</span><br></pre></td></tr></table></figure>

<h3 id="设置对象初始值"><a href="#设置对象初始值" class="headerlink" title="设置对象初始值"></a>设置对象初始值</h3><p>实例化对象时, 可以直接写大括号的形式初始化公共成员变量和属性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person p = <span class="keyword">new</span> Person() &#123; sex = <span class="literal">true</span>, Age = <span class="number">18</span>, Name = <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person &#123; Age = <span class="number">18</span> &#125;; <span class="comment">// 无参数时括号可以不写, 变量可以部分初始化</span></span><br></pre></td></tr></table></figure>

<h3 id="设置集合的初始值"><a href="#设置集合的初始值" class="headerlink" title="设置集合的初始值"></a>设置集合的初始值</h3><p>申明集合对象时, 可以通过大括号, 直接初始化内部属性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">List&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Person&gt; listPerson = <span class="keyword">new</span> List&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="keyword">new</span> Person(),</span><br><span class="line">    <span class="keyword">new</span> Person() &#123; Age = <span class="number">10</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Person() &#123; Name = <span class="string">&quot;Alice&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt;() &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;111&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;222&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h3><p>var变量可以声明为自定义的匿名类型 (不建议使用)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能有变量类型, 不能再定义某个属性为匿名函数或者lambda表达式</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; age = <span class="number">10</span>, money = <span class="number">11</span>, name = <span class="string">&quot;Alice&quot;</span> &#125;</span><br><span class="line">Console.WriteLine(v.age);</span><br><span class="line">Console.WriteLine(v.name);</span><br></pre></td></tr></table></figure>

<h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><ul>
<li>值类型本来不可以为null, 但是在值类型后面加<code>?</code>, 则变量成为可空类型, 可以赋值为null</li>
<li>可空类型其本质是 <code>Nullable&lt;&gt;</code> 的泛型类型, 是语法糖</li>
<li>可以通过 <code>HasValue</code> 判断可空类型是否不为null<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int c = null; // 报错</span></span><br><span class="line"><span class="keyword">int</span>? c = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (c.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(c);</span><br><span class="line">    Console.WriteLine(c.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>安全获取可空类型值</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>? <span class="keyword">value</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 如果为空则返回类型默认值</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.GetValueOrDefault());</span><br><span class="line"><span class="comment">// 也可以指定一个默认值</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.GetValueOrDefault(<span class="number">100</span>)); <span class="comment">// 并不会改变value的原值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用类型的使用 (自动判空)</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (o != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    o.ToString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//语法糖, 自动判断null, 如果是null, 就不会执行后面的方法</span></span><br><span class="line">o?.ToString();</span><br><span class="line">Console.WriteLine(o?.ToString()); <span class="comment">// 返回null, 无打印, 不报错</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">Console.WriteLine(arr?[<span class="number">0</span>]);</span><br><span class="line">Action action = <span class="literal">null</span>;</span><br><span class="line">action?.Invoke();</span><br></pre></td></tr></table></figure>

<h3 id="空合并操作"><a href="#空合并操作" class="headerlink" title="空合并操作 ??"></a>空合并操作 <code>??</code></h3><p>语法: <code>左边</code> ?? <code>右边</code></p>
<p>如果左边为null就返回右边值, 否则返回左边值</p>
<p>只要是<strong>可以为null的类型</strong>都能使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>? num = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">int</span> i = num == <span class="literal">null</span> ? <span class="number">100</span> : num.Value;</span><br><span class="line">i = num ?? <span class="number">100</span>; <span class="comment">// 等价于上面的三位运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> str = <span class="literal">null</span>;</span><br><span class="line">str = str ?? <span class="string">&quot;111&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="内插字符串"><a href="#内插字符串" class="headerlink" title="内插字符串"></a>内插字符串</h3><p>关键字<code>$</code>, 用于构造字符串</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;她的名字是<span class="subst">&#123;name&#125;</span>, 年龄: <span class="subst">&#123;age&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="单句逻辑简单写法"><a href="#单句逻辑简单写法" class="headerlink" title="单句逻辑简单写法"></a>单句逻辑简单写法</h3><p>只有一句逻辑时可以省略大括号简写</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        <span class="keyword">set</span> =&gt; name = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span> =&gt; x + y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speek</span>(<span class="params"><span class="keyword">string</span> str</span>)</span> =&gt; Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中值类型与引用类型深入理解</title>
    <url>/csharp/csharp-value-and-class/</url>
    <content><![CDATA[<p>值类型和引用类型的本质区别是, 值的具体内容存储在栈内存上, 而引用类型变量只在栈上存储一个地址, 具体内容存储在堆上</p>
<h3 id="如何判断值类型与引用类型"><a href="#如何判断值类型与引用类型" class="headerlink" title="如何判断值类型与引用类型"></a>如何判断值类型与引用类型</h3><p>F12跟进去看, <code>class</code>为引用, <code>struct</code>为值</p>
<h3 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h3><ul>
<li><p>命名空间</p>
</li>
<li><p>类, 接口, 结构体</p>
</li>
<li><p>函数, 属性, 索引器, 运算符重载</p>
</li>
<li><p>条件分支, 循环</p>
</li>
<li><p>上层语句块: 类, 结构体</p>
</li>
<li><p>中层语句块: 函数</p>
</li>
<li><p>底层语句块: 条件分支, 循环</p>
</li>
</ul>
<p>上层语句块声明成员变量, 中底层语句块声明临时变量</p>
<h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p>编程时大部分是临时变量, 语句块执行结束时, 没有被记录的对象编程垃圾, 此时值类型将被系统自动回收(栈弹出), 引用类型: 栈上的引用地址的变量被系统自动回收(栈弹出), 堆中的具体内容将在下次GC时回收</p>
<p>如果想要变量不被回收, 不变成垃圾, 必须将它记录下来</p>
<ul>
<li>在更高层的作用域中记录</li>
<li>使用静态全局变量记录</li>
</ul>
<p>作用域提升</p>
<a id="more"></a>

<h3 id="结构体中的值和引用"><a href="#结构体中的值和引用" class="headerlink" title="结构体中的值和引用"></a>结构体中的值和引用</h3><ul>
<li>结构体本身是值类型的前提: <strong>该结构体没有作为类的成员变量</strong></li>
<li>在结构体中的值类型变量, 栈中存储具体内容</li>
<li>在结构体中的引用类型变量, 栈中存储地址, 堆中存储具体的内容</li>
<li><strong>引用类型具体内容始终存储在堆中</strong>, 不管引用变量在结构体中还是在类中</li>
</ul>
<h3 id="类中的值和引用"><a href="#类中的值和引用" class="headerlink" title="类中的值和引用"></a>类中的值和引用</h3><ul>
<li>类类型始终是引用类型, 不管引用变量在结构体还是在类中</li>
<li>在类中的值类型变量, 其内容存储在堆上</li>
<li>在类中的引用类型变量, 变量的地址在堆上, 实际引用对象也在堆上</li>
</ul>
<h3 id="数组中的存储规则"><a href="#数组中的存储规则" class="headerlink" title="数组中的存储规则"></a>数组中的存储规则</h3><ul>
<li>数组本身是引用类型</li>
<li>值类型数组, 在数组堆地址中存储具体内容</li>
<li>引用类型数组, 在数组堆地址中存储地址</li>
</ul>
<h3 id="结构体继承接口"><a href="#结构体继承接口" class="headerlink" title="结构体继承接口"></a>结构体继承接口</h3><p>如果用接口容器装载结构体对象时, 会存在装箱拆箱</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ITest</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Value &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> TestStruct : ITest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Value &#123; <span class="keyword">get</span> =&gt; <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestStruct t = <span class="keyword">new</span> TestStruct();</span><br><span class="line">TestStruct t2 = t; <span class="comment">// 复制, 浅拷贝</span></span><br><span class="line">ITest it = t; <span class="comment">// 装箱</span></span><br><span class="line">TestStruct t3 = (TestStruct)t; <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity工具栏与基础操作</title>
    <url>/unity/unity-toolbar/</url>
    <content><![CDATA[<h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><ul>
<li>File: 新建工程, 新建场景, 工程打包设置等<ul>
<li><strong>Build Settings</strong> (工程打包设置)</li>
</ul>
</li>
<li>Edit: 对象编辑, 工程设置, 引擎相关<ul>
<li>Frame Selected (f) 视野集中到所选物体</li>
<li>Lock View to Selected (shift + f) 视野锁定跟随物体</li>
<li><strong>Project Settings</strong> (工程设置, 输入系统, 物理系统, Tag&amp;Layer等) 保存在ProjectSettings文件夹中</li>
<li><strong>Preferences</strong> (首选项, IDE工具设置)</li>
<li>Clear All PlayerPrefs</li>
<li>Grid and Snap (设置网格大小, 移动的吸附, 旋转吸附, 缩放吸附(按住Ctrl))</li>
</ul>
</li>
</ul>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul>
<li><code>Ctrl+Alt+F</code> Move To View 将物体移动到摄像机视口中央位置</li>
<li><code>Ctrl+Shift+F</code> Align With View 将物体对齐到当前视口位置 (位置, 旋转), 常用于操作摄像机, 用Scenes窗口找到一个看起来比较好的视角, 选中摄像机对齐到视口, 那么该摄像机看到的就是当前Scenes视口看到的 (快速设置摄像机位置)</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中特性的使用</title>
    <url>/csharp/csharp-features/</url>
    <content><![CDATA[<h3 id="特性是什么"><a href="#特性是什么" class="headerlink" title="特性是什么"></a>特性是什么</h3><p>特性可以在运行时使用反射查询特性信息</p>
<p>特性本质是个类, 可以利用特性为元数据添加额外信息, 比如堆一个类/成员变量/成员方法等添加更多的额外信息</p>
<p>之后再通过反射来获取这些额外信息</p>
<h3 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h3><p>特性名一般需要以<code>Attribute</code>结尾, 然后继承系统的<code>Attribute</code>类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyCustomAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> info;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCustomAttribute</span>(<span class="params"><span class="keyword">string</span> info</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="特性的使用"><a href="#特性的使用" class="headerlink" title="特性的使用"></a>特性的使用</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyCustom(<span class="meta-string">&quot;我的自定义类&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MyCusrom(<span class="meta-string">&quot;成员变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MyCustom(<span class="meta-string">&quot;test函数&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">[MyCustom(<span class="string">&quot;函数参数&quot;</span></span>)] <span class="keyword">int</span> a)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">Type t = mc.GetType(); <span class="comment">// typeof(MyClass) Type.GetType(&quot;Lesson21.MyClass&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否使用了某个特性 仅判断该类型, 而不管它的成员</span></span><br><span class="line"><span class="keyword">if</span> (t.IsDefined(<span class="keyword">typeof</span>(MyCustomAttribute), <span class="literal">false</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;使用了特性MyCustomAttribute&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得Type元数据中的所有特性</span></span><br><span class="line"><span class="keyword">object</span>[] array = t.GetCustomAttributes(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.Length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] <span class="keyword">is</span> MyCustomAttribute)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine((array[i] <span class="keyword">as</span> MyCustomAttribute).info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IsDefined</code> 判断是否使用某个特性, 参数1是特性类型, 参数2代表是否搜索继承链(属性和事件忽略此参数)</li>
<li><code>GetCustomAttributes</code> 获取Type元数据的所有特性, 参数表示是否搜索继承链</li>
</ul>
<h3 id="限制自定义特性使用范围"><a href="#限制自定义特性使用范围" class="headerlink" title="限制自定义特性使用范围"></a>限制自定义特性使用范围</h3><p>通过为特性类 添加特性 限制使用范围</p>
<ol>
<li>参数1: AttributeTargets 特性可以用在哪些位置</li>
<li>参数2: AllowMultiple 是否允许多个特性实例用在同一个目标上</li>
<li>参数3: Inherited 特性是否能被派生类和重写成员继承</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCustomAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统自带特性"><a href="#系统自带特性" class="headerlink" title="系统自带特性"></a>系统自带特性</h3><h4 id="过时特性"><a href="#过时特性" class="headerlink" title="过时特性"></a>过时特性</h4><p><code>Obsolete</code> 用于提示用户, 使用的方法等成员已经过时了, 建议使用新的方法, 一般用于函数前的特性</p>
<ul>
<li>参数1: 调用过时函数时的提示信息</li>
<li>参数2: true, 使用该方法报错; false, 使用方法警告</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Obsolete(<span class="meta-string">&quot;OldSpeek方法已经过时了, 请使用Speek方法&quot;</span>, true)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldSpeek</span>(<span class="params"><span class="keyword">string</span> str</span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speek</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用者信息特性"><a href="#调用者信息特性" class="headerlink" title="调用者信息特性"></a>调用者信息特性</h4><p>需要命名空间 <code>System.Runtime.CompilerServices</code>, 一般作为函数参数的特性</p>
<ul>
<li><code>CallerFilePath</code> 哪个文件中被调用</li>
<li><code>CallerLineNumber</code> 哪一行被调用</li>
<li><code>CallerMemberName</code> 哪个函数调用的</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeekCaller</span>(<span class="params"><span class="keyword">string</span> str, [CallerFilePath]<span class="keyword">string</span> fileName = <span class="string">&quot;&quot;</span>, [CallerLineNumber]<span class="keyword">int</span> line = <span class="number">0</span>, [CallerMemberName]<span class="keyword">string</span> target = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">        Console.WriteLine(fileName);</span><br><span class="line">        Console.WriteLine(line);</span><br><span class="line">        Console.WriteLine(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件编译特性"><a href="#条件编译特性" class="headerlink" title="条件编译特性"></a>条件编译特性</h4><p><code>Conditional</code> 和预处理指令 <code>#define</code> 配合使用</p>
<p>需要引用命名空间<code>System.Diagnostics</code>, 主要用在一些调试代码上, 有时想执行有时不想执行的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #define FUN</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Conditional(<span class="meta-string">&quot;FUN&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Fun(); <span class="comment">// 如果定义符号 FUN, 该函数执行, 否则不执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="外部Dll包函数特性"><a href="#外部Dll包函数特性" class="headerlink" title="外部Dll包函数特性"></a>外部Dll包函数特性</h4><p><code>DllImport</code> 用来标记非C#的函数, 表明该函数在一个外部的Dll中定义</p>
<p>一般用来调用C/C++的Dll包写好的方法</p>
<p>需要引用命名空间 <code>System.Runtime.InteropServices</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 外部dll实现的函数</span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">&quot;Test.dll&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的预编译指令</title>
    <url>/csharp/csharp-precompile/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>预处理器指令可以在代码编译之前进行一些逻辑处理, 一般用于平台或者版本的判断</p>
<h3 id="代码折叠-region"><a href="#代码折叠-region" class="headerlink" title="代码折叠 region"></a>代码折叠 region</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">region</span> 知识点一</span></span><br><span class="line"><span class="comment">// 这是C#专有的预编译指令, 可以让一段代码可以折叠起来</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;这里是知识点一&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span><br></pre></td></tr></table></figure>

<h3 id="符号定义-amp-条件编译"><a href="#符号定义-amp-条件编译" class="headerlink" title="符号定义 &amp; 条件编译"></a>符号定义 &amp; 条件编译</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Unity5 // 定义符号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> Unity5 // 取消定义符号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Unity2019</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> Unity2019</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Unity2019版本&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> Unity2019</span></span><br><span class="line"><span class="comment">// 可以通过 &amp;&amp; 和 || 进行多种逻辑判断</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> Unity2017 &amp;&amp; IOS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="警告与错误"><a href="#警告与错误" class="headerlink" title="警告与错误"></a>警告与错误</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> Unity2019</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> Unity2017</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">warning</span> 版本较低</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// #error 如果生效, 则直接产生错误, 不允许编译</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">error</span> 这个版本不支持</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中对象间的父子关系</title>
    <url>/unity/unity-object-parent/</url>
    <content><![CDATA[<ul>
<li><strong>子对象Inspector窗口中的Transform信息是相对于父对象的</strong>(包括位置, 旋转, 缩放; 通过Inspector窗口右上角三点的Debug模式可以看到, 位置其实是Local Position)</li>
<li>子对象会随着父对象的变化而变化</li>
<li><code>pivot/center</code> 中心点位置, pivot是当前选中对象的位置点; center是当前对象以及其所有子对象的位置点的中心位置</li>
<li><code>global/local</code> 坐标系显式是全局坐标系还是本地坐标系</li>
<li>一般为了方便管理物体, 可以创建空物体作为父物体来管理</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的迭代器</title>
    <url>/csharp/csharp-iterator/</url>
    <content><![CDATA[<h2 id="迭代器概念"><a href="#迭代器概念" class="headerlink" title="迭代器概念"></a>迭代器概念</h2><h3 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h3><p>迭代器 (Iterator) 有时又称为光标(cursor)</p>
<p>是程序设计的一种软件设计模式</p>
<p>迭代器模式: 提供一个方法顺序访问一个集合对象中的各个元素, 而又不暴露其内部的标识</p>
<p>从表现效果上看是可以在容器对象(例如链表或者数组)上遍历访问的接口</p>
<p>可以使用 <code>foreach</code> 遍历的类都是实现了迭代器的</p>
<h2 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h2><p>关键接口: <code>IEnumerator</code>, <code>IEnumerable</code></p>
<p>命令空间: <code>using System.Collections</code></p>
<p>可以通过同时继承<code>IEnumerable</code>和<code>IEnumerator</code>实现其中的方法</p>
<p><strong>想要在foreach中使用的类型, 必须实现<code>public IEunmerator GetEnumerator()</code>方法</strong>, 一般通过实现<code>IEnumerable</code>接口来实现方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span>, <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        position = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// IEnumerable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Reset(); <span class="comment">// 重置光标一般在获取迭代器时调用一次</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// IEnumerator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Current =&gt; list[position];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 移动光标</span></span><br><span class="line">        ++position;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.Length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 重置光标</span></span><br><span class="line">        position = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="foreach-本质"><a href="#foreach-本质" class="headerlink" title="foreach 本质"></a>foreach 本质</h4><ol>
<li>先获取遍历对象的<code>IEnumerator</code>, 调用它的<code>public IEnumerator GetEnumerator()</code>方法获取</li>
<li>执行得到这个<code>IEnumerator</code>对象中的<code>MoveNext</code>方法</li>
<li>只要MoveNext方法返回true, 就去得到Current, 赋值给item(迭代变量)</li>
<li>如果MoveNext方法返回false, 则调用Reset方法, 退出foreach循环</li>
</ol>
<h2 id="用yield-return语法糖实现迭代器"><a href="#用yield-return语法糖实现迭代器" class="headerlink" title="用yield return语法糖实现迭代器"></a>用yield return语法糖实现迭代器</h2><p>yield return 是C#的语法糖(糖衣语法, 简化实现逻辑)</p>
<p>让想要通过<code>foreach</code>遍历的自定义类实现<code>IEnumerable</code>接口</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyList</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyList</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.Length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yield 关键字, 配合迭代器使用</span></span><br><span class="line">            <span class="comment">// 可以理解为, 暂时返回, 保留当前状态</span></span><br><span class="line">            <span class="comment">// 下次调用&quot;MoveNext&quot;并获取&quot;Current&quot;其实接着上次的yield return 位置下一句继续执行</span></span><br><span class="line">            <span class="comment">// C#的语法糖, 本质还是 一个IEnumerator对象, 通过迭代器对象内部的&quot;MoveNext&quot;和&quot;Current&quot;实现 </span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型迭代器"><a href="#泛型迭代器" class="headerlink" title="泛型迭代器"></a>泛型迭代器</h2><p>可以将上述的类改为泛型实现, <code>IEnumerable</code>也有泛型的接口, <code>IEnumerator</code>也有泛型类型</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏基础框架2 -- 缓存池模块</title>
    <url>/unity/unity-game-base-cache-pool/</url>
    <content><![CDATA[<h2 id="缓存池模块"><a href="#缓存池模块" class="headerlink" title="缓存池模块"></a>缓存池模块</h2><p>对于场景上需要大量创建的物体, 例如子弹, 不能一直创建新物体然后弃用, 这样会不断消耗内存, 使得GC发生频率变高</p>
<p>缓存池放各种抽屉, 每个抽屉里存放一种资源的缓存</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="comment">// 抽屉</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoolData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GameObject root_;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;GameObject&gt; objQueue_;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PoolData</span>(<span class="params"><span class="keyword">string</span> name, GameObject poolObj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        root_ = <span class="keyword">new</span> GameObject(name);</span><br><span class="line">        root_.transform.parent = poolObj.transform;</span><br><span class="line">        objQueue_ = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObj</span>(<span class="params">UnityAction&lt;GameObject&gt; callback</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject obj;</span><br><span class="line">        <span class="keyword">if</span> (objQueue_.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            obj = objQueue_.Dequeue();</span><br><span class="line">            obj.transform.parent = <span class="literal">null</span>;</span><br><span class="line">            obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">            callback?.Invoke(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ResMgr.Instance.LoadAsync&lt;GameObject&gt;(root_.name, (obj) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                obj.name = root_.name;</span><br><span class="line">                callback(obj);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushObj</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        obj.SetActive(<span class="literal">false</span>);</span><br><span class="line">        obj.transform.parent = root_.transform;</span><br><span class="line">        objQueue_.Enqueue(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoolMgr</span> : <span class="title">BaseManager</span>&lt;<span class="title">PoolMgr</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="keyword">string</span>, PoolData&gt; poolDic_;</span><br><span class="line">    <span class="keyword">private</span> GameObject poolObj_;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PoolMgr</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        poolDic_ = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, PoolData&gt;();</span><br><span class="line">        poolObj_ = <span class="keyword">new</span> GameObject(<span class="string">&quot;Pool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckData</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolObj_ == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            poolObj_ = <span class="keyword">new</span> GameObject(<span class="string">&quot;Pool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!poolDic_.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            poolDic_[name] = <span class="keyword">new</span> PoolData(name, poolObj_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取缓存池中的对象, 若不存在则自动从Resources目录中异步加载实例化</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>资源在Resources目录中的相对路劲<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span>处理资源的回调函数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObj</span>(<span class="params"><span class="keyword">string</span> name, UnityAction&lt;GameObject&gt; callback</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        CheckData(name);</span><br><span class="line">        poolDic_[name].GetObj(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 调用该方法, 将对象压入缓存池中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>抽屉名称(Resources下的资源路径)<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span>需要压入的对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushObj</span>(<span class="params"><span class="keyword">string</span> name, GameObject obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        CheckData(name);</span><br><span class="line">        poolDic_[name].PushObj(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的反射机制和游戏场景</title>
    <url>/unity/unity-reflection-and-scene/</url>
    <content><![CDATA[<p>Unity的运行就是利用反射和引擎提供的各种功能进行扩展开发</p>
<h2 id="场景中对象的本质"><a href="#场景中对象的本质" class="headerlink" title="场景中对象的本质"></a>场景中对象的本质</h2><ul>
<li><code>GameObject</code> 是Unity场景中所有对象的根本, 在游戏场景中出现的任何一个对象不管是图片/模型/音效/摄像机等等, 都是依附于GameObject对象的</li>
<li><code>Transform</code> 是一个必不可少的组件, 每个GameObject都必须拥有一个<code>Transform</code>组件</li>
<li>利用Inspector面板中Transform的内容: 利用反射, 已知对象, 类名, 变量名, 通过反射为该对象设置变量值</li>
<li>新建一个脚本后, 添加给一个指定的GameObject对象: 利用反射, 已知类名, 可以获取类的所有公共成员, 可以在Inspector面板上获取/修改各公共字段信息</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="场景叠加显式"><a href="#场景叠加显式" class="headerlink" title="场景叠加显式"></a>场景叠加显式</h3><p>一般不会让场景叠加显式, 只在编辑模式下需要拷贝一些东西时, 可以这样操作</p>
<p>直接将另一个Scene资源从Project窗口中拖拽到层级窗口中即可</p>
<h3 id="场景的本质"><a href="#场景的本质" class="headerlink" title="场景的本质"></a>场景的本质</h3><p>场景本质就是配置文件</p>
<p>场景资源文件: *.unity</p>
<p>用文本编辑器打开就很清晰了, 场景上每个物体的信息, 存储的值都在配置中</p>
<p>其实读取配置文件后还是使用了反射创建关联的对象</p>
<p>其实预制体也是配置文件</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏基础框架3 -- 消息中心模块</title>
    <url>/unity/unity-game-base-message-center/</url>
    <content><![CDATA[<h2 id="事件中心模块"><a href="#事件中心模块" class="headerlink" title="事件中心模块"></a>事件中心模块</h2><p>各模块间复杂交互解耦神器, 建议全代码背诵</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MessageException</span> : <span class="title">System.Exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageException</span>(<span class="params"><span class="keyword">string</span> msg</span>) : <span class="title">base</span>(<span class="params">msg</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MessageCenter</span> : <span class="title">BaseManager</span>&lt;<span class="title">MessageCenter</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="keyword">string</span>, System.Delegate&gt; msgDic_;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageCenter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        msgDic_ = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, System.Delegate&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddListener</span>(<span class="params"><span class="keyword">string</span> name, UnityAction listener</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListening(name, listener);</span><br><span class="line">        msgDic_[name] = (UnityAction)msgDic_[name] + listener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">string</span> name, UnityAction&lt;T&gt; listener</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListening(name, listener);</span><br><span class="line">        msgDic_[name] = (UnityAction&lt;T&gt;)msgDic_[name] + listener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>(<span class="params"><span class="keyword">string</span> name, UnityAction listener</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnRemoving(name, listener);</span><br><span class="line">        msgDic_[name] = (UnityAction)msgDic_[name] - listener;</span><br><span class="line">        OnRemoved(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">string</span> name, UnityAction&lt;T&gt; listener</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnRemoving(name, listener);</span><br><span class="line">        msgDic_[name] = (UnityAction&lt;T&gt;)msgDic_[name] - listener;</span><br><span class="line">        OnRemoved(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgDic_.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            Delegate d = msgDic_[name];</span><br><span class="line">            <span class="keyword">if</span> (d != <span class="literal">null</span> &amp;&amp; d.GetType() != <span class="keyword">typeof</span>(UnityAction))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageException(<span class="string">$&quot;Attempting to send msg <span class="subst">&#123;name&#125;</span> as &quot;</span> +</span><br><span class="line">                    <span class="string">$&quot;UnityAction but dic[<span class="subst">&#123;name&#125;</span>] is <span class="subst">&#123;d.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            UnityAction action = d <span class="keyword">as</span> UnityAction;</span><br><span class="line">            action?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">string</span> name, T arg</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgDic_.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            Delegate d = msgDic_[name];</span><br><span class="line">            <span class="keyword">if</span> (d != <span class="literal">null</span> &amp;&amp; d.GetType() != <span class="keyword">typeof</span>(UnityAction&lt;T&gt;))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageException(<span class="string">$&quot;Attempting to send msg <span class="subst">&#123;name&#125;</span> as &quot;</span> +</span><br><span class="line">                    <span class="string">$&quot;UnityAction but dic[<span class="subst">&#123;name&#125;</span>] is <span class="subst">&#123;d.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            UnityAction&lt;T&gt; action = d <span class="keyword">as</span> UnityAction&lt;T&gt;;</span><br><span class="line">            action?.Invoke(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        msgDic_.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnListening</span>(<span class="params"><span class="keyword">string</span> name, Delegate listener</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!msgDic_.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            msgDic_.Add(name, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Delegate d = msgDic_[name];</span><br><span class="line">            <span class="keyword">if</span> (d != <span class="literal">null</span> &amp;&amp; d.GetType() != listener.GetType())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageException(<span class="string">$&quot;Attempting to add listener with type&quot;</span> +</span><br><span class="line">                    <span class="string">$&quot; <span class="subst">&#123;listener.GetType()&#125;</span>, but listeners in dic[<span class="subst">&#123;name&#125;</span>] is <span class="subst">&#123;d.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRemoving</span>(<span class="params"><span class="keyword">string</span> name, Delegate listener</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!msgDic_.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MessageException(<span class="string">$&quot;Attempting to remove listener&quot;</span> +</span><br><span class="line">                <span class="string">$&quot; from dic[<span class="subst">&#123;name&#125;</span>] but dic[<span class="subst">&#123;name&#125;</span>] not exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Delegate d = msgDic_[name];</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageException(<span class="string">$&quot;Attempting to remove listener from&quot;</span> +</span><br><span class="line">                    <span class="string">$&quot; dic[<span class="subst">&#123;name&#125;</span>] but dic[<span class="subst">&#123;name&#125;</span>] is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d.GetType() != listener.GetType())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageException(<span class="string">$&quot;Attempting to remove listener with type&quot;</span> +</span><br><span class="line">                    <span class="string">$&quot; <span class="subst">&#123;listener.GetType()&#125;</span> but listeners in dic[<span class="subst">&#123;name&#125;</span>] is <span class="subst">&#123;d.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRemoved</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgDic_[name] == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            msgDic_.Remove(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏基础框架5 -- 资源加载</title>
    <url>/unity/unity-game-base-resource-load/</url>
    <content><![CDATA[<p>资源加载模块提供同步和异步加载资源的接口</p>
<p>对GameObject的资源自动实例化, 对于非GameObject的资源则自动返回</p>
<p>前面缓存池的实现都是用同步加载资源的方式, 如果碰到比较大比较耗时的资源, 同步加载可能导致游戏卡顿, 我们可以改写为异步加载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResMgr</span> : <span class="title">BaseManager</span>&lt;<span class="title">ResMgr</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 同步加载资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>资源类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>Resources目录下的资源路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>对应资源<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Load</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">string</span> name</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Object obj = Resources.Load(name);</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">is</span> GameObject) <span class="comment">// 如果对象是GameObject类型, 需要先实例化再返回</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Object.Instantiate(obj) <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// TextAsset AudioClip 等等</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> obj <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 异步加载资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>资源类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>Resources下的资源目录<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span>处理资源的回调函数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">string</span> name, UnityAction&lt;T&gt; callback</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MonoMgr.Instance.StartCoroutine(LoadAsyncCoroutine(name, callback));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">LoadAsyncCoroutine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">string</span> name, UnityAction&lt;T&gt; callback</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ResourceRequest req = Resources.LoadAsync(name);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> req;</span><br><span class="line">        <span class="keyword">if</span> (req.asset <span class="keyword">is</span> GameObject)</span><br><span class="line">        &#123;</span><br><span class="line">            callback?.Invoke(Object.Instantiate(req.asset) <span class="keyword">as</span> T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            callback?.Invoke(req.asset <span class="keyword">as</span> T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏基础框架1 -- 单例模块</title>
    <url>/unity/unity-game-base-singleton/</url>
    <content><![CDATA[<p>制作游戏, 通用框架是基础, 通过各框架模块互相配合使用, 搭建各种玩法的游戏</p>
<p>这里不考虑多线程应用</p>
<h2 id="单例模块"><a href="#单例模块" class="headerlink" title="单例模块"></a>单例模块</h2><h3 id="普通类单例"><a href="#普通类单例" class="headerlink" title="普通类单例"></a>普通类单例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">public class BaseManager&lt;T&gt; where T : new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance_;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance_ == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance_ = <span class="keyword">new</span> T();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于MonoBehaviour的单例"><a href="#基于MonoBehaviour的单例" class="headerlink" title="基于MonoBehaviour的单例"></a>基于MonoBehaviour的单例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseMonoManager</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance_;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance_ == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">                DontDestroyOnLoad(obj); <span class="comment">// 让这个单例对象过场景不移除</span></span><br><span class="line">                obj.name = <span class="keyword">typeof</span>(T).Name;</span><br><span class="line">                instance_ = obj.AddComponent&lt;T&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏基础框架4 -- 公共Mono</title>
    <url>/unity/unity-game-base-mono-manager/</url>
    <content><![CDATA[<h2 id="公共Mono模块"><a href="#公共Mono模块" class="headerlink" title="公共Mono模块"></a>公共Mono模块</h2><p>让没有继承Mono的类可以开启协程或者Update更新, 统一管理Mono外需要的Update, 可以让外部普通类可以开启协程, 提供一个统一的延时执行函数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonoController</span> : <span class="title">BaseMonoManager</span>&lt;<span class="title">MonoController</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">event</span> UnityAction updateAction = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUpdateAction</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        updateAction += action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveUpdateAction</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateAction != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            updateAction -= action;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        updateAction?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonoMgr</span> : <span class="title">BaseManager</span>&lt;<span class="title">MonoMgr</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将外部普通函数添加到公共Mono的Update中执行</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span>需要在公共Mono的Update中执行的函数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUpdateAction</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MonoController.Instance.AddUpdateAction(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将Update中执行的函数移除</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span>需要从公共Mono的Update移除的函数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveUpdateAction</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MonoController.Instance.RemoveUpdateAction(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对外部普通函数开启协程</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;routine&quot;&gt;</span>协程函数返回的迭代器对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>Coroutine对象<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> MonoController.Instance.StartCoroutine(routine);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 停止一个携程函数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;routine&quot;&gt;</span>携程函数返回的迭代器对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MonoController.Instance.StopCoroutine(routine);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 延迟执行函数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span>需要执行的函数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;seconds&quot;&gt;</span>需要延迟的时间(秒)<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DelayCall</span>(<span class="params">UnityAction action, <span class="keyword">float</span> seconds</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MonoController.Instance.StartCoroutine(DelayCoroutine(action, seconds));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">DelayCoroutine</span>(<span class="params">UnityAction action, <span class="keyword">float</span> seconds</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForSeconds</span>(<span class="params">seconds</span>)</span>;</span><br><span class="line">        action?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity脚本基础规则</title>
    <url>/unity/unity-script-base/</url>
    <content><![CDATA[<h2 id="创建脚本注意事项"><a href="#创建脚本注意事项" class="headerlink" title="创建脚本注意事项"></a>创建脚本注意事项</h2><ul>
<li>创建脚本最好在Unity中创建</li>
<li>需要挂载的脚本(MonoBehaviour), <strong>类名和文件名必须一致</strong>, 因为反射机制创建对象会用文件名去找Type, 不一致的脚本不能加载</li>
</ul>
<h2 id="MonoBehaviour基础"><a href="#MonoBehaviour基础" class="headerlink" title="MonoBehaviour基础"></a>MonoBehaviour基础</h2><ul>
<li>只有继承了MonoBehaviour的脚本才能挂载到GameObject上</li>
<li>MonoBehaviour只能挂载, 不能用new实例化</li>
<li>MonoBehaviour不要写构造函数, 初始化在Awake/Start中</li>
<li>如果没有DisallowMultipleComponent属性, 可以挂载多个实例在同一个脚本上</li>
</ul>
<h2 id="脚本执行的先后顺序"><a href="#脚本执行的先后顺序" class="headerlink" title="脚本执行的先后顺序"></a>脚本执行的先后顺序</h2><p>点击一个脚本, 右上角有执行顺序选项, 默认为0</p>
<p>从ProjectSettings中也可以打开</p>
<h2 id="默认脚本内容"><a href="#默认脚本内容" class="headerlink" title="默认脚本内容"></a>默认脚本内容</h2><p>目录: <code>Editor\Data\Resources\ScriptTemplates</code></p>
<p>可以修改其中的模板内容</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏基础框架7 -- 音效管理模块</title>
    <url>/unity/unity-game-base-audio-manager/</url>
    <content><![CDATA[<p>统一管理背景音乐和特效音乐的播放, 暂停, 停止等功能, 将音量设置等功能统一控制, 不分散在各个模块中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioMgr</span> : <span class="title">BaseManager</span>&lt;<span class="title">AudioMgr</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> AudioSource backSource_;</span><br><span class="line">    <span class="keyword">private</span> AudioSource effectSource_;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="keyword">string</span>, AudioClip&gt; clipDic_;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> isBackLoading_;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> isEffectLoading_;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> isMute_;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> backVolume_;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> effectVolume_;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioMgr</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GameObject obj = <span class="keyword">new</span> GameObject(<span class="keyword">nameof</span>(AudioMgr));</span><br><span class="line">        Object.DontDestroyOnLoad(obj);</span><br><span class="line">        backSource_ = obj.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">        effectSource_ = obj.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">        clipDic_ = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, AudioClip&gt;();</span><br><span class="line">        isBackLoading_ = <span class="literal">false</span>;</span><br><span class="line">        isMute_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 播放背景音乐</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>名称, Resources下的资源路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayBackMusic</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (clipDic_.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            AudioClip clip = clipDic_[name];</span><br><span class="line">            <span class="keyword">if</span> (backSource_.isPlaying &amp;&amp; backSource_.clip.name == clip.name)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backSource_.clip = clip;</span><br><span class="line">            backSource_.Play();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBackLoading_) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">            isBackLoading_ = <span class="literal">true</span>;</span><br><span class="line">            ResMgr.Instance.LoadAsync&lt;AudioClip&gt;(name, (clip) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (clip != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    clipDic_[name] = clip;</span><br><span class="line">                    backSource_.clip = clip;</span><br><span class="line">                    backSource_.Play();</span><br><span class="line">                &#125;</span><br><span class="line">                isBackLoading_ = <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 暂停背景音乐</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PauseBackMusic</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        backSource_.Pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 停止背景音乐</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopBackMusic</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        backSource_.Stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 播放特效音乐</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>特效名称, Resources下的资源路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayEffectAudio</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (clipDic_.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            effectSource_.PlayOneShot(clipDic_[name]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEffectLoading_) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">            isEffectLoading_ = <span class="literal">true</span>;</span><br><span class="line">            ResMgr.Instance.LoadAsync&lt;AudioClip&gt;(name, (clip) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (clip != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    clipDic_[name] = clip;</span><br><span class="line">                    effectSource_.PlayOneShot(clip);</span><br><span class="line">                &#125;</span><br><span class="line">                isEffectLoading_ = <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 停止特效音乐</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopEffectAudio</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        effectSource_.Stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 设置背景音乐音量</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;volume&quot;&gt;</span>音量值(0-1)<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetBackVolume</span>(<span class="params"><span class="keyword">float</span> volume</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        volume = Mathf.Clamp(volume, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        backVolume_ = volume;</span><br><span class="line">        backSource_.volume = backVolume_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 设置特效音乐音量</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;volume&quot;&gt;</span>音量值(0-1)<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetEffectVolume</span>(<span class="params"><span class="keyword">float</span> volume</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        volume = Mathf.Clamp(volume, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        effectVolume_ = volume;</span><br><span class="line">        effectSource_.volume = effectVolume_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 设置静音状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;mute&quot;&gt;</span>是否静音<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMute</span>(<span class="params"><span class="keyword">bool</span> mute</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        isMute_ = mute;</span><br><span class="line">        backSource_.mute = isMute_;</span><br><span class="line">        effectSource_.mute = isMute_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 停止背景音乐和特效音乐</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopAll</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        backSource_.Stop();</span><br><span class="line">        effectSource_.Stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中Inspector窗口中的可编辑变量</title>
    <url>/unity/unity-inspector-field/</url>
    <content><![CDATA[<p>Inspector显示的可编辑内容就是MonoBehaviour脚本的成员变量</p>
<h2 id="private和protected变量"><a href="#private和protected变量" class="headerlink" title="private和protected变量"></a>private和protected变量</h2><h3 id="private和protected默认不显示"><a href="#private和protected默认不显示" class="headerlink" title="private和protected默认不显示"></a>private和protected默认不显示</h3><p>默认情况下, private和protected变量是不会显示在Inspector窗口中的</p>
<h3 id="显示private和protected"><a href="#显示private和protected" class="headerlink" title="显示private和protected"></a>显示private和protected</h3><p>但是, 可以加上序列化字段特性<code>[SerializeField]</code>, 让private或protected成员变量也可以显示在Inspector窗口中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br></pre></td></tr></table></figure>

<p>所谓序列化就是把一个对象保存到文件或者数据库字段中</p>
<h2 id="public变量"><a href="#public变量" class="headerlink" title="public变量"></a>public变量</h2><h3 id="public默认显示"><a href="#public默认显示" class="headerlink" title="public默认显示"></a>public默认显示</h3><p>public变量默认显示在Inspector窗口中</p>
<h3 id="public不显示"><a href="#public不显示" class="headerlink" title="public不显示"></a>public不显示</h3><p>加上字段特性<code>[HideInInspector]</code>, 可以让原本会显示在Inspector窗口中的public变量不显示</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HideInInspector</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="大部分类型都可以显示编辑"><a href="#大部分类型都可以显示编辑" class="headerlink" title="大部分类型都可以显示编辑"></a>大部分类型都可以显示编辑</h2><ul>
<li>数组, List, 枚举, GameObject 可以显示</li>
<li>字典, 自定义类型struct/class 不能显示</li>
</ul>
<h2 id="让自定义类型可以被显示在Inspector中"><a href="#让自定义类型可以被显示在Inspector中" class="headerlink" title="让自定义类型可以被显示在Inspector中"></a>让自定义类型可以被显示在Inspector中</h2><p>对自定义类型加上序列化特性 <code>[System.Serializable]</code> 即可</p>
<p>但是字典无论怎样都不能显示在Inspector</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些辅助特性"><a href="#一些辅助特性" class="headerlink" title="一些辅助特性"></a>一些辅助特性</h2><h3 id="分组说明特性-Header"><a href="#分组说明特性-Header" class="headerlink" title="分组说明特性 Header"></a>分组说明特性 Header</h3><p>为成员分组</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;基础属性&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sex;</span><br><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;战斗属性&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> atk;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> def;</span><br></pre></td></tr></table></figure>
<h3 id="悬停提示-Tooltip"><a href="#悬停提示-Tooltip" class="headerlink" title="悬停提示 Tooltip"></a>悬停提示 Tooltip</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Tooltip(<span class="meta-string">&quot;悬停提示&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> miss;</span><br></pre></td></tr></table></figure>

<h3 id="间隔特性-Space"><a href="#间隔特性-Space" class="headerlink" title="间隔特性 Space"></a>间隔特性 Space</h3><p>让两个字段间出现间隔</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Space()</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> crit;</span><br></pre></td></tr></table></figure>

<h3 id="修饰数值的滑条范围-Range"><a href="#修饰数值的滑条范围-Range" class="headerlink" title="修饰数值的滑条范围 Range"></a>修饰数值的滑条范围 Range</h3><p>让数值在Inspector中显示可拖动的滑动条</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Range(0, 10)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">float</span> luck;</span><br></pre></td></tr></table></figure>

<h3 id="多行显示字符串"><a href="#多行显示字符串" class="headerlink" title="多行显示字符串"></a>多行显示字符串</h3><p>默认不写参数显示3行 (编辑框高度)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Multiline(4)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> tips;</span><br></pre></td></tr></table></figure>

<h3 id="滚动条显示字符串"><a href="#滚动条显示字符串" class="headerlink" title="滚动条显示字符串"></a>滚动条显示字符串</h3><p>默认不写参数就是超过3行显示滚动条</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最少显示3行, 最多4行, 超过4行就显示滚动条</span></span><br><span class="line">[<span class="meta">TextArea(3, 4)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> story;</span><br></pre></td></tr></table></figure>

<h3 id="为变量添加快捷方法"><a href="#为变量添加快捷方法" class="headerlink" title="为变量添加快捷方法"></a>为变量添加快捷方法</h3><p>参数1: 显示按钮名<br>参数2: 方法名 不能有参数<br>Inspector变量右键可以出现对应操作按钮</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ContextMenuItem(<span class="meta-string">&quot;重置金币&quot;</span>, <span class="meta-string">&quot;ResetMoney&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetMoney</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    money = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对方法添加特性能投在Inspector中执行"><a href="#对方法添加特性能投在Inspector中执行" class="headerlink" title="对方法添加特性能投在Inspector中执行"></a>对方法添加特性能投在Inspector中执行</h3><p>可以在脚本右上角三个点中找到对应操作, 用于测试</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ContextMenu(<span class="meta-string">&quot;Test&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>Inspector窗口中的变量关联的就是对象的成员变量, 运行时改变它们就是改变了相应脚本对象的成员变量</li>
<li>拖拽到GameObject上之后, 再改变脚本中对象的默认值, 界面上不会改变</li>
<li>运行中修改的信息不会保存</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的脚本生命周期</title>
    <url>/unity/unity-script-life-cycle/</url>
    <content><![CDATA[<h2 id="帧的概念"><a href="#帧的概念" class="headerlink" title="帧的概念"></a>帧的概念</h2><p>游戏本质是一个循环, 每一次循环处理游戏逻辑后更新一次画面, 当画面更新速度达到一定速度, 则认为画面是流畅的</p>
<p>一帧就是执行一次循环</p>
<p>FPS(Frames Per Second) 每秒帧数</p>
<p>60帧: 1帧 = 1秒/60 = 16.66ms<br>30帧: 1帧 = 1秒/30 = 33.33ms</p>
<p>游戏卡顿的原因: 一帧中游戏逻辑计算量过大, 或者CPU不给力, 不能在一帧时间内处理完所有逻辑</p>
<h2 id="Unity中打印信息"><a href="#Unity中打印信息" class="headerlink" title="Unity中打印信息"></a>Unity中打印信息</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Debug.Log(<span class="string">&quot;&quot;</span>); <span class="comment">// Info信息</span></span><br><span class="line">Debug.LogError(<span class="string">&quot;&quot;</span>); <span class="comment">// Error红色错误信息</span></span><br><span class="line">Debug.LogWarning(<span class="string">&quot;&quot;</span>); <span class="comment">// Warn黄色警告信息</span></span><br><span class="line"><span class="comment">// MonoBehaviour提供了一个print函数, 相当于Debug.Log</span></span><br><span class="line">print(<span class="string">&quot;&quot;</span>); <span class="comment">// Info</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p>Unity会通过反射执行挂载在GameObject上的MonoBehaviour对象的特定名称的函数</p>
<p>生命周期函数一般为<code>private</code>或者<code>protected</code>, 由Unity执行, 一般不会手动执行</p>
<h3 id="Awake"><a href="#Awake" class="headerlink" title="Awake"></a>Awake</h3><p>当MonoBehaviour对象被创建时, 调用该生命周期函数, 该函数之会被调用一次</p>
<p>类似于构造函数的存在, 可用于初始化成员变量</p>
<p>场景上的脚本执行Awake时, 所有场景GameObject已经初始化完毕, 所以可以在Awake中可以初始化对其它GameObject的引用, 使用类似GameObject.Find的函数查找别的对象引用; 但是, 场景上不同物体的Awake执行顺序是不确定的, 调用Awake时不能</p>
<ul>
<li>如果脚本挂载时, GameObject是非激活状态, 则Awake不会在挂载时执行, 而是等物体第一次激活时才会执行</li>
</ul>
<h3 id="OnEnable"><a href="#OnEnable" class="headerlink" title="OnEnable"></a>OnEnable</h3><p>当依附的GameObject每次被激活时执行</p>
<ul>
<li>脚本本身是激活状态: GameObject每次激活/失活, 都会调用OnEnable/OnDisable</li>
<li>GameObject本身是激活状态: 脚本每次激活/失活也会调用OnEnable/OnDisable</li>
<li>如果脚本一直保持失活或者GameObject一直失活, 那么改变另一个的激活状态都不会触发OnEnable或OnDisable</li>
</ul>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>在场景上所有的Awake之后, 所有的Update第一次调用之前, 只被调用一次</p>
<p>用于Awake之后的初始化</p>
<h3 id="FixUpdate"><a href="#FixUpdate" class="headerlink" title="FixUpdate"></a>FixUpdate</h3><p>物理帧更新, 每间隔固定时间执行一次, 可以在ProjectSettings中的Time中设置物理更新时间, 默认为0.02s</p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>主要用于处理游戏核心逻辑更新的函数</p>
<h3 id="LateUpdate"><a href="#LateUpdate" class="headerlink" title="LateUpdate"></a>LateUpdate</h3><p>一般用于处理摄像机位置更新</p>
<p>Update和LateUpdate之间, Unity进行了一些处理, 处理动画相关的更新</p>
<h3 id="OnDisable"><a href="#OnDisable" class="headerlink" title="OnDisable"></a>OnDisable</h3><p>与OnEnable对应, 每当依附对象失活或者脚本失活时调用</p>
<h3 id="OnDistroy"><a href="#OnDistroy" class="headerlink" title="OnDistroy"></a>OnDistroy</h3><p>当依附的对象被销毁时被调用</p>
<h2 id="生命周期函数支持多态"><a href="#生命周期函数支持多态" class="headerlink" title="生命周期函数支持多态"></a>生命周期函数支持多态</h2><p>可以使用virtual和override实现代码重用</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>如果没有对应逻辑, 则不写出对应的函数, 否则反射调用会有一定开销</li>
<li>一个对象挂载多个A脚本, 或者多个对象都挂载A脚本, 则创建的是不同的A脚本对象</li>
<li>不要去new一个MonoBehaviour脚本对象, 也不要写脚本的构造函数, 否则会破坏Unity设计上的规范</li>
<li>Unity中所有对象的脚本生命周期函数都是在同一个线程中按照先后执行的</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity游戏基础框架6 -- 场景管理模块</title>
    <url>/unity/unity-game-base-scene-manager/</url>
    <content><![CDATA[<p>场景管理模块用于统一管理场景的切换</p>
<p>可以在场景切换前后利用事件管理模块发送 <code>场景退出</code> 和 <code>场景进入</code> 的事件, 也可以在异步加载时发出 <code>加载进度</code> 的事件</p>
<p>需要切换的场景Scene要提前添加到BuildSettings中的场景列表中, 否则不能切换</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneMgr</span> : <span class="title">BaseManager</span>&lt;<span class="title">SceneMgr</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 同步加载场景</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>场景名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// todo 可以通知场景退出 SceneManager.GetActiveScene().name 获取当前场景名</span></span><br><span class="line">        SceneManager.LoadScene(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 异步加载场景</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>场景名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span>回调函数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadSceneAsync</span>(<span class="params"><span class="keyword">string</span> name, UnityAction callback</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        MonoMgr.Instance.StartCoroutine(LoadSceneCoroutine(name, callback));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">LoadSceneCoroutine</span>(<span class="params"><span class="keyword">string</span> name, UnityAction callback</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AsyncOperation ao = SceneManager.LoadSceneAsync(name);</span><br><span class="line">        <span class="keyword">while</span> (!ao.isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// todo 通知加载进度 ao.progress</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callback?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中MonoBehaviour的基础内容</title>
    <url>/unity/unity-mono-base/</url>
    <content><![CDATA[<p>学习最好的方法, 就是进入这个类, 依次看一下, 不懂的再查查文档</p>
<h2 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h2><ul>
<li><code>gameObject</code> 依附的GameObject</li>
<li><code>transform</code> 依附的GameObject的transform信息 (位置旋转缩放)</li>
<li><code>enabled</code> 获取/控制该脚本是否激活 (脚本左上角的勾选)</li>
</ul>
<h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><p>一般不会在同一个对象挂载多个相同对象</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获取依附GameObject上的单个脚本 (没有对应脚本则返回null)</span></span><br><span class="line">ComponentType component = GetComponent&lt;ComponentType&gt;();</span><br><span class="line"><span class="comment">// 2. 得到自己挂载的多个脚本</span></span><br><span class="line">ComponentType[] arr = GetComponents&lt;ComponentType&gt;();</span><br><span class="line"><span class="comment">// 3. 得到子对象挂载的脚本 (同时会寻找自身) 递归子对象</span></span><br><span class="line">ComponentType component = GetComponentInChildren&lt;ComponentType&gt;(); <span class="comment">// 相当于传入参数false, 子对象失活不会找到对应脚本</span></span><br><span class="line">GetComponentInChildren&lt;ComponentType&gt;(<span class="literal">true</span>); <span class="comment">// 即使子对象失活了也会找到对应脚本</span></span><br><span class="line">GetComponentsInChildren&lt;ComponentType&gt;(<span class="literal">true</span>); <span class="comment">// 查找所有</span></span><br><span class="line"><span class="comment">// 4. 得到父对象挂载的脚本 (同时会寻找自身) 递归父对象</span></span><br><span class="line">GetComponentInParent&lt;ComponentType&gt;(); <span class="comment">// 不可以传参</span></span><br><span class="line">GetComponentsInParent&lt;ComponentType&gt;();</span><br><span class="line"><span class="comment">// 5. 尝试 (和上面的直接获取后判空差不多)</span></span><br><span class="line">ComponentType component;</span><br><span class="line"><span class="keyword">if</span> (TryGetComponent&lt;ComponentType&gt;(<span class="keyword">out</span> component)) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>重点: <strong>注意GetComponentInChildren的参数, 默认情况下不会查找失活的子对象的脚本</strong></p>
<p>以上的<code>GetComponentsxxx</code>都可以传入一个list参数, 用以代替返回数组的函数</p>
<p>得到脚本就可以得到脚本相关的对象所有相关信息</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中GameObject的基础内容</title>
    <url>/unity/unity-gameobject-base/</url>
    <content><![CDATA[<p>GameObject就是游戏对象, 场景上的每一个对象都是一个GameObject, 一个prefab预制体也是一个GameObject对象, 而Transform, Button, 或者自定义的MonoBehaviour脚本, 都是需要依附于GameObject而存在</p>
<p>给GameObject挂载一个脚本, 就是创建了一个该脚本的实例, 并与GameObject绑定</p>
<h2 id="GameObject中的成员变量"><a href="#GameObject中的成员变量" class="headerlink" title="GameObject中的成员变量"></a>GameObject中的成员变量</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">gameObject.name; <span class="comment">// 获取/修改名字, 也就是层级窗口中的名字</span></span><br><span class="line">gameObject.activeSelf; <span class="comment">// 获取/修改 游戏对象本身是否激活</span></span><br><span class="line">gameObject.isStatic; <span class="comment">// 获取/修改 游戏对象是否是静态对象</span></span><br><span class="line">gameObject.layer; <span class="comment">// int 层级</span></span><br><span class="line">gameObject.tag; <span class="comment">// string 标签</span></span><br><span class="line">gameObject.transform;</span><br></pre></td></tr></table></figure>

<h2 id="GameObject中的静态方法"><a href="#GameObject中的静态方法" class="headerlink" title="GameObject中的静态方法"></a>GameObject中的静态方法</h2><h3 id="创建基础几何体"><a href="#创建基础几何体" class="headerlink" title="创建基础几何体"></a>创建基础几何体</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建自带几何体</span></span><br><span class="line">GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">cube.name = <span class="string">&quot;MyCube&quot;</span>;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="查找对象相关"><a href="#查找对象相关" class="headerlink" title="查找对象相关"></a>查找对象相关</h3><p>查找单个:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整个场景查找 (无法找到失活对象) 效率比较低, 会查找场景中所有对象, 找不到则返回null, 名字中可以用&#x27;/&#x27;表示父子层级 (尽量不要使用)</span></span><br><span class="line">GameObject obj = GameObject.Find(<span class="string">&quot;objName&quot;</span>);</span><br><span class="line"><span class="comment">// 根据tag查找 (无法找到失活对象)</span></span><br><span class="line">obj = GameObject.FindWithTag(<span class="string">&quot;tagName&quot;</span>); <span class="comment">// 与 FindGameObjectWithTag 一样</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Find</code>和<code>FindWithTag</code>只能找到激活的对象, 失活的对象无法找到</li>
<li><code>Find</code>和<code>FindWithTag</code>如果有名称或者标签相同的对象, 只会返回其中一个</li>
</ul>
<p>查找多个:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GameObject.FindGameObjectsWithTag(<span class="string">&quot;Enemy&quot;</span>); <span class="comment">// 通过tag找到多个对象 (只能找到激活对象)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只有通过tag查找多个对象, 没有通过名称查找多个对象</li>
<li><code>FindGameObjectsWithTag</code>也只能找到激活的对象</li>
</ul>
<p>其它的比如<code>FindGameObjectOfType&lt;&gt;()</code>, 效率更低, 一般不使用</p>
<h3 id="实例化-克隆对象"><a href="#实例化-克隆对象" class="headerlink" title="实例化/克隆对象"></a>实例化/克隆对象</h3><p>克隆的原对象可以是场景上的GameObject对象, 也可以是一个Prefab预制体对象 (一般都是用预设体创建)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GameObject obj = Object.Instantiate(myObj);</span><br></pre></td></tr></table></figure>

<h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Object.Destroy(obj); <span class="comment">// 删除GameObject对象, 也可以删除脚本对象</span></span><br><span class="line">Object.Destroy(obj, <span class="number">5</span>); <span class="comment">// 延迟5秒后删除</span></span><br></pre></td></tr></table></figure>

<p>删除对象:</p>
<ol>
<li>删除指定游戏对象</li>
<li>删除一个指定的脚本对象</li>
</ol>
<p>注意: Destroy方法不会马上移除对象, 一般情况下会在下一帧时移除对象</p>
<p>如果没有特殊需求一般使用Destroy(异步的), 降低卡顿概率</p>
<p>立即移除</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Object.DestroyImmediate(obj); <span class="comment">// 立即移除, 同步执行</span></span><br></pre></td></tr></table></figure>

<h3 id="过场景不移除"><a href="#过场景不移除" class="headerlink" title="过场景不移除"></a>过场景不移除</h3><p>默认情况下, 切换场景时, 场景中所有对象都会自动删除, 如果希望某个对象过场景时不移除</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Object.DontDestroyOnLoad(obj);</span><br></pre></td></tr></table></figure>

<h2 id="GameObject中的成员方法"><a href="#GameObject中的成员方法" class="headerlink" title="GameObject中的成员方法"></a>GameObject中的成员方法</h2><p>创建空物体</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GameObject obj = <span class="keyword">new</span> GameObject(); <span class="comment">// 也可以传入一个名称作为参数</span></span><br><span class="line">obj = <span class="keyword">new</span> GameObject(<span class="string">&quot;MyEmpty&quot;</span>);</span><br><span class="line">obj = <span class="keyword">new</span> GameObject(<span class="string">&quot;obj&quot;</span>, <span class="keyword">typeof</span>(ComponentType1), <span class="keyword">typeof</span>(ComponentType2)); <span class="comment">// 创建物体同时添加脚本</span></span><br></pre></td></tr></table></figure>

<p>为对象添加脚本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果obj是激活状态, 添加脚本会直接调用Awake, 否则, 在物体激活时调用Awake</span></span><br><span class="line">ComponentType component = obj.AddComponent&lt;ComponentType&gt;();</span><br></pre></td></tr></table></figure>

<p>得到脚本方法<code>GetComponent</code>与Mono脚本中的一致</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">obj.SetActive(<span class="literal">false</span>); <span class="comment">// 设置激活状态</span></span><br></pre></td></tr></table></figure>

<h3 id="不建议使用的方法"><a href="#不建议使用的方法" class="headerlink" title="不建议使用的方法"></a>不建议使用的方法</h3><p>以下方法效率低下, 不建议使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通知执行</span></span><br><span class="line">obj.SendMessage(<span class="string">&quot;TestFun&quot;</span>); <span class="comment">// 反射遍历所有脚本的方法, 执行同名方法, 也可以传参数</span></span><br><span class="line">obj.BroadcastMessage(<span class="string">&quot;FunName&quot;</span>); <span class="comment">// 让自己和子对象执行</span></span><br><span class="line">obj.SendMessageUpwards(<span class="string">&quot;FunName&quot;</span>); <span class="comment">// 让自己和父对象执行</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中Time类的基本内容</title>
    <url>/unity/unity-time-base/</url>
    <content><![CDATA[<p>主要用于游戏中参与位移/计时/时间速度/时间暂停等</p>
<h2 id="时间缩放比例"><a href="#时间缩放比例" class="headerlink" title="时间缩放比例"></a>时间缩放比例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间停止</span></span><br><span class="line">Time.timeScale = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 回复正常</span></span><br><span class="line">Time.timeScale = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 2倍速</span></span><br><span class="line">Time.timeScale = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="帧间隔时间"><a href="#帧间隔时间" class="headerlink" title="帧间隔时间"></a>帧间隔时间</h2><p>帧时间: 上一帧时间 (s)</p>
<p>帧间隔时间主要用于计算位移, 路程=时间*速度</p>
<ul>
<li>如果希望游戏暂停时不移动, 使用deltaTime</li>
<li>如果希望游戏暂停时移动不受到影响, 使用unscaledDeltaTime</li>
<li>timeScale不会影响Update的调用频率, 只会影响deltaTime的大小<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Update中使用</span></span><br><span class="line"><span class="comment">// 受timeScale影响</span></span><br><span class="line">Time.deltaTime; <span class="comment">// 相当于unscaledDeltaTime * timeScale</span></span><br><span class="line"><span class="comment">// 不受timeScale影响</span></span><br><span class="line">Time.unscaledDeltaTime;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>

<h2 id="游戏累计时间"><a href="#游戏累计时间" class="headerlink" title="游戏累计时间"></a>游戏累计时间</h2><p>一般只有单机游戏使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Time.time; <span class="comment">// 游戏开始到现在的时间</span></span><br></pre></td></tr></table></figure>

<h2 id="物理帧间隔时间"><a href="#物理帧间隔时间" class="headerlink" title="物理帧间隔时间"></a>物理帧间隔时间</h2><p>物理帧时间固定, 可以在ProjectSettings中的Time中设置物理帧时间</p>
<p>用于处理物理相关逻辑</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在FixedUpdate中使用</span></span><br><span class="line"><span class="comment">// 受到scale影响</span></span><br><span class="line">Time.fixedDeltaTime;</span><br><span class="line"><span class="comment">// 不受scale影响</span></span><br><span class="line">Time.unscaledFixedDeltaTime;</span><br></pre></td></tr></table></figure>

<h2 id="帧数"><a href="#帧数" class="headerlink" title="帧数"></a>帧数</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总帧数</span></span><br><span class="line">Time.frameCount;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的坐标类型和坐标转换</title>
    <url>/unity/unity-coordinate-system-and-translate/</url>
    <content><![CDATA[<h2 id="坐标类型"><a href="#坐标类型" class="headerlink" title="坐标类型"></a>坐标类型</h2><h3 id="世界坐标"><a href="#世界坐标" class="headerlink" title="世界坐标"></a>世界坐标</h3><p>在世界坐标系中, 相对于场景中世界零点(0, 0, 0)的坐标</p>
<p>Transform中的position属性就是世界坐标</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.position; <span class="comment">// 世界位置</span></span><br><span class="line">transform.rotation; <span class="comment">// 相对于世界坐标系的旋转 (四元数)</span></span><br><span class="line">transform.lossyScale; <span class="comment">// 相对于世界坐标系的缩放 (只读)</span></span><br></pre></td></tr></table></figure>

<h3 id="本地坐标"><a href="#本地坐标" class="headerlink" title="本地坐标"></a>本地坐标</h3><p>相对于父物体的位置, 旋转, 缩放</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.localPosition; <span class="comment">// 相对于父节点的位置</span></span><br><span class="line">transform.localRotation; <span class="comment">// 相对于父节点的旋转 (四元数)</span></span><br><span class="line">transform.localScale; <span class="comment">// 相对于父节点的缩放 (可读可写)</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="屏幕坐标"><a href="#屏幕坐标" class="headerlink" title="屏幕坐标"></a>屏幕坐标</h3><p>游戏窗口坐标, 窗口左下角为(0, 0), 该坐标以像素为单位</p>
<p>常见的屏幕坐标:</p>
<ul>
<li><p><strong>鼠标位置</strong> <code>Input.mousePosition</code></p>
</li>
<li><p><strong>指针事件</strong> <code>PointerEventData</code>中的position</p>
</li>
<li><p><strong>绘制GUI界面使用的坐标</strong> <code>OnGui</code>中绘制控件使用的坐标</p>
</li>
<li><p><code>Screen.width</code> 和 <code>Screen.height</code> 获取的是当前游戏窗口的宽和高 (像素单位)</p>
</li>
<li><p><code>Screen.currentResolution.width</code> 和 <code>Screen.currentResolution.height</code> 获取的是当前显示器的分辨率的宽高, 与游戏窗口大小无关</p>
</li>
</ul>
<h3 id="视口坐标"><a href="#视口坐标" class="headerlink" title="视口坐标"></a>视口坐标</h3><p>视口坐标, 指的是游戏窗口区域的<strong>比例单位</strong>, 左下角为(0, 0), 右上角(1.0, 1.0)</p>
<h2 id="坐标概念和转换"><a href="#坐标概念和转换" class="headerlink" title="坐标概念和转换"></a>坐标概念和转换</h2><h3 id="transform-forward与Vector3-forward"><a href="#transform-forward与Vector3-forward" class="headerlink" title="transform.forward与Vector3.forward"></a><code>transform.forward</code>与<code>Vector3.forward</code></h3><ul>
<li><code>transform.forward</code>是<strong>物体本地的z轴正方向的单位向量在世界坐标系中的值</strong>, 会随着物体旋转而改变</li>
<li><code>Vector3.forward</code>是世界坐标z轴正方向的单位向量, 永远是(0, 0, 1)</li>
</ul>
<p>e.g. 让物体朝自己的正前方移动:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 沿着自己正方向在世界坐标系中的向量, 以世界坐标系为参考移动</span></span><br><span class="line">transform.Translate(transform.forward, Space.World);</span><br><span class="line"><span class="comment">// 沿着自身坐标系的(0,0,1)方向移动</span></span><br><span class="line">transform.Translate(Vector3.forward, Space.Self);</span><br></pre></td></tr></table></figure>

<h3 id="本地坐标与世界坐标的转换"><a href="#本地坐标与世界坐标的转换" class="headerlink" title="本地坐标与世界坐标的转换"></a>本地坐标与世界坐标的转换</h3><h4 id="世界转本地"><a href="#世界转本地" class="headerlink" title="世界转本地"></a>世界转本地</h4><ul>
<li><p>世界坐标点 转换 本地坐标点 (受到缩放影响, 当物体放大时, 其本地坐标的单位长度也变大了)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.InverseTransformPoint(worldPos);</span><br></pre></td></tr></table></figure>
</li>
<li><p>世界坐标方向 转换 本地坐标系方向<br>向量方向不变, 原点从世界零点平移到物体原点, 并返回该向量在本地坐标系中的值</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不受缩放影响</span></span><br><span class="line">transform.InverseTransformDirection(worldDir);</span><br><span class="line"><span class="comment">// 受到缩放影响</span></span><br><span class="line">transform.InverseTransformVector(worldVec);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="本地转世界"><a href="#本地转世界" class="headerlink" title="本地转世界"></a>本地转世界</h4><ul>
<li><p>本地坐标点转世界坐标点 (受到缩放影响)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.TransformPoint(localPos);</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地方向转世界方向</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不受缩放影响</span></span><br><span class="line">transform.TransformDirection(localDir);</span><br><span class="line"><span class="comment">// 受缩放影响</span></span><br><span class="line">transform.TransformVector(localVec);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="屏幕坐标与世界坐标转换"><a href="#屏幕坐标与世界坐标转换" class="headerlink" title="屏幕坐标与世界坐标转换"></a>屏幕坐标与世界坐标转换</h3><ul>
<li><p>世界坐标点转为屏幕坐标点</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 screenPos = camera.WorldToScreenPoint(worldPos);</span><br></pre></td></tr></table></figure>
<p>这里返回的是一个Vector3, 其中(x, y)是像素单位的屏幕坐标, 而z是以世界单位的 点到相机所在平面的距离 (也就是相机坐标系中, 物体的z坐标)</p>
</li>
<li><p>屏幕坐标转为世界坐标</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 worldPos = camera.ScreenToWorldPoint(screenPos);</span><br></pre></td></tr></table></figure>
<p>这里传入的是一个Vector3, (x, y)是像素单位的屏幕坐标, z是世界单位的 点到相机所在平面的距离 (相机坐标系中 物体的z坐标)</p>
</li>
</ul>
<h3 id="UI中的坐标"><a href="#UI中的坐标" class="headerlink" title="UI中的坐标"></a>UI中的坐标</h3><p>查阅很多资料, 发现Unity的UGUI的坐标相对不太好理解, 而且很多地方将锚框anchorMin与anchorMax是否重合分成两种情况讲, 让我有些疑惑</p>
<p>这里查阅大量资料和动手实践, 试图找到一种解释, 让锚框无论是否为一点还是矩形框时, 其各属性都能得到统一的解释</p>
<p><code>RectTransform</code>继承于<code>Transform</code>, 它有自己特有的一些属性, 用于表示UI对象的位置信息</p>
<p>RectTransform中有position和localPosition和anchoredPosition是像素单位的屏幕坐标, 其它很多坐标都是比例坐标, 比如pivot, anchorMin, anchorMax. 为了方便表达, 以下<strong>使用xxxPos表示比例坐标对应的屏幕坐标</strong>, 比如pivotPos表示UI对象的轴心点实际的屏幕坐标</p>
<p>屏幕坐标: 相对于游戏窗口左下角的像素单位坐标</p>
<p><strong>Canvas</strong>的轴心点(pivotPos): 游戏窗口正中间(Screen.width/2, Screen.height/2)</p>
<p>以下用<code>rect</code>表示UI对象的<code>RectTransform</code>组件对象, xxxPos表示比例坐标对应的屏幕坐标</p>
<table>
<thead>
<tr>
<th>项</th>
<th>说明</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>position</td>
<td>Vector3 (z为0)</td>
<td>等于pivotPos, 也就是轴心点的屏幕坐标(相对于屏幕左下角的像素坐标)</td>
</tr>
<tr>
<td>localPosition</td>
<td>Vector3 (z为0)</td>
<td>UI对象的pivotPos相对于父对象pivotPos的屏幕坐标 (Canvas的轴心点为屏幕中间)</td>
</tr>
<tr>
<td>pivot</td>
<td>比例坐标 (0到1)</td>
<td>pivotPos在UI对象矩形框的位置, (0, 0)表示左下角, (1, 1)表示右上角; <strong>同时影响锚点位置</strong></td>
</tr>
<tr>
<td>rect</td>
<td>Rect</td>
<td>UI对象的矩形框, rect.min和rect.max是矩形框左下角和右上角相对于自身pivotPos的坐标, rect.size(UI真正大小)</td>
</tr>
<tr>
<td>anchorMin</td>
<td>比例坐标 (0到1)</td>
<td>UI对象锚框左下角, <strong>相对于父对象矩形框的比例位置</strong></td>
</tr>
<tr>
<td>anchorMax</td>
<td>比例坐标 (0到1)</td>
<td>锚框右上角, 相对于父对象的位置</td>
</tr>
<tr>
<td>anchorPos</td>
<td>不能直接获取</td>
<td><strong>真正锚点位置, anchorMinPos和anchorMaxPos对pivot求插值(Lerp)获得</strong></td>
</tr>
<tr>
<td>anchoredPosition</td>
<td>Vector2</td>
<td><strong>pivotPos相对于anchorPos的屏幕坐标</strong></td>
</tr>
<tr>
<td>offsetMin</td>
<td>Vector2</td>
<td>UI矩形框左下角坐标 - anchorMinPos</td>
</tr>
<tr>
<td>offsetMax</td>
<td>Vector2</td>
<td>UI矩形框右上角坐标 - anchorMaxPos</td>
</tr>
<tr>
<td>sizeDelta</td>
<td>Vector2</td>
<td>offsetMax - offsetMin (也就是<strong>UI矩形框大小减去锚框大小</strong>), 当锚框为一点时, 它与rect.size相同, 但要区别开来</td>
</tr>
</tbody></table>
<ul>
<li><p>sizeDelta只有当锚框为一点时与rect.size相同, 所以不能把它当作UI对象的大小, UI对象大小为<code>rect.size</code></p>
</li>
<li><p>anchorMin, anchorMax都是相对于父对象的比例坐标</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent 是当前UI对象的父对象的RectTransform</span></span><br><span class="line">Vector2 parentPos = parent.position; <span class="comment">// 自动取用x和y, 忽略z</span></span><br><span class="line">Vector2 anchorMinPos = parentPos + Vector2.Lerp(parent.rect.min, parent.rect.max, anchorMin); <span class="comment">// 这里忽略了类型转换</span></span><br><span class="line">Vector2 anchorMaxPos = parentPos + Vector2.Lerp(parent.rect.min, parent.rect.max, anchorMax);</span><br><span class="line">Vector2 anchorPos = Vector2.Lerp(anchorMinPos, anchorMaxPos, pivot); <span class="comment">// anchor也使用pivot</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中Transform的基础内容</title>
    <url>/unity/unity-transform-base/</url>
    <content><![CDATA[<p>创建一个GameObject对象时, 必定附加了Transform脚本 (必不可少)</p>
<h2 id="位置和位移"><a href="#位置和位移" class="headerlink" title="位置和位移"></a>位置和位移</h2><h3 id="Vector3基础"><a href="#Vector3基础" class="headerlink" title="Vector3基础"></a>Vector3基础</h3><p>Vector3主要表示三维坐标系中的一个点, 或者一个向量</p>
<p>Vector3是一个struct, 值类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">Vector3 v = <span class="keyword">new</span> Vector3();</span><br><span class="line">v.x = <span class="number">10</span>;</span><br><span class="line">Vector3 v1 = <span class="keyword">new</span> Vector3(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">Vector3 v2 = <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 运算</span></span><br><span class="line">print(v1 + v2); <span class="comment">// 12, 12, 7</span></span><br><span class="line">print(v1 - v2); <span class="comment">// 8, 8, 3</span></span><br><span class="line">print(v1 * <span class="number">10</span>);</span><br><span class="line">print(v1 / <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 常用</span></span><br><span class="line">print(Vector3.zero);</span><br><span class="line">print(Vector3.one);</span><br><span class="line">print(Vector3.right);</span><br><span class="line">print(Vector3.left);</span><br><span class="line">print(Vector3.forward);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line">Vector3.Distance(v1, v2); <span class="comment">// 计算两个点之间的距离</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.position; <span class="comment">// 相对于世界坐标系的位置</span></span><br><span class="line">transform.localPosition; <span class="comment">// 相对于父对象坐标系的位置</span></span><br></pre></td></tr></table></figure>

<p>注意: <strong>位置的赋值不能直接单独改变xyz某一个值, 只能整体赋值</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.position.x = <span class="number">10</span>; <span class="comment">// 报错!!!!</span></span><br><span class="line">transform.position = <span class="keyword">new</span> Vector3(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>如果想只改变一个轴的值:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个Vector3</span></span><br><span class="line">transform.position = <span class="keyword">new</span> Vector3(<span class="number">10</span>, transform.position.y, transform.position.z);</span><br><span class="line"><span class="comment">// 先取出来, 改值后再赋值回去</span></span><br><span class="line">Vector3 pos = transform.position;</span><br><span class="line">pos.x = <span class="number">10</span>;</span><br><span class="line">transform.position = pos;</span><br></pre></td></tr></table></figure>

<p>对象当前的面朝向 (在世界坐标系中的方向向量)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.forward;</span><br></pre></td></tr></table></figure>
<p>同样, 可以得到对象上下左右前后的朝向方向在世界坐标系中的方向向量</p>
<h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><p>路程 = 方向 * 速度 * 时间</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己计算</span></span><br><span class="line">transform.position += transform.forward * Time.deltaTime; <span class="comment">// 向自己前方移动</span></span><br><span class="line">transform.position += Vector3.forward * Time.deltaTime; <span class="comment">// 向世界z轴正方向移动</span></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line">transform.Translate(Vector3.forward); <span class="comment">// 默认相对于自身坐标系</span></span><br><span class="line">transform.Translate(Vector3.forward, Space.Self); <span class="comment">// 和上面一样</span></span><br><span class="line">transform.Translate(transform.forward, Space.World); <span class="comment">// 和上面一样</span></span><br><span class="line">transform.Translate(Vector3.forward, Space.World); <span class="comment">// 向世界坐标系z轴正方向移动</span></span><br></pre></td></tr></table></figure>

<p>注意: 一般都使用API进行移动</p>
<h2 id="角度和旋转"><a href="#角度和旋转" class="headerlink" title="角度和旋转"></a>角度和旋转</h2><h3 id="角度相关"><a href="#角度相关" class="headerlink" title="角度相关"></a>角度相关</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.rotation; <span class="comment">// 相对于世界坐标系的旋转 (四元数)</span></span><br><span class="line">transform.eulerAngles; <span class="comment">// 相对于世界坐标系的旋转 (欧拉角)</span></span><br><span class="line">transform.localEulerAngles; <span class="comment">// 相对于父对象的旋转 (欧拉角)</span></span><br><span class="line"><span class="comment">// 不能单独设置欧拉角的xzy, 需要整体改变</span></span><br><span class="line">Vector3 rotate = transform.localEulerAngles;</span><br><span class="line">rotate.x = <span class="number">90</span>;</span><br><span class="line">transform.localEulerAngles = rotate;</span><br></pre></td></tr></table></figure>

<h3 id="API计算"><a href="#API计算" class="headerlink" title="API计算"></a>API计算</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自转</span></span><br><span class="line">transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>) * Time.deltaTime, Space.Self); <span class="comment">// 第二个参数默认为自身坐标系</span></span><br><span class="line"><span class="comment">// 相对于某个轴旋转</span></span><br><span class="line">transform.Rotate(Vector3.up, <span class="number">10</span> * Time.deltaTime, Space.Self);</span><br><span class="line"><span class="comment">// 相对于某个点旋转</span></span><br><span class="line">transform.RotateAround(Vector3.zero, Vector3.up, <span class="number">10</span> * Time.deltaTime);</span><br></pre></td></tr></table></figure>

<h2 id="缩放和看向"><a href="#缩放和看向" class="headerlink" title="缩放和看向"></a>缩放和看向</h2><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相对世界坐标系</span></span><br><span class="line">transform.lossyScale; <span class="comment">// 不能修改, 只能读</span></span><br><span class="line"><span class="comment">// 相对于父对象的缩放</span></span><br><span class="line">transform.localScale; <span class="comment">// 可读可改</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同样, 缩放不能单独改xyz, 只能一起改, 而且只能改localScale</li>
<li>Unity没有提供关于缩放的API</li>
</ul>
<h3 id="看向"><a href="#看向" class="headerlink" title="看向"></a>看向</h3><p>让一个对象一直朝向某个点 (z轴正方向朝向某个点/对象)</p>
<p>应用: 炮台瞄准, 摄像机</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看向一个点, 点坐标为世界坐标系</span></span><br><span class="line">transform.LookAt(Vector3.zero);</span><br><span class="line"><span class="comment">// 看向一个对象, 传入transform即可, 一般第二个参数不需要改</span></span><br><span class="line">transform.LookAt(lookTransform);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的Camera内容</title>
    <url>/unity/unity-camera-base/</url>
    <content><![CDATA[<h2 id="Camera上可编辑的参数"><a href="#Camera上可编辑的参数" class="headerlink" title="Camera上可编辑的参数"></a>Camera上可编辑的参数</h2><ul>
<li><strong>Clear Flags</strong> 如何清除背景<ul>
<li>skybox 天空盒 (3D天空效果) 3D游戏使用</li>
<li>Solid Color 颜色填充 (背景为纯色) 2D游戏使用</li>
<li>Depth Only 只画该层, 背景透明 多个相机叠加渲染</li>
<li>Don’t Clear 不移除, 覆盖渲染 (极少使用) Game窗口右键选项(总是清空上一帧去掉后可以看到效果)</li>
</ul>
</li>
<li><strong>Culling Mask</strong> 选择渲染部分层级, 可以指定只渲染对应层级, 很常用</li>
<li><strong>Projection</strong> 透视方式<ul>
<li>Perspective 透视模式 (正常视角, 近大远小)<ul>
<li>Field of View 摄像机视口角度, 会改变视口大小和焦段, 一般60不改</li>
<li>FOV Axis 上面的角度按照水平还是垂直方向计算 一般不改</li>
<li>Physical Camera 真实摄像机开关 打开后可以像真实相机一样调整参数, 专业用法<ul>
<li>Focal Length 焦距</li>
<li>Sensor Type 传感器类型</li>
<li>Sensor Size 传感器尺寸</li>
<li>Lens Shift 透镜位移</li>
<li>Gate Fit 闸门配合</li>
</ul>
</li>
</ul>
</li>
<li>Orthographic 正交模式 (一般用于2D游戏制作)<ul>
<li>Size 摄制范围</li>
</ul>
</li>
</ul>
</li>
<li><strong>Clipping Planes</strong> 裁剪平面距离 (裁剪范围内可见, 有可能模型被裁剪一半)<ul>
<li>Near 近距离裁剪距离, 物体距离相机小于该距离则不可见</li>
<li>Far 远距裁剪距离, 物体距离相机大于该距离则不可见</li>
</ul>
</li>
<li>Viewport Rect 主要用于多摄像机游戏, 设置摄像机的渲染范围<ul>
<li>x和y是渲染起点, w和h是宽和高 (都是0到1, (0, 0)表示窗口左下角)</li>
</ul>
</li>
<li><strong>Depth</strong> 渲染顺序上的深度 (深度高的相机越后渲染, 深度高的相机会覆盖深度低的相机画面) 需要配合多个相机和<code>Depth Only</code>配合使用<ul>
<li>深度最低的相机渲染背景和基本画面</li>
<li>深度高的相机选择渲染某个特殊层, 并且选择DepthOnly(背景透明), 那么就可以叠加显示</li>
</ul>
</li>
<li>Redering path 渲染路径 (默认使用渲染设置)</li>
<li><strong>Target Texture</strong> 可以把摄像机画面渲染到一张图上 (默认渲染到游戏窗口)<ul>
<li>Project上右键新建<code>Render Texture</code></li>
<li>相机渲染中的<code>Target Texture</code>选择新建的Texture, 那么该相机的画面就渲染在这个Texture中</li>
<li>小地图: 俯视摄像机, Texture做小地图</li>
</ul>
</li>
<li><strong>Occlusion Culling</strong> 是否启用剔除遮挡, 用于性能优化<ul>
<li>被完全遮挡的模型是否渲染</li>
</ul>
</li>
<li>Allow HDR 是否允许高动态范围渲染 (默认使用渲染设置)</li>
<li>Allow MSAA 是否允许抗锯齿 (默认使用渲染设置)</li>
<li>Allow Dynamic Resolution 是否允许动态分辨率呈现</li>
<li>Target Display 该相机显示在那个显示器, 主要用于开发有多个屏幕的平台游戏 (Game窗口可以切换显示的Display) 最多支持8个</li>
<li>Target Eye 制作VR相关</li>
</ul>
<p>在ProjectSettings中可以更改渲染设置</p>
<a id="more"></a>

<h2 id="Camera代码相关"><a href="#Camera代码相关" class="headerlink" title="Camera代码相关"></a>Camera代码相关</h2><h3 id="重要静态成员"><a href="#重要静态成员" class="headerlink" title="重要静态成员"></a>重要静态成员</h3><ol>
<li>获取摄像机 最基本的就是拖拽方式<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速获取主摄像机</span></span><br><span class="line">Camera.main;</span><br><span class="line"><span class="comment">// 获取摄像机数量</span></span><br><span class="line">Camera.allCamerasCount;</span><br><span class="line"><span class="comment">// 得到所有摄像机</span></span><br><span class="line">Camera[] allCameras = Camera.allCameras;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>获取<code>Camera.main</code>一定要求场景中有一个摄像机的Tag是<code>MainCamera</code>, 一般只设置一个主摄像机</p>
<ol start="2">
<li>渲染相关委托<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 摄像机遮挡剔除之前处理的委托函数</span></span><br><span class="line">Camera.onPreCull += (c) =&gt; &#123;&#125;;</span><br><span class="line"><span class="comment">// 摄像机渲染前处理的委托</span></span><br><span class="line">Camera.onPreRender += (c) =&gt; &#123;&#125;;</span><br><span class="line"><span class="comment">// 摄像机 渲染后 处理的委托</span></span><br><span class="line">Camera.onPostRender += (c) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 界面上的参数都可以通过代码访问设置</span></span><br><span class="line">Camera.main.depth = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 2. 世界坐标转换屏幕坐标 转换后的x和y是以屏幕左下角为原点的像素坐标(屏幕坐标), z表示物体距离摄像机的z轴距离(世界单位)</span></span><br><span class="line">Vector3 screenPos = Camera.main.WorldToScreenPoint(transform.position);</span><br><span class="line"><span class="comment">// 3. 屏幕坐标转换世界坐标 传入的Vector3的x和y是屏幕坐标, z为距离相机在z方向上的距离</span></span><br><span class="line">Vector3 pos = Input.mousePosition;</span><br><span class="line">pos.z = <span class="number">10</span>; <span class="comment">// z方向距离相机10个世界单位, 若z为0, 表示计算的世界坐标和相机重合了, 没有意义</span></span><br><span class="line">Camera.main.ScreenToWorldPoint(pos);</span><br></pre></td></tr></table></figure>

<ul>
<li>WorldToScreenPoint可以用于做血条, 根据z轴大小得到距离, 对血条UI进行缩放</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的父子关系</title>
    <url>/unity/unity-transform-parent/</url>
    <content><![CDATA[<h2 id="获取和设置父对象"><a href="#获取和设置父对象" class="headerlink" title="获取和设置父对象"></a>获取和设置父对象</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取父对象, 如果没有父对象, 则为null</span></span><br><span class="line">transform.parent;</span><br><span class="line"><span class="comment">// 设置父对象, 如果设置为null, 则没有父对象, 在场景根目录</span></span><br><span class="line">transform.parent = <span class="literal">null</span>;</span><br><span class="line">transform.parent = otherObj.transform;</span><br><span class="line"><span class="comment">// 通过API设置父子关系 第二个参数默认为false</span></span><br><span class="line">transform.SetParent(<span class="literal">null</span>);</span><br><span class="line">transform.SetParent(otherTransform);</span><br><span class="line"><span class="comment">// API第二个参数: 是否保留相对世界坐标系的 位置&amp;旋转&amp;缩放</span></span><br><span class="line">transform.SetParent(otherTransform, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>SetParent第二个参数为true, 则修改相对于父级的位置&amp;旋转&amp;缩放, 使得对象保持原有的世界空间位置&amp;旋转&amp;缩放</li>
<li>第二个参数为false, 则物体修改父级后相对于新父级的位置&amp;旋转&amp;缩放 与物体相对于原来父级的位置&amp;旋转&amp;缩放 保持一致</li>
</ul>
<h2 id="分离所有子对象"><a href="#分离所有子对象" class="headerlink" title="分离所有子对象"></a>分离所有子对象</h2><p>分离后, 子对象直接到根目录下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.DetachChildren();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="获取子对象"><a href="#获取子对象" class="headerlink" title="获取子对象"></a>获取子对象</h2><p>返回的是Transform信息</p>
<p><strong>可以查找到失活的对象</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按名称查找 只能找到直接子对象, 不能找子对象的子对象!!!</span></span><br><span class="line">transform.Find(<span class="string">&quot;SubCube&quot;</span>);</span><br><span class="line"><span class="comment">// 获取直接子对象 (失活也算数)</span></span><br><span class="line">transform.childCount; <span class="comment">// 直接子对象数量</span></span><br><span class="line">transform.GetChild(<span class="number">0</span>); <span class="comment">// 根据下标取直接子对象</span></span><br></pre></td></tr></table></figure>

<h2 id="子对象操作"><a href="#子对象操作" class="headerlink" title="子对象操作"></a>子对象操作</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否为某个Transform的子对象 (直接子对象)</span></span><br><span class="line">transform.IsChildOf(otherTransform);</span><br><span class="line"><span class="comment">// 得到自己作为子对象的编号</span></span><br><span class="line">tranform.GetSiblingIndex();</span><br><span class="line"><span class="comment">// 设置为第一个子对象 (层级窗口中最上面/视图窗口中在最后面)</span></span><br><span class="line">transform.SetAsFirstSibling();</span><br><span class="line"><span class="comment">// 设置为最后一个子对象</span></span><br><span class="line">transform.SetAsLastSibling();</span><br><span class="line"><span class="comment">// 设置为指定编号的子对象</span></span><br><span class="line">transform.SetSiblingIndex(<span class="number">15</span>); <span class="comment">// 为负数或者朝纲, 都设置为最后一个子对象</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中光源组件基础</title>
    <url>/unity/unity-light-system-base/</url>
    <content><![CDATA[<p>下载标准资源包, 可以在package manager中搜索StandardAssets, 导入需要的内容 (这里用Effects/Lightxxx中的资源)</p>
<p>学习组件, 可以点击组件右上角的问号, 查看相应文档</p>
<h2 id="面板参数"><a href="#面板参数" class="headerlink" title="面板参数"></a>面板参数</h2><ul>
<li><strong>Type</strong> 光源类型<ul>
<li>Spot 聚光灯<ul>
<li>Range 发光范围, 值越大, 光越亮, 距离越远</li>
<li>Spot Angle 光锥角度</li>
</ul>
</li>
<li>Directional 方向光</li>
<li>Point 点光源<ul>
<li>Range 发光范围</li>
</ul>
</li>
<li>Area 面光源 (仅烘焙可用, 上面三个为实时光照)</li>
</ul>
</li>
<li><strong>Color</strong> 光的颜色</li>
<li><strong>Mode</strong> 光源模式<ul>
<li>Realtime 实时光源, 每帧实时计算, 效果好, 性能开销大</li>
<li>Baked 烘焙光源, 事先计算好, 无动态变化</li>
<li>Mixed 混合计算, 预先计算+实时运算</li>
</ul>
</li>
<li><strong>Intensity</strong> 光照强度</li>
<li>Indirect Multiplier 改变间接光强度<ul>
<li>低于1, 每次光反弹会更暗</li>
<li>大于1, 每次光反弹会更亮</li>
</ul>
</li>
<li><strong>Shadow Type</strong><ul>
<li>NoShadows 无阴影</li>
<li>HardShadows 生硬阴影 (有锯齿)</li>
<li>SoftShadows 柔软阴影 (有性能消耗)</li>
</ul>
</li>
<li>RealtimeShadows<ul>
<li>Strength 阴影暗度 0-1, 越大越暗</li>
<li>Resolution 阴影贴图渲染分辨率, 越高越逼真 (默认使用质量设置)</li>
<li>Bias 阴影推离光源的距离 (阴影计算, 一般不用)</li>
<li>Normal Bias 阴影投射面沿法线收缩距离 (一般不用)</li>
<li>Near Panel 渲染阴影的近裁剪面 (一般不用)</li>
</ul>
</li>
<li><strong>Cookie</strong> 投影遮罩 (一般用于聚光灯)<ul>
<li>拖拽一张贴图(黑白图, 白色有光)到Cookie, 可以让光呈现特殊形状</li>
</ul>
</li>
<li>Cookie Size (不常用, 只在方向光中设置Cookie才能用, 但是方向光一般不用Cookie)</li>
<li><strong>Draw Halo</strong> 球形光晕效果 (蜡烛/太阳)</li>
<li><strong>Flare</strong> 耀斑 (一般用于方向光等强光)<ul>
<li><strong>如果想要在游戏视图看到耀斑, 需要在摄像机上加一个FlareLayer脚本</strong></li>
</ul>
</li>
<li>Render Mode 渲染模式<ul>
<li>Auto 运行时确定</li>
<li>Important 以像素为单位进行渲染, 逼真, 消耗大</li>
<li>Not Important 以快速模式进行渲染</li>
</ul>
</li>
<li><strong>Culling Mask</strong> 选择哪些层受到光照影响</li>
</ul>
<h2 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h2><p>Light中一般都是成员</p>
<p>Light面板中的内容都可以通过代码获取修改, 可以进入类中看看</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 光源强度</span></span><br><span class="line">light.intensity = <span class="number">0.5f</span>;</span><br></pre></td></tr></table></figure>

<h2 id="光相关面板"><a href="#光相关面板" class="headerlink" title="光相关面板"></a>光相关面板</h2><h3 id="Lighting-Settings"><a href="#Lighting-Settings" class="headerlink" title="Lighting Settings"></a>Lighting Settings</h3><p>Window/Rendering/Lighting Settings</p>
<ul>
<li><p>Environment 环境相关设置</p>
<ul>
<li>Skybox Material 天空盒材质, 可改变天空云朵 (需要特殊材质)</li>
<li>Sun Source 太阳来源 (不设置默认使用场景中最亮的方向光代表太阳)</li>
<li>Environment Lighting 环境光设置<ul>
<li>Source 环境光光源颜色 (一般用天空盒即可)<ul>
<li>Skybox 天空盒材质作为环境光颜色</li>
<li>Gradient 可以为天空/地平线/地面单独选择颜色和他们之间混合</li>
</ul>
</li>
<li>Intensity Mutiplier 环境光亮度 (在洞穴才能看到效果)</li>
<li>Ambient Mode 全局光照模式 (只有启用了实时全局和全局烘焙时才有用)</li>
</ul>
</li>
</ul>
</li>
<li><p>OtherSettings 其它设置</p>
<ul>
<li>Fog 雾开关 (手游中一般不会开雾)<ul>
<li>Color 雾的颜色</li>
<li>Mode 雾计算模式<ul>
<li>Linear 随距离线性增加<ul>
<li>Start 距离摄像机多远开始有雾</li>
<li>End 距离摄像机多远完全遮挡</li>
</ul>
</li>
<li>Exponential 随距离指数增加<ul>
<li>Density 强度</li>
</ul>
</li>
<li>Exponential Qquare 随距离比指数更快的增加<ul>
<li>Density 强度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Halo Texture 光源周围光晕的纹理</p>
</li>
<li><p>Halo Strength 光晕可见性</p>
</li>
<li><p>Flare Fade Speed 耀斑淡出时间 (最初出现之后淡出的时间)</p>
</li>
<li><p>Flare Strength 耀斑可见性</p>
</li>
<li><p>Spot Cookie 探照灯默认裁剪形状 (影响所有探照灯)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity的Input输入系统</title>
    <url>/unity/unity-input-base/</url>
    <content><![CDATA[<p>注意: 输入相关的内容一般都是在Update中使用的</p>
<h2 id="鼠标在屏幕上的位置"><a href="#鼠标在屏幕上的位置" class="headerlink" title="鼠标在屏幕上的位置"></a>鼠标在屏幕上的位置</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鼠标坐标是屏幕坐标 (以游戏窗口左下角为原点的像素坐标)</span></span><br><span class="line">Vector3 mousePos = Input.mousePosition; <span class="comment">// z轴一直为0</span></span><br></pre></td></tr></table></figure>

<h2 id="检测鼠标输入"><a href="#检测鼠标输入" class="headerlink" title="检测鼠标输入"></a>检测鼠标输入</h2><p>以下内容在Update中使用</p>
<p>0 左键; 1 右键; 2 中键</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测鼠标按下的一瞬间 (只检测一次)</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line"><span class="comment">// 检测鼠标抬起的一瞬间 (只检测一次)</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line"><span class="comment">// 持续检测 (只要鼠标按下状态, 每一帧都会检测为true)</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line"><span class="comment">// 获取中建滚动 Vector2 x为0, y值为-1则表示下滚, 0表示没有滚动, 1表示向上滚动</span></span><br><span class="line">Input.mouseScrollDelta;</span><br></pre></td></tr></table></figure>

<h2 id="检测按键输入"><a href="#检测按键输入" class="headerlink" title="检测按键输入"></a>检测按键输入</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测按键按下</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.W)) &#123;&#125; <span class="comment">// 检测W键按下</span></span><br><span class="line"><span class="comment">// 检测按键抬起</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyUp(KeyCode.W)) &#123;&#125;</span><br><span class="line"><span class="comment">// 检测按键 按下时会一直检测</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKey(KeyCode.W)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>检测按键还有个传入字符串的重载, 但是只能传入小写字母的字符串, 不建议使用</li>
<li>可以进入KeyCode中查看可以检测的按键</li>
</ul>
<a id="more"></a>

<h2 id="检测默认轴输入"><a href="#检测默认轴输入" class="headerlink" title="检测默认轴输入"></a>检测默认轴输入</h2><p>在ProjectSettings中的InputManager可以设置轴输入, 也可以添加自定义的轴</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示水平输入 值从-1到1, 会渐变变化, 可以在设置中更改变化速度,按键等</span></span><br><span class="line"><span class="keyword">float</span> h = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line"><span class="comment">// 垂直输入</span></span><br><span class="line"><span class="keyword">float</span> v = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"><span class="comment">// 鼠标左右移动 -1到1渐变</span></span><br><span class="line"><span class="keyword">float</span> mouseh = Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>);</span><br><span class="line"><span class="comment">// 鼠标上下移动 -1到1渐变</span></span><br><span class="line"><span class="keyword">float</span> mousev = Input.GetAxis(<span class="string">&quot;Mouse Y&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GetAxis</code>和<code>GetAxisRaw</code>的使用方法相同, 只不过<code>GetAxisRaw</code>只会返回-1,0或者1, 不会有值的渐变; 而<code>GetAxis</code>在按键变化时值会有渐变</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否有任意键或者鼠标按着</span></span><br><span class="line"><span class="keyword">if</span> (Input.anyKey) &#123;&#125;</span><br><span class="line"><span class="comment">// 是否有任意键或者鼠标按下了 (一次检测)</span></span><br><span class="line"><span class="keyword">if</span> (Input.anyKeyDown)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前的键盘输入</span></span><br><span class="line">    print(Input.inputString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手柄输入相关</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到链接的手柄的所有按钮名字</span></span><br><span class="line"><span class="keyword">string</span>[] btns = Input.GetJoystickNames();</span><br><span class="line"><span class="comment">// 某一个手柄键按下</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>)) &#123;&#125;</span><br><span class="line"><span class="comment">// 某一个手柄键抬起</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetButtonUp(<span class="string">&quot;Jump&quot;</span>)) &#123;&#125;</span><br><span class="line"><span class="comment">// 某个手柄键长按</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetButton(<span class="string">&quot;Jump&quot;</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>移动设备触摸相关</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Input.touchCount &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Touch t1 = Input.touches[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 触摸位置</span></span><br><span class="line">    print(t1.position);</span><br><span class="line">    <span class="comment">// 相对于上次的位置变化</span></span><br><span class="line">    print(t1.deltaPosition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否启用多点触控</span></span><br><span class="line">Input.multiTouchEnabled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>重力感应 (陀螺仪)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否开启陀螺仪</span></span><br><span class="line">Input.gyro.enabled = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 重力加速度向量</span></span><br><span class="line">print(Input.gyro.gravity);</span><br><span class="line"><span class="comment">// 旋转速度</span></span><br><span class="line">print(Input.gyro.rotationRate);</span><br><span class="line"><span class="comment">// 陀螺仪 当前的旋转四元数</span></span><br><span class="line">print(Input.gyro.attitude);</span><br></pre></td></tr></table></figure>

<p>Input类中还有很多其它内容, 可以进入类中查看</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity物理系统--刚体</title>
    <url>/unity/unity-physical-system-rigid-body/</url>
    <content><![CDATA[<p>碰撞产生的必要条件: <strong>两个物体都有碰撞器, 至少一个物体有刚体</strong></p>
<p>碰撞器(Collider): 用于表示一个物体的体积</p>
<p>刚体(Rigidbody): 让物体能够受到力的作用</p>
<h2 id="Rigidbody组件信息"><a href="#Rigidbody组件信息" class="headerlink" title="Rigidbody组件信息"></a>Rigidbody组件信息</h2><h3 id="Mass-质量"><a href="#Mass-质量" class="headerlink" title="Mass 质量"></a>Mass 质量</h3><p>默认为千克, 质量越大惯性越大</p>
<p>质量比较大的时候, 不容易改变当前状态, 越不容易被别的物体/力推动</p>
<h3 id="Drag-空气阻力"><a href="#Drag-空气阻力" class="headerlink" title="Drag 空气阻力"></a>Drag 空气阻力</h3><p>根据力移动对象时, 影响对象的空气阻力大小, 0表示没有空气阻力</p>
<h3 id="Angular-Drag-扭矩阻力"><a href="#Angular-Drag-扭矩阻力" class="headerlink" title="Angular Drag 扭矩阻力"></a>Angular Drag 扭矩阻力</h3><p>扭矩阻力, 物体旋转时受到的阻力大小</p>
<h3 id="Use-Gravity-使用重力"><a href="#Use-Gravity-使用重力" class="headerlink" title="Use Gravity 使用重力"></a>Use Gravity 使用重力</h3><p>是否受重力影响</p>
<h3 id="Is-Kinematic-运动学选项"><a href="#Is-Kinematic-运动学选项" class="headerlink" title="Is Kinematic 运动学选项"></a>Is Kinematic 运动学选项</h3><p>运动学选项 (就像让原本的刚体失效了)</p>
<p>如果启用此选项, 则对象不会被物理引擎驱动, 只能通过Transform对其进行操作, 对于移动的平台, 或者要动画化附加了HingeJoint的刚体, 此属性将非常有用</p>
<h3 id="Interpolate-插值运算"><a href="#Interpolate-插值运算" class="headerlink" title="Interpolate 插值运算"></a>Interpolate 插值运算</h3><p>让刚体物体移动更加平滑</p>
<ul>
<li>None 不应用插值运算</li>
<li>Interpolate 根据前一帧的变换来平滑变换</li>
<li>Extrapolate 差值运算, 根据下一帧的估计变换来平滑变换</li>
</ul>
<p>ProjectSettings 中 Time选项中可以设置物理帧时间</p>
<p>当物理帧时间变长时, 如果不运用插值运算, 则物体的运动将是跳跃式(可以将物理帧改为1秒看效果)</p>
<p>所以当需要将物理帧时间加长时, 插值运算将非常有用, 它可以让物体的运动变得平滑</p>
<p>一般根据具体情况选择算法, 但是当物理帧时间比较长的时候, 建议使用根据前一帧的算法(Interpolate)</p>
<h3 id="Collision-Detection-碰撞检测模式-重要"><a href="#Collision-Detection-碰撞检测模式-重要" class="headerlink" title="Collision Detection 碰撞检测模式 (重要)"></a>Collision Detection 碰撞检测模式 (重要)</h3><p><strong>用于防止快速移动的对象穿过其它对象而不检测碰撞</strong></p>
<p>例如: 高速的子弹穿过薄板, 可能会因为子弹速度非常快, 上一帧在木板前(未碰到), 下一帧穿过木板在木板后(未碰到), 就会检测不到子弹与木板的碰撞 因为默认使用的是离散检测(每帧检测)</p>
<ul>
<li>Discrete 离散检测 (默认值)</li>
</ul>
<p>对场景中的所有其它碰撞体使用离散碰撞检测, 其它碰撞体在测试碰撞时会使用离散碰撞检测, 用于正常碰撞</p>
<ul>
<li>Continuous 连续检测<ul>
<li>对动态碰撞体 (具有刚体) 使用离散碰撞检测</li>
<li>并对静态碰撞体(没有刚体) 使用连续碰撞检测</li>
<li>设置为连续动态检测 (Continuous Dynamic) 的刚体在测试与该刚体的碰撞时使用连续碰撞检测 (此属性对物理性能有很大影响, 如果没有快速对象碰撞的问题, 应该将其保留为Discrete设置)</li>
<li>其它的刚体将使用离散碰撞检测</li>
</ul>
</li>
<li>Continuous Dynamic (连续动态检测) 性能消耗高<ul>
<li>对设置为连续(Continuous)和连续动态(Continuous Dynamic)碰撞的游戏对象使用连续碰撞检测</li>
<li>对静态碰撞体(没有刚体)使用连续碰撞检测</li>
</ul>
</li>
<li>Continuous Speculative (连续推测检测)<ul>
<li>对刚体和碰撞体使用推测行连续碰撞检测, 该方法通常比连续碰撞检测的成本更低</li>
</ul>
</li>
</ul>
<p>一般使用的时候直接看图使用即可, 除非需要检测高速移动物体的碰撞检测, 否则一般保持为离散检测, 节约性能 (性能消耗越高, 检测越准确)</p>
<img data-src="/unity/unity-physical-system-rigid-body/collision.png" class="">

<h3 id="Constraints-约束"><a href="#Constraints-约束" class="headerlink" title="Constraints 约束"></a>Constraints 约束</h3><p>对刚体运动的约束</p>
<ul>
<li>Freeze Position 有选择的停止刚体沿某个轴运动</li>
<li>Freeze Rotation 有选择的停止刚体绕某个轴的旋转</li>
</ul>
<h3 id="info-调试参数"><a href="#info-调试参数" class="headerlink" title="info 调试参数"></a>info 调试参数</h3><p>可以实时查看刚体上的物理信息</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中Screen类中的内容</title>
    <url>/unity/unity-screen-base/</url>
    <content><![CDATA[<p>Screen提供屏幕相关内容</p>
<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是一个表示当前屏幕(显示器, 而不是游戏窗口)分辨率的结构体 有宽高和刷新频率</span></span><br><span class="line">Resolution r = Screen.currentResolution;</span><br><span class="line">print(r.with);</span><br><span class="line">print(r.height);</span><br><span class="line"><span class="comment">// 当前游戏窗口大小 (一般使用这个大小)</span></span><br><span class="line">print(Screen.width);</span><br><span class="line">print(Screen.height);</span><br><span class="line"><span class="comment">// 屏幕休眠模式</span></span><br><span class="line">Screen.sleepTimeout = SleepTimeout.NeverSleep;</span><br></pre></td></tr></table></figure>

<h3 id="不常用"><a href="#不常用" class="headerlink" title="不常用"></a>不常用</h3><p>全屏相关</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行时是否全屏模式</span></span><br><span class="line">Screen.fullScreen = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 设置全屏模式为 窗口模式 (还有独占全屏/全屏窗口/最大化窗口)</span></span><br><span class="line">Screen.fullScreenMode = FullScreenMode.Windowed;</span><br></pre></td></tr></table></figure>

<p>移动设备屏幕旋转相关</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许自动旋转为左横向 Home在左</span></span><br><span class="line">Screen.autorotateToLandscapeLeft = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 允许自动旋转为右横向 Home在右</span></span><br><span class="line">Screen.autorotateToLandscapeRight = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 允许自动旋转为纵向 Home在下</span></span><br><span class="line">Screen.autorotateToPortrait = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 允许自动旋转为倒着 Home在上</span></span><br><span class="line">Screen.autorotateToPortraitUpsideDown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定屏幕显示方向</span></span><br><span class="line">Screen.orientation = ScreenOrientation.Landscape; <span class="comment">// 横屏</span></span><br></pre></td></tr></table></figure>

<p>上述内容一般不会直接用代码设置, 而是打包时统一配置</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置分辨率 (移动设备不使用)</span></span><br><span class="line">Screen.SetResolution(<span class="number">1920</span>, <span class="number">1080</span>, <span class="literal">false</span>); <span class="comment">// 最后是是否全屏</span></span><br></pre></td></tr></table></figure>

<p>其它内容可以进入类中查看</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity的音效系统</title>
    <url>/unity/unity-audio-system/</url>
    <content><![CDATA[<h2 id="音效文件导入"><a href="#音效文件导入" class="headerlink" title="音效文件导入"></a>音效文件导入</h2><h3 id="常用音频格式"><a href="#常用音频格式" class="headerlink" title="常用音频格式"></a>常用音频格式</h3><p>Unity中支持的音频格式:</p>
<p>wav mp3 ogg aiff</p>
<h3 id="音频文件选项"><a href="#音频文件选项" class="headerlink" title="音频文件选项"></a>音频文件选项</h3><p>预览面板三个按钮(播放, 选中时自动播放, 循环播放)</p>
<ul>
<li>Force To Mono 多声道转为单声道 (一般不勾选)<ul>
<li>Normalize 强制为单声道时, 混合过程中被标准化</li>
</ul>
</li>
<li><strong>Load In Background</strong> 在后台加载, 不阻塞主线程</li>
<li>Ambisonic 立体声混响 (非常适合360度视频和XR应用程序) 如果音频文件包含立体混响声编码的音频, 请启用此选项</li>
<li><strong>Load Type</strong> 加载类型<ul>
<li>Decompress On Load 不压缩模式存在内存, 加载快, 但占用内存高 (适用于小音效)</li>
<li>Compress In Memory 压缩形式存在内存, 加载慢, 内存小 (仅适用于较大的音效文件)</li>
<li>Streaming 以流形式存在, 使用时编码, 内存占用最小, cpu消耗高 (性能换内存)</li>
</ul>
</li>
<li><strong>Preload Audio Data</strong> 预加载音频 (一般勾选)<ul>
<li>勾选后, 进入场景就加载, 不勾选则第一次使用时才加载</li>
</ul>
</li>
<li>Compression Format 压缩方式<ul>
<li>PCM 音频以最高质量存储, 背景音效</li>
<li>Vorbis 相对PCM压缩的更小, 根据质量决定</li>
<li>ADPCM 包含噪音, 会被多次播放的声音, 如碰撞声, 打击音效</li>
</ul>
</li>
<li>Quality 音频质量 确定要应用于压缩剪辑的压缩量<ul>
<li>不适用于PCM/ADPCM/HEVAG格式, 只适用于Vorbis</li>
</ul>
</li>
<li>Sample Rate Setting PCM和ADPCM压缩格式允许自动优化或手动降低采样率<ul>
<li>Preserve Sample Rate 保持采样率不变 (默认值)</li>
<li>Optimize Sample Rate 根据分析的最高频率内容自动优化采样率</li>
<li>Override Sample Rate 允许手动覆盖采样率, 可有效地将其用于丢弃频率内容</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="音频源和音频监听脚本"><a href="#音频源和音频监听脚本" class="headerlink" title="音频源和音频监听脚本"></a>音频源和音频监听脚本</h2><h3 id="AudioSource-音频源"><a href="#AudioSource-音频源" class="headerlink" title="AudioSource 音频源"></a>AudioSource 音频源</h3><ul>
<li><strong>AudioClip</strong> 声音剪辑文件 音频文件</li>
<li>Output 默认直接输出到场景中的音频监听器, 可更改为输出到混音器</li>
<li><strong>Mute</strong> 静音开关</li>
<li>Bypass Effect 开关滤波器效果</li>
<li>Bypass Listener Effects 快速开关所有监听器</li>
<li>Bypass Reverb Zones 快速开关所有混响区</li>
<li><strong>Play On Awake</strong> 对象创建时就播放音乐</li>
<li><strong>Loop</strong> 循环</li>
<li>Priority 优先级 (默认128)</li>
<li><strong>Volume</strong> 音量大小</li>
<li>Pitch 音高 (声音快放/慢放的效果, 可以在游戏加速/减速时使用)</li>
<li>Stereo Pan 2D声音立体声位置 (相当于左右声道)</li>
<li><strong>Spatial Blend</strong> 音频受3D空间的影响程度 (一般只用0或者1, 2D音效或者3D音效)</li>
<li>Reverb Zone Mix 到混响区的输出信号量</li>
<li>3D Sound Settings 和Spatial Blend参数成正比应用<ul>
<li>Doppler Level 多普勒效果等级</li>
<li>Spread 扩散角度设置为3D立体声还是多声道</li>
<li>Volume Rolloff 声音衰减速度<ul>
<li>Logarithmic Rolloff 靠近音频源时声音很大, 但离开对象时声音降低得非常快</li>
<li>Linear Rolloff 与音频源距离越远, 听到得声音越小</li>
<li>Custom Rolloff 音频源得音频效果是根据曲线图得设置变化得</li>
</ul>
</li>
<li>Min/Max Distance 最小距离内, 声音保持最大响度; 最大距离外, 声音完全听不到</li>
</ul>
</li>
</ul>
<h3 id="AudioListener-音频监听脚本"><a href="#AudioListener-音频监听脚本" class="headerlink" title="AudioListener 音频监听脚本"></a>AudioListener 音频监听脚本</h3><p>摄像机上默认添加AudioListener脚本</p>
<p>该脚本相当于游戏的’耳朵’, 如果没有该脚本对象, 则听不到任何声音</p>
<p>场景上必须有且只有一个AudioListener脚本</p>
<h2 id="代码控制音频源"><a href="#代码控制音频源" class="headerlink" title="代码控制音频源"></a>代码控制音频源</h2><h3 id="代码控制播放停止"><a href="#代码控制播放停止" class="headerlink" title="代码控制播放停止"></a>代码控制播放停止</h3><p>AudioSource</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">audioSource = GetComponent&lt;AudioSource&gt;();</span><br><span class="line"><span class="comment">// 播放</span></span><br><span class="line">audioSource.Play();</span><br><span class="line"><span class="comment">// 停止</span></span><br><span class="line">audioSource.Stop();</span><br><span class="line"><span class="comment">// 暂停 (之后再播放则继续播放)</span></span><br><span class="line">audioSource.Pause();</span><br><span class="line"><span class="comment">// 取消暂停 (和暂停后Play效果一样)</span></span><br><span class="line">audioSource.UnPause();</span><br><span class="line"><span class="comment">// 延迟播放 不常用</span></span><br><span class="line">audioSource.PlayDelayed(<span class="number">5</span>); <span class="comment">// 5秒后播放</span></span><br></pre></td></tr></table></figure>

<h3 id="检测音效是否在播放中"><a href="#检测音效是否在播放中" class="headerlink" title="检测音效是否在播放中"></a>检测音效是否在播放中</h3><p>没有音效开始/结束播放的委托, 只能Update中不停检测</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否播放中</span></span><br><span class="line">audioSource.isPlaying;</span><br></pre></td></tr></table></figure>

<h3 id="动态控制音效播放"><a href="#动态控制音效播放" class="headerlink" title="动态控制音效播放"></a>动态控制音效播放</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 直接在需要播放音效的对象上挂载脚本控制播放</span></span><br><span class="line"><span class="comment">// 2. 用一个AudioSource控制播放不同的音效</span></span><br><span class="line">aus = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">aus.clip = clip;</span><br><span class="line">aus.Play();</span><br></pre></td></tr></table></figure>

<p>一个GameObject可以挂载多个AudioSource脚本, 但是挂载多个的时候需要管理起来</p>
<h2 id="麦克风输入"><a href="#麦克风输入" class="headerlink" title="麦克风输入"></a>麦克风输入</h2><p>不太常用</p>
<h3 id="获取设备麦克风信息"><a href="#获取设备麦克风信息" class="headerlink" title="获取设备麦克风信息"></a>获取设备麦克风信息</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>[] strs = Microphone.devices; <span class="comment">// 所有麦克风设备</span></span><br></pre></td></tr></table></figure>

<h3 id="开始录制"><a href="#开始录制" class="headerlink" title="开始录制"></a>开始录制</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1: 设备名, 传null则使用默认设备</span></span><br><span class="line"><span class="comment">// 参数2: 超过录制长度后 是否重头录制</span></span><br><span class="line"><span class="comment">// 参数3: 录制时长</span></span><br><span class="line"><span class="comment">// 参数4: 采样率</span></span><br><span class="line">clip = Microphone.Start(<span class="literal">null</span>, <span class="literal">false</span>, <span class="number">10</span>, <span class="number">44100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="结束录制"><a href="#结束录制" class="headerlink" title="结束录制"></a>结束录制</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Microphone.End(<span class="literal">null</span>);</span><br><span class="line">audioSource.clip = clip;</span><br><span class="line">audioSource.Play(); <span class="comment">// 播放</span></span><br></pre></td></tr></table></figure>

<h3 id="获取音频数据用于存储或者传输"><a href="#获取音频数据用于存储或者传输" class="headerlink" title="获取音频数据用于存储或者传输"></a>获取音频数据用于存储或者传输</h3><p>主要是从AudioClip中获取数据, 或者设置数据到AudioClip中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规则: 数据长度是用 声道数 * 剪辑长度</span></span><br><span class="line"><span class="keyword">float</span>[] data = <span class="keyword">new</span> <span class="keyword">float</span>[clip.channels * clip.samples];</span><br><span class="line">clip.GetData(f, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 需要传输时, 将float数组转化为byte字节数据流传输</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity物理系统--碰撞器</title>
    <url>/unity/unity-physical-system-collider/</url>
    <content><![CDATA[<p>碰撞产生必要条件: 两个物体都有碰撞器(Collider), 至少一个物体有刚体(Rigidbody)</p>
<p>碰撞器表示物体的体积(形状), 刚体利用体积进行碰撞计算, 模拟真实的碰撞效果, 产生力的作用</p>
<h2 id="3D碰撞器种类"><a href="#3D碰撞器种类" class="headerlink" title="3D碰撞器种类"></a>3D碰撞器种类</h2><h3 id="性能高-较为常用"><a href="#性能高-较为常用" class="headerlink" title="性能高 较为常用"></a>性能高 较为常用</h3><ul>
<li>BoxCollider 盒状</li>
<li>SphereCollider 球状</li>
<li>CapsuleCollider 胶囊</li>
</ul>
<h3 id="准确性高-性能低-使用少"><a href="#准确性高-性能低-使用少" class="headerlink" title="准确性高 性能低 使用少"></a>准确性高 性能低 使用少</h3><ul>
<li>网格</li>
<li>轮胎</li>
<li>地形</li>
</ul>
<h2 id="共同参数"><a href="#共同参数" class="headerlink" title="共同参数"></a>共同参数</h2><h3 id="Is-Trigger-是否为触发器"><a href="#Is-Trigger-是否为触发器" class="headerlink" title="Is Trigger 是否为触发器"></a>Is Trigger 是否为触发器</h3><p>如果启用此属性, 则该碰撞体将用于触发事件, 并被物理引擎忽略</p>
<p>主要用于进行没有物理效果的碰撞检测</p>
<h3 id="Material-物理材质"><a href="#Material-物理材质" class="headerlink" title="Material 物理材质"></a>Material 物理材质</h3><p>可以确定碰撞体和其它对象碰撞时的交互(表现)方式</p>
<p>例如: 橡胶球, 冰面</p>
<h3 id="Center"><a href="#Center" class="headerlink" title="Center"></a>Center</h3><p>碰撞体体积的位置偏移</p>
<h2 id="常用碰撞器"><a href="#常用碰撞器" class="headerlink" title="常用碰撞器"></a>常用碰撞器</h2><h3 id="BoxCollider-盒状碰撞器"><a href="#BoxCollider-盒状碰撞器" class="headerlink" title="BoxCollider 盒状碰撞器"></a>BoxCollider 盒状碰撞器</h3><ul>
<li>Size 碰撞体在xyz方向上的大小</li>
</ul>
<h3 id="SphereCollider-球状碰撞器"><a href="#SphereCollider-球状碰撞器" class="headerlink" title="SphereCollider 球状碰撞器"></a>SphereCollider 球状碰撞器</h3><ul>
<li>Radius 球状碰撞体的半径大小</li>
</ul>
<h3 id="CapsuleCollider-胶囊碰撞体"><a href="#CapsuleCollider-胶囊碰撞体" class="headerlink" title="CapsuleCollider 胶囊碰撞体"></a>CapsuleCollider 胶囊碰撞体</h3><ul>
<li>Radius 胶囊提半径</li>
<li>Height 胶囊提高度</li>
<li>Direction 胶囊提轴向方向</li>
</ul>
<h2 id="异性物体使用多种碰撞器组合"><a href="#异性物体使用多种碰撞器组合" class="headerlink" title="异性物体使用多种碰撞器组合"></a>异性物体使用多种碰撞器组合</h2><p><strong>刚体对象的子对象碰撞器参与碰撞检测</strong></p>
<h2 id="不常用碰撞器"><a href="#不常用碰撞器" class="headerlink" title="不常用碰撞器"></a>不常用碰撞器</h2><ul>
<li>MeshCollider 网格碰撞器 (性能消耗高)<ul>
<li>Convex <strong>如果带有MeshCollider的物体需要使用刚体, 那么必须勾选Convex</strong> 启用该选项, 该MeshCollider将与其它MeshCollider发生碰撞, Convex Mesh Collider最多255个三角形</li>
<li>Cooking Options 启用或禁用影响物理引擎对网格处理方式的网格烹制选项 (不常用)<ul>
<li>None 禁用所有Cooking Options</li>
<li>Everything 启用所有Cooking Options</li>
<li>Cook for Faster Simulation 使物理引擎烹制网格以加快模拟速度, 启用该设置后, 会运行一些额外步骤, 以保证生成的网格在运行时的性能最佳, 但是它会影响物理物理查询和接触生成的性能; 禁用此设置后, 物理引擎会使用更快的烹制速度, 并尽可能快速生成结果. 因此, 烹制的MeshCollider可能不是最佳的</li>
<li>Enable Mesh Cleaning 使用物理引擎清理网格, 启用此设置后, 烹制过程会常识消除网格的退化三角形以及其它的几何瑕疵, 此过程生成的网格更适合在碰撞检测中使用, 往往可生成更准确的击中点</li>
<li>Weld Colocated Vertices 使物理引擎在网格中删除相等的顶点, 启用此设置后, 物理引擎将合并具有相同位置的顶点, 这对于运动时发生的碰撞反馈十分重要</li>
</ul>
</li>
<li>Mesh 设置碰撞器的网格</li>
</ul>
</li>
<li>WheelCollider 环形碰撞器 (一般只用于赛车)<ul>
<li>添加WheelCollider看不到绿色提示</li>
<li>创建一个空物体Car</li>
<li>在其中创建车身, 轮胎, 对轮胎添加WheelCollider</li>
<li>给根物体添加刚体, 轮胎的碰撞器就会显示出来了</li>
<li>‘车子’拖到空中, 会被直接弹飞, 是因为质量太小, 刚体质量改成1500(kg)即可</li>
<li>创建车子简单点就是车身加4个轮胎碰撞器</li>
</ul>
</li>
<li>TerrainCollider 地形碰撞器 (性能消耗大, Unity自带地形本来就性能不好, 一般很少使用)<ul>
<li>Terrain Data 地形数据</li>
<li>Enable Tree Collider 选中时, 启用树的碰撞</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity物理系统--碰撞检测函数</title>
    <url>/unity/unity-physical-system-collision-function/</url>
    <content><![CDATA[<p>回顾:</p>
<ol>
<li>产生碰撞条件 - 至少1个刚体, 和2个碰撞器</li>
<li>两个物体碰撞时的不同效果 - 物理材质, 摩擦力和反弹力</li>
<li>触发器作用 - 两个物体碰撞没有物理效果, 只触发对应的触发器函数</li>
</ol>
<p>碰撞和触发函数属于特殊的生命周期函数, 也是通过反射调用, 触发响应频率和物理帧息息相关</p>
<h2 id="物理碰撞检测响应函数"><a href="#物理碰撞检测响应函数" class="headerlink" title="物理碰撞检测响应函数"></a>物理碰撞检测响应函数</h2><p>OnCollisionxxx都是产生物理效果的碰撞</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 碰撞刚开始接触时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 碰撞结束分离时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 当碰撞物体持续接触时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>参数Collision包含了碰到自己的对象的相关信息:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 碰撞对象的碰撞器</span></span><br><span class="line">collision.collider;</span><br><span class="line"><span class="comment">// 2. 碰撞对象的依附对象</span></span><br><span class="line">collision.gameObject;</span><br><span class="line"><span class="comment">// 3. 碰撞对象的依附对象的位置信息</span></span><br><span class="line">collision.transform;</span><br><span class="line">collision.transform.GetComponent&lt;T&gt;(); <span class="comment">// 获取碰撞对象的脚本</span></span><br><span class="line"><span class="comment">// 4. 碰撞位置 碰撞点</span></span><br><span class="line">collision.contactCount; <span class="comment">// 接触点个数</span></span><br><span class="line">ContactPoint[] points = collision.contacts; <span class="comment">// 接触点</span></span><br></pre></td></tr></table></figure>

<h2 id="触发器响应函数"><a href="#触发器响应函数" class="headerlink" title="触发器响应函数"></a>触发器响应函数</h2><p>勾选Is Trigger后的触发函数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个物体刚接触时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 当接触状态结束时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 当两个物体一直接触时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="要明确什么时候会响应函数"><a href="#要明确什么时候会响应函数" class="headerlink" title="要明确什么时候会响应函数"></a>要明确什么时候会响应函数</h2><ol>
<li>只要挂载的对象能和别的物体产生碰撞或者触发, 那么对应的这些函数就能够被触发</li>
<li>一般不是几个函数都需要, 只根据需要写就行</li>
<li>如果是一个组合物体(父对象具有刚体, 但是碰撞器都在子物体上), 在子物体上挂载脚本检测碰撞是不行的, 必须挂载到这个物体的父对象上才能响应</li>
</ol>
<h2 id="碰撞和触发器函数都可以写成虚函数在子类中实现"><a href="#碰撞和触发器函数都可以写成虚函数在子类中实现" class="headerlink" title="碰撞和触发器函数都可以写成虚函数在子类中实现"></a>碰撞和触发器函数都可以写成虚函数在子类中实现</h2><p>一般将碰撞/触发函数写成private或者protected</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity物理系统--物理材质</title>
    <url>/unity/unity-physical-system-physic-material/</url>
    <content><![CDATA[<h2 id="创建与应用"><a href="#创建与应用" class="headerlink" title="创建与应用"></a>创建与应用</h2><p>右键创建-&gt;物理材质(Physic Material)</p>
<p>在Collider的材质选项中, 选择传概念的物理材质</p>
<h2 id="物理材质参数"><a href="#物理材质参数" class="headerlink" title="物理材质参数"></a>物理材质参数</h2><h3 id="Dynamic-Friction-在移动时的摩擦力"><a href="#Dynamic-Friction-在移动时的摩擦力" class="headerlink" title="Dynamic Friction 在移动时的摩擦力"></a>Dynamic Friction 在移动时的摩擦力</h3><p>通常为0到1之间的值, 值为0就会像冰一样, 值为1将使运动的对象迅速静止 (除非用很大的力推动对象)</p>
<h3 id="Static-Friction-静止时的摩擦力"><a href="#Static-Friction-静止时的摩擦力" class="headerlink" title="Static Friction 静止时的摩擦力"></a>Static Friction 静止时的摩擦力</h3><p>通常为0到1之间, 值为0像冰面, 值为1将导致很难让对象移动</p>
<h3 id="Bounciness-弹性"><a href="#Bounciness-弹性" class="headerlink" title="Bounciness 弹性"></a>Bounciness 弹性</h3><p>值为0将不会反弹, 值为1将在反弹时不产生任何能量损失</p>
<h3 id="Friction-Combine-两个碰撞对象的摩擦力组合方式"><a href="#Friction-Combine-两个碰撞对象的摩擦力组合方式" class="headerlink" title="Friction Combine 两个碰撞对象的摩擦力组合方式"></a>Friction Combine 两个碰撞对象的摩擦力组合方式</h3><p>碰撞的两个物体, 可能拥有两个不同的物理材质, 以下就是计算不同物理材质之间实际摩擦力的方式</p>
<ul>
<li>Average 两个摩擦值求平均值 (默认值)</li>
<li>Minimum 使用两个值中的最小值</li>
<li>Maximum 使用两个值中的最大值</li>
<li>Multiply 两个摩擦值相乘</li>
</ul>
<h3 id="Bounce-Combine-两个碰撞对象的弹性组合方式"><a href="#Bounce-Combine-两个碰撞对象的弹性组合方式" class="headerlink" title="Bounce Combine 两个碰撞对象的弹性组合方式"></a>Bounce Combine 两个碰撞对象的弹性组合方式</h3><p>模式与Friction Combine模式相同</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity物理系统--对刚体加力</title>
    <url>/unity/unity-physical-system-rigidbody-add-force/</url>
    <content><![CDATA[<h2 id="刚体自带的添加力的方法"><a href="#刚体自带的添加力的方法" class="headerlink" title="刚体自带的添加力的方法"></a>刚体自带的添加力的方法</h2><p>给刚体加力的目标就是, 让刚体有一个加速度, 朝某个方向改变速度</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">rig = GetComponent&lt;Rigidbody&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="添加力"><a href="#添加力" class="headerlink" title="添加力"></a>添加力</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相对于世界坐标</span></span><br><span class="line">rig.AddForce(Vector3.forward * <span class="number">10</span>); <span class="comment">// 加力一帧时间</span></span><br><span class="line"><span class="comment">// 相对于本地坐标</span></span><br><span class="line">rig.AddRelativeForce(Vector3.forward * <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 与上面的等价</span></span><br><span class="line">rig.AddForce(transform.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="添加扭矩力"><a href="#添加扭矩力" class="headerlink" title="添加扭矩力"></a>添加扭矩力</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相对于世界坐标系</span></span><br><span class="line">rig.AddTorque(Vector3.up * <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 相对于本地坐标系</span></span><br><span class="line">rig.AddRelativeTorque(Vector3.up * <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="直接改变速度-手动给一个加速度"><a href="#直接改变速度-手动给一个加速度" class="headerlink" title="直接改变速度 (手动给一个加速度)"></a>直接改变速度 (手动给一个加速度)</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是相对于世界坐标系</span></span><br><span class="line">rig.velocity += Vector3.forward * <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>一般不会随意更改速度, 否则可能出现不符合物理规律的运动, 看起来比较奇怪</p>
<p>一般不手动更改速度, <strong>除非你知道自己在干什么</strong>(符合物理规律的改变)</p>
<h3 id="模拟爆炸效果"><a href="#模拟爆炸效果" class="headerlink" title="模拟爆炸效果"></a>模拟爆炸效果</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 爆炸力大小(会随距离改变), 爆炸中心, 爆炸范围</span></span><br><span class="line">rig.AddExplosionForce(<span class="number">10</span>, Vector3.zero, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这个’爆炸力’只对调用者生效, 其它未调用该方法的刚体不受影响</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>还有<code>AddForceAtPosition</code>在某个点加力, 一般用的较少, 可以进入类中查看</p>
<h2 id="力的几种模式"><a href="#力的几种模式" class="headerlink" title="力的几种模式"></a>力的几种模式</h2><p><code>AddForce</code>方法可以接受一个力的模式参数</p>
<p>主要作用就是计算方式不同, 由于4中计算方式不同, 最终的效果也会不同</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">rig.AddForce(Vector3.forward * <span class="number">10</span>, ForceMode.Acceleration);</span><br></pre></td></tr></table></figure>

<h3 id="动量定理"><a href="#动量定理" class="headerlink" title="动量定理"></a>动量定理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ft &#x3D; mv</span><br><span class="line">v &#x3D; Ft&#x2F;m</span><br></pre></td></tr></table></figure>

<h3 id="Acceleration-增加持续加速度-忽略质量"><a href="#Acceleration-增加持续加速度-忽略质量" class="headerlink" title="Acceleration 增加持续加速度, 忽略质量"></a>Acceleration 增加持续加速度, 忽略质量</h3><p>v = Ft/m (m当作1)</p>
<p>F: (0, 0, 10) 施加的力</p>
<p>t: 施加力的时间 (一个物理帧: 0.02s)</p>
<p>m: 在该模式下, 忽略重量, <strong>直接当作1计算</strong></p>
<p>v: 速度的改变量</p>
<h3 id="Force-正常模式-速度改变和质量有关"><a href="#Force-正常模式-速度改变和质量有关" class="headerlink" title="Force 正常模式, 速度改变和质量有关"></a>Force 正常模式, 速度改变和质量有关</h3><p>v = Ft/m (m和t都按正常计算)</p>
<h3 id="Impulse-给物体添加一个瞬间的力-与物体质量有关-忽略时间-当作1"><a href="#Impulse-给物体添加一个瞬间的力-与物体质量有关-忽略时间-当作1" class="headerlink" title="Impulse 给物体添加一个瞬间的力, 与物体质量有关, 忽略时间(当作1)"></a>Impulse 给物体添加一个瞬间的力, 与物体质量有关, 忽略时间(当作1)</h3><p>v = Ft/m (t当作1)</p>
<h3 id="VelocityChange-忽略时间和质量-都当作1"><a href="#VelocityChange-忽略时间和质量-都当作1" class="headerlink" title="VelocityChange 忽略时间和质量(都当作1)"></a>VelocityChange 忽略时间和质量(都当作1)</h3><p>v = Ft/m (t和m都当作1, 力就是速度的改变量)</p>
<h2 id="力场脚本"><a href="#力场脚本" class="headerlink" title="力场脚本"></a>力场脚本</h2><p>自带脚本中有个Constant Force, 可以根据参数给物体持续的力</p>
<p>一般用于制作简单的物体效果</p>
<h2 id="刚体休眠"><a href="#刚体休眠" class="headerlink" title="刚体休眠"></a>刚体休眠</h2><p>Unity中为了节约性能, 一定条件下会让刚体休眠</p>
<p>刚体cube掉落在平面上, 之后旋转该平面, 让物体悬空, 但物体还是停在空中; 平面移动之后, cube才会继续检测</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否为休眠状态, 并激活</span></span><br><span class="line"><span class="keyword">if</span> (rig.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line">    rig.WakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC框架--PureMVC</title>
    <url>/csharp/design-patterns/pure-mvc/</url>
    <content><![CDATA[<p>MVC是一种很好的设计框架, 可以解耦数据(Model)/视图(View)和业务逻辑(Controller)之间的耦合</p>
<p>PureMVC是一个通用的MVC框架, 运用多种设计模式, 将数据/视图和业务解耦, 这里先看看官方给的图</p>
<img data-src="/csharp/design-patterns/pure-mvc/puremvc.png" class="">

<p>不要被图吓到, 其实这个框架结构还是很清晰的</p>
<p>官方提供了<a href="http://puremvc.org/docs/PureMVC_IIBP_Chinese.pdf">PureMVC的中文PDF文档</a></p>
<p>下面大致了解以下该框架</p>
<a id="more"></a>

<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>PureMVC中的Model/View/Controller都是单例类</p>
<ul>
<li>Model单例统一管理所有的Proxy<ul>
<li>Proxy负责操作数据模型(DataObjects), 或者与远程服务器通信存取数据 (代理模式, 保证Model层的可移植性)</li>
<li>Proxy可以</li>
</ul>
</li>
<li>View单例统一管理所有的Mediator<ul>
<li>Mediator对象操作具体的视图组件(ViewConponent), 包括: 添加事件监听器, 发送或者接受Notification, 直接改变视图组件的状态 (中介者模式, 将视图和控制它的逻辑分离开)</li>
</ul>
</li>
<li>Controller单例统一管理所有的Command映射(命令)<ul>
<li>Command类是无状态的, 只在需要时被创建 (命令模式)</li>
</ul>
</li>
</ul>
<p>PureMVC中的Facade是一个单例类, 它统一管理上述的Model/View/Controller的单实例, 对外提供管理Proxy/Mediator/Command和发送通知的接口, 避免用户直接操作Model/View/Controller, 减少耦合 (设计模式: 面板模式)</p>
<h2 id="MVC交互"><a href="#MVC交互" class="headerlink" title="MVC交互"></a>MVC交互</h2><img data-src="/csharp/design-patterns/pure-mvc/mvc.gif" class="">

<p>Facade使用Controller实例保存了Command与Notification之间的映射, 当Notification(通知)被发出时, 对应的Command(命令)就会自动由Controller执行</p>
<h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><p>Notification可以触发Command的执行, Command也可以发送Notification</p>
<ul>
<li>获取Proxy对象并与之交互</li>
<li>发送Notification</li>
<li>或者执行其它的Command</li>
</ul>
<p>Command用于业务逻辑操作, 比如应用程序的’启动’和’关闭’</p>
<h3 id="Meditor"><a href="#Meditor" class="headerlink" title="Meditor"></a>Meditor</h3><p>Mediator可以发送, 监听, 接受Notification</p>
<ul>
<li>Meditor的listNotifications返回所有关联视图关心的事件列表</li>
<li>当View注册Meditor时, 会获取它的关注事件列表, 并添加监听</li>
<li>之后当Notification(通知)被发出时, 所有关心该通知的Meditor都会调用handleNotification方法处理通知</li>
<li>当View移除Meditor时, 会自动取消监听</li>
</ul>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy发送Notification, 但不接收</p>
<p>很多场合下Proxy需要发送Notification(通知), 比如: Proxy从远程服务器收到数据; 或当Proxy的数据被更新时</p>
<p>View和Controller必须监听Proxy发送的Notification, 做出UI更新或者其它操作</p>
<p>不过对View层和Controller层的改变不应该影响到Model层</p>
<h3 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h3><p>Facade是Model, View和Controller三者的’经纪人’, 实际的应用都有一个Facade子类, 这个Facade需要建立Command与Notification名之间的映射, 并执行一个Command注册需要的Model与View</p>
<p>在Unity中使用时, View的存在与场景息息相关, 可以在场景加载成功的Notification对应Command中注册该场景中的UI; 在场景退出的Notification对应Command中移除对应UI</p>
<p>应用程序应该编写自己的Facade子类, 比如’ApplicationFacade’, 然后提供一个StartUp方法, 完成整个框架流程的启动(比如: 注册一个StartUpCommand, 发送一个StartUp的Notification)</p>
<h3 id="Command-1"><a href="#Command-1" class="headerlink" title="Command"></a>Command</h3><p>Controller会注册监听每一个Notification, 当通知到达时, Controller会实例化一个该Notification对应的Command类对象, 然后将Notification作为参数传递给execute方法</p>
<p>Command对象无状态, 只在需要时动态创建, 并在执行之后就被删除, 所以不应该在生命周期长的对象里引用Command对象</p>
<h2 id="代码写在哪里"><a href="#代码写在哪里" class="headerlink" title="代码写在哪里"></a>代码写在哪里</h2><p>刚开始使用PureMVC时总有疑惑, 我的代码该写在哪里? Command, 还是Proxy, 还是Mediator?</p>
<h3 id="Command-2"><a href="#Command-2" class="headerlink" title="Command"></a>Command</h3><p>Command管理应用程序的业务逻辑(Business Logic), 与域逻辑(Domain Logic)相区别, 业务逻辑要协调Model与View的状态</p>
<p>Command可能用于实现一些复杂的必须按照一定顺序的系统行为, 上一步动作的结果可能会流入下一个动作</p>
<ul>
<li>注册/删除 Mediator, Proxy 和 Command, 或者检查它们是否已经注册</li>
<li>发送Notification通知Command或者Mediator做出响应</li>
<li>获取Proxy和Mediator对象并直接使用它们的接口</li>
</ul>
<p>自定义Command类可以继承SimpleCommand(提供一个Execute方法), 或者继承MacroCommand类(表示一系列按顺序的Command组合)</p>
<p>注意: Unity中的Mediator&amp;View是和场景相关的, 可能退出当前场景后, 当前所有注册的Mediator都无效了, 进入新场景需要注册新的Mediator, 这里可以斟酌处理(比如在退出场景Command中删除不需要的Mediator, 进入场景Command中注册场景需要的Mediator; 或者在对应UI显示时/Awake时注册Mediator, 隐藏/Destroy时删除Mediator)</p>
<h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a>Proxy</h3><p>数据对象(Data Object), 仅是一个简单对象, 就表示该数据有哪些变量(Field)就行了, 不需要提供额外接口</p>
<p>由Proxy集中程序的域逻辑, 对位提供操作数据对象的接口, <strong>Proxy封装所有对数据模型的操作, 不管数据是客户端还是服务端的, 对程序其它部分来说就是数据的访问是同步还是异步</strong></p>
<p><strong>Proxy发送Notification, 但不接受Notification</strong></p>
<ul>
<li>获取, 创建, 初始化数据对象</li>
<li>操作修改数据 (比如升级后的属性更新)</li>
</ul>
<h3 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator"></a>Mediator</h3><p>Mediator需要重写listNotifications和handleNotification来关注事件和处理事件</p>
<ul>
<li>接收Notification并做处理</li>
<li>处理UI交互事件 (按钮点击, 文本改变, 滑动滑条)</li>
<li>发送Notification (用户操作, 数据改变)</li>
</ul>
<p>注意: <strong>Command 与 Mediator 和 Proxy 交互, 应避免 Mediator 与 Proxy 直接交互</strong></p>
<p>当数据发生改变时, 发出Notification, 对应Mediator受到Notification后根据参数来更新UI, 不要直接取Proxy</p>
<h3 id="Facade-1"><a href="#Facade-1" class="headerlink" title="Facade"></a>Facade</h3><p>一般在自己继承的AppFacade中提供一个StartUp函数, 提供PureMVC框架的全局启动点</p>
<ol>
<li>在StartUp函数中注册一个StartUpCommand命令, 并发送一个StartUp的Notification, 让StartUpCommand得到执行</li>
<li>在StartUpCommand中注册Proxy, 注册其它Command (场景切换等), 在Unity中这些操作可以放在一个Init场景中单独执行, 执行完成后再发送一个跳转场景的Notification, Unity中的View和场景有关, 所以不在这里注册</li>
<li>Facade提供了注册/删除/检测 所有Proxy, Mediator和Command的接口, 也提供了发送Notification的接口, 一般是在Command中使用Facade获取Proxy和Mediator, 而不要让Proxy和Mediator产生直接关联, 降低耦合</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Command 用于完成业务逻辑, 可以直接依赖Proxy和Mediator</p>
<p>Proxy 封装所有对数据的操作, 获取/修改数据, 只发通知不接收通知</p>
<p>Mediator 封装所有对视图的操作, 处理用户交互/根据数据更新数据, 接收通知也发送通知</p>
<p>Facade 全局单例, 统一管理(注册/删除/检测)Command, Proxy和Mediator, 可以发送通知</p>
<p>看的再多不如拿来用一用, 写一写, 再结合文档和源码看看就会理解了</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPatterns</tag>
        <tag>Framework</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity知识点--隐藏/锁定鼠标和更改鼠标图标</title>
    <url>/unity/unity-hide-and-lock-mouse-and-change-mouse-icon/</url>
    <content><![CDATA[<h2 id="隐藏鼠标"><a href="#隐藏鼠标" class="headerlink" title="隐藏鼠标"></a>隐藏鼠标</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Cursor.visible = <span class="literal">true</span>; <span class="comment">// 隐藏鼠标</span></span><br></pre></td></tr></table></figure>

<h2 id="锁定鼠标"><a href="#锁定鼠标" class="headerlink" title="锁定鼠标"></a>锁定鼠标</h2><p>编辑模式下, 鼠标锁定后按下ESC可以退出锁定模式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// None 无锁定</span></span><br><span class="line"><span class="comment">// Locked 锁定在窗口中心点 (不仅会被锁定, 还会隐藏)</span></span><br><span class="line"><span class="comment">// Confined 锁定在窗口范围内</span></span><br><span class="line">Cursor.lockState = CursorLockMode.Locked;</span><br></pre></td></tr></table></figure>

<h2 id="设置鼠标图标"><a href="#设置鼠标图标" class="headerlink" title="设置鼠标图标"></a>设置鼠标图标</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1 Texture2D: 光标图片</span></span><br><span class="line"><span class="comment">// 参数2 Vector2: 偏移位置, 相对于图片左上角</span></span><br><span class="line"><span class="comment">// 参数3 CursorMode: 平台支持的光标模式 (硬件或软件), 一般自动</span></span><br><span class="line">Cursor.SetCursor(tex, Vector2.zero, CursorMode.Auto);</span><br></pre></td></tr></table></figure>

<p>如果发现鼠标图标变形了, 可能因为图片的宽高不一样导致</p>
<p>如果导入的图片不是透明的, 需要在资源属性窗口的Texture Type选项中选择为Cursor; 最好作为光标使用的图片资源都选择类型为Cursor</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的随机数和自带委托</title>
    <url>/unity/unity-random-and-delegate/</url>
    <content><![CDATA[<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">UnityEngine.Random; <span class="comment">// 区别于System.Random</span></span><br><span class="line"><span class="keyword">int</span> randNum = Random.Range(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// [0, 100) 也就是生成结果不包括100</span></span><br><span class="line"><span class="keyword">float</span> randf = Random.Range(<span class="number">1.1f</span>, <span class="number">99.9f</span>); <span class="comment">// float 左右都包含</span></span><br></pre></td></tr></table></figure>

<p>一般Unity中就使用UnityEngine.Random类, 如果非要使用C#中的Random类, 可以用命名空间限定</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Random r = <span class="keyword">new</span> System.Random();</span><br><span class="line">r.Next(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>C#中提供的委托</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Action act = () =&gt; <span class="comment">// 无参无返回委托类型</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line">System.Action&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; ac2 = (i, f) =&gt; &#123;&#125;;</span><br><span class="line">System.Func&lt;<span class="keyword">int</span>&gt; fun1 = () =&gt; &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line">System.Func&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; fun2 = (i) =&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>Unity自带委托</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line">UnityAction uac = () =&gt; &#123;&#125;;</span><br><span class="line">UnityAction&lt;<span class="keyword">string</span>&gt; uac1 = (s) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果不需要返回值, 可以用UnityAction, 如果需要返回值, 使用System.Func</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity知识点--场景切换和游戏退出</title>
    <url>/unity/unity-scene-change-and-application-exit/</url>
    <content><![CDATA[<h2 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h2><p>注意: <strong>需要使用的场景Scene必须先在BuildSettings中添加到场景列表, 进入游戏的第一个场景必须是列表中的第1个(序号0)</strong></p>
<p>如果Scene未添加到BuildSettings列表中, 切换时会直接报错</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement; <span class="comment">// SceneManager在该命名空间</span></span><br><span class="line"><span class="comment">// 需要切换的场景必须添加到BuildSettings场景列表中</span></span><br><span class="line">SceneManager.LoadScene(<span class="string">&quot;Scene2&quot;</span>); <span class="comment">// 传入场景名, 还有许多其他重载</span></span><br></pre></td></tr></table></figure>

<p>SceneManager中还提供了获取场景数量, 当前场景, 异步切换场景等, 可以进入类中自行查看</p>
<p>老版本中可能使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Application.LoadLevel(<span class="string">&quot;Scene2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个方法已经过时, 但是看到了应该了解</p>
<h2 id="游戏退出"><a href="#游戏退出" class="headerlink" title="游戏退出"></a>游戏退出</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行这句代码退出游戏, 但是UnityEditor编辑模式下不会起作用</span></span><br><span class="line">Application.Quit();</span><br></pre></td></tr></table></figure>

<p>可以使用平台相关的宏来让游戏正常退出</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    UnityEditor.EditorApplication.isPlaying = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    Application.Quit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编辑器暂停</span></span><br><span class="line">UnityEditor.EditorApplication.isPaused = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中SceneManager场景切换和相关事件</title>
    <url>/unity/unity-scenemanager-sceneload-event/</url>
    <content><![CDATA[<h2 id="SceneManager-LoadScene是半异步"><a href="#SceneManager-LoadScene是半异步" class="headerlink" title="SceneManager.LoadScene是半异步"></a>SceneManager.LoadScene是半异步</h2><p>学习Unity时发现一个问题, 看下面一段代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> loadScene = notification.Body.ToString();</span><br><span class="line">Debug.Log(<span class="string">$&quot;调用LoadScene前, 当前活动场景: <span class="subst">&#123;SceneManager.GetActiveScene().name&#125;</span>&quot;</span>);</span><br><span class="line">SceneManager.LoadScene(loadScene);</span><br><span class="line">Debug.Log(<span class="string">$&quot;调用LoadScene后, 当前活动场景: <span class="subst">&#123;SceneManager.GetActiveScene().name&#125;</span>&quot;</span>);</span><br><span class="line">SendNotification(Consts.N_SceneLoaded, <span class="keyword">new</span> SceneLoadedArg()</span><br><span class="line">&#123;</span><br><span class="line">    LastScene = curScene,</span><br><span class="line">    LoadScene = loadScene</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>原本以为LoadScene是调用时同步执行, 结果打印结果如下</p>
<img data-src="/unity/unity-scenemanager-sceneload-event/result.png" class="">

<a id="more"></a>

<p>查阅文档如下:</p>
<img data-src="/unity/unity-scenemanager-sceneload-event/loadscene.png" class="">

<p><a href="https://docs.unity.cn/cn/2020.3/ScriptReference/SceneManagement.SceneManager.LoadScene.html">文档链接</a></p>
<p>文档给出了两个结论</p>
<ol>
<li><strong>SceneManager.LoadScene方法是下一帧执行, 是半异步, 不是完全的同步执行</strong></li>
<li><strong>最好使用异步加载LoadSceneAsync</strong></li>
</ol>
<h2 id="判断场景的切换"><a href="#判断场景的切换" class="headerlink" title="判断场景的切换"></a>判断场景的切换</h2><ol>
<li>使用异步加载, 在协程中判断异步操作的IsDone</li>
<li>订阅SceneManager中提供的场景切换事件</li>
</ol>
<h3 id="SceneManager场景切换事件"><a href="#SceneManager场景切换事件" class="headerlink" title="SceneManager场景切换事件"></a>SceneManager场景切换事件</h3><p>三个事件: <code>activeSceneChanged</code> <code>sceneLoaded</code> <code>sceneUnloaded</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DontDestroyOnLoad(gameObject);</span><br><span class="line">SceneManager.activeSceneChanged += (a, b) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">$&quot;活动场景切换了: 从 <span class="subst">&#123;a.name&#125;</span> 到 <span class="subst">&#123;b.name&#125;</span>&quot;</span>);</span><br><span class="line">    print(<span class="string">$&quot;当前活动场景: <span class="subst">&#123;SceneManager.GetActiveScene().name&#125;</span>&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">SceneManager.sceneLoaded += (s, m) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">$&quot;场景<span class="subst">&#123;s.name&#125;</span>被加载了&quot;</span>);</span><br><span class="line">    print(<span class="string">$&quot;当前活动场景: <span class="subst">&#123;SceneManager.GetActiveScene().name&#125;</span>&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">SceneManager.sceneUnloaded += (s) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">$&quot;场景<span class="subst">&#123;s.name&#125;</span>被卸载了&quot;</span>);</span><br><span class="line">    print(<span class="string">$&quot;当前活动场景: <span class="subst">&#123;SceneManager.GetActiveScene().name&#125;</span>&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<img data-src="/unity/unity-scenemanager-sceneload-event/eventresult.png" class="">

<p>对于<code>activeSceneChanged</code>事件, 看到打印的第一个参数的场景名称为空, 调试时发现第一个Scene参数的buildIndex是-1, 注意以下就好</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo建立的个人小站</title>
    <url>/career/build-my-site-with-hexo/</url>
    <content><![CDATA[<p>折腾半天, 用Hexo + NexT建成个人小站, 真是相当美观呀, 发布到Gitee或者GitHub Page, 可以写写博客, 记点日志, 美滋滋~</p>
<p>简单记录一下使用过程</p>
<p>详细的安装步骤以及配置, 可以查阅<a href="https://hexo.io/zh-cn/docs">Hexo官方中文文档</a></p>
<a id="more"></a>

<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><blockquote>
<p><a href="https://hexo.io/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<img data-src="/career/build-my-site-with-hexo/hexo.png" class="" title="Hexo官网图">

<h2 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h2><p>Hexo依赖<a href="https://nodejs.org/">Node.js</a>, Node.js的安装可以搜索关键字<code>Node.js 安装</code></p>
<p>然后使用npm安装Hexo, 在命令行输入以下命令完成Hexo的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g nexo-cli</span><br></pre></td></tr></table></figure>

<p>Hexo安装完成后, 使用以下命令创建站点, <code>folder</code>是自定义目录名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>之后可以在<code>folder</code>目录下的<code>_config.yml</code>文件中修改网站配置信息, 比如网站标题, 描述, 作者等</p>
<p>需要注意的是如果网站存放在子目录, 例如<code>http://yoursite.com/blog</code>, 需要将网站<code>url</code>修改为<code>http://yoursite.com/blog</code>并修改<code>root</code>为<code>/blog/</code></p>
<p>本地测试一下!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>命令行提示本地服务器启动, 默认地址为<code>http://localhost:4000/</code></p>
<p>在浏览器访问上面的地址, 不出意外会打开网站的Hello World页面, 简单炫酷的小站创建成功, 恭喜!</p>
<p>使用以下命令创建自己的文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>创建成功之后去<code>source/_posts</code>下编辑文章, 保存后刷新首页或者<code>hexo s</code>重新启动后刷新, 就能看到刚刚创建的文章了~</p>
<p>详细的配置说明可以查阅官方文档, 有很多配置项可以按需自行配置</p>
<h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><p>想要自定义网站样式? Hexo官方提供了非常多的主题, 快去挑一款喜欢的吧! <a href="https://hexo.io/themes/">https://hexo.io/themes</a></p>
<p>本站用的主题是<a href="https://theme-next.org/">NexT</a>, 喜欢的朋友路过不要错过</p>
<p>主题的自定义配置在官网一般有详细说明, 可以定制想要的效果, 这里不再赘述</p>
<h2 id="网站部署"><a href="#网站部署" class="headerlink" title="网站部署"></a>网站部署</h2><p>很多源码托管平台都会提供Pages服务, 允许你把自己生成好的网页放在它们的服务器上, 比如最著名的<a href="https://pages.github.com/">GitHub Pages</a>, 国内的Coding, Gitee都提供类似服务, 国外的<a href="https://firebase.google.cn/docs/hosting/">Firebase hosting</a> <a href="https://www.netlify.com/">Netlify</a>等</p>
<p>部署方法在对应网站都有详细说明</p>
<p>Hexo生成静态资源前最好清一下缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Hexo和一些主题会提供一些可选的第三方服务, 可以根据文档自由开启, 比如搜索, 访问量计数, 评论等功能</p>
<p>折腾完成后看着自己的小站还是挺开心的~</p>
]]></content>
      <categories>
        <category>career</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中不要使用null条件运算符和null合并运算符</title>
    <url>/unity/csharp-null-condition-operator-in-unity/</url>
    <content><![CDATA[<p>结论: Unity中应避免使用<code>?.</code>和<code>??</code>运算符, 以免出现不符合预期的结果, 或者导致报错</p>
<h2 id="C-中的null条件运算符和null合并运算符"><a href="#C-中的null条件运算符和null合并运算符" class="headerlink" title="C#中的null条件运算符和null合并运算符"></a>C#中的null条件运算符和null合并运算符</h2><p>C# 6.0 中提供了两个方便的语法糖, 一个是 null条件运算符<code>?.</code>, 一个是 null合并运算符<code>??</code></p>
<ul>
<li>null条件运算符, 如果对象不为null则执行后面的方法, 否则不执行(如果有返回值, 则返回null)</li>
<li>null合并运算符, 如果左边的对象不为null则返回左边对象, 否则返回右边的对象</li>
</ul>
<p><strong>注意: 无论是<code>?.</code>还是<code>??</code>判断对象是否为null都是底层直接判断的, 没有使用<code>==</code>运算符, 因此对于重载了<code>==</code>运算符的对象需要注意这两个运算符是否符合预期</strong></p>
<p>如果不在Unity环境下, 仅仅在C#中使用这两个语法糖的运算符是非常方便的</p>
<p>null条件运算符</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Object obj = GetObj(); <span class="comment">// 某返回可能为null的函数</span></span><br><span class="line"><span class="comment">// 一般的使用方法</span></span><br><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123; Console.WriteLine(obj.ToString()); &#125;</span><br><span class="line"><span class="comment">// null条件运算符</span></span><br><span class="line">Console.WriteLine(obj?.ToString());</span><br></pre></td></tr></table></figure>

<p>null合并运算符</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般用法</span></span><br><span class="line">System.Object result;</span><br><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123; result = obj; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; result = defaultObj; &#125;</span><br><span class="line"><span class="comment">// null合并运算符</span></span><br><span class="line">result = obj ?? defaultObj;</span><br></pre></td></tr></table></figure>

<h2 id="Unity中为什么不能使用"><a href="#Unity中为什么不能使用" class="headerlink" title="Unity中为什么不能使用"></a>Unity中为什么不能使用</h2><ul>
<li>Unity中所有对象都继承自<code>UnityEngine.Object</code>, 不同于<code>System.Object</code>, <strong>UnityEngine.Object重载了<code>==</code>运算符</strong>, 可以用于判别Unity对象是否有效</li>
<li>很多时候一个Unity引擎对象本身不是null, 但是它与null作<code>==</code>判断时是相等的(表示该对象已经无效)</li>
<li>如果对上述Unity对象运用<code>?.</code>或者<code>??</code>运算符, 则很可能导致报错或者意想不到的结果</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Monobehaviour脚本中, 假设物体并没有挂载Camera脚本</span></span><br><span class="line"><span class="keyword">private</span> Camera c; <span class="comment">// 未拖拽绑定, 未初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里c其实本身不为null, 但是它是一个无效的Camera对象, 与null作==运算返回是true</span></span><br><span class="line">    print(c == <span class="literal">null</span>); <span class="comment">// True</span></span><br><span class="line">    print(c ?? Camera.main); <span class="comment">// 打印了c的值: null</span></span><br><span class="line">    <span class="comment">// 对于GetComponent也一样</span></span><br><span class="line">    Camera mc = GetComponent&lt;Camera&gt;(); <span class="comment">// 未挂载Camera, 返回无效对象</span></span><br><span class="line">    print(mc == <span class="literal">null</span>); <span class="comment">// True</span></span><br><span class="line">    print(mc ?? Camera.main); <span class="comment">// null</span></span><br><span class="line">    print(mc == <span class="keyword">default</span>(Camera)); <span class="comment">// True</span></span><br><span class="line">    print(mc == <span class="keyword">default</span>(UnityEngine.Object)); <span class="comment">// True </span></span><br><span class="line">    print(mc?.GetComponent&lt;Transform&gt;()); <span class="comment">//直接报错, 这里的?.运算符并未按照预期执行!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Unity中不要使用<code>?.</code>和<code>??</code>两种运算符 (Unity中的对象大都继承于UnityEngine.Object, 它重写了==运算符, 使得判断是否为null时与<code>?.</code>和<code>??</code>有歧义)</li>
<li>其它C#类, 如果重载了<code>==</code>运算符, 那么最好也别使用</li>
</ul>
<p>如果一定要使用<code>?.</code>和<code>??</code>, 那么一定要先确定<code>==</code>与null的判断和这两个运算符没有歧义</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua简明教程</title>
    <url>/lua/lua-tutorial/</url>
    <content><![CDATA[<h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><h2 id="编译Lua-5-3-5"><a href="#编译Lua-5-3-5" class="headerlink" title="编译Lua 5.3.5"></a>编译Lua 5.3.5</h2><ol>
<li><p>下载lua5.3.5源码并解压 <a href="http://www.lua.org/ftp/">www.lua.org/ftp/</a></p>
</li>
<li><p>下载配置好Mingw64</p>
</li>
<li><p>cd到src目录, 运行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mingw32-make.exe mingw</span><br></pre></td></tr></table></figure>
</li>
<li><p>将生成在src目录下的文件按结构拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin:</span><br><span class="line">    lua luac lua53[库文件 dll或其它格式]</span><br><span class="line">include:</span><br><span class="line">    lua.h luaconf.h lualib.h lauxlib.h lua.hpp</span><br><span class="line">lib:</span><br><span class="line">    liblua.a</span><br><span class="line">man&#x2F;man1:</span><br><span class="line">    lua.1 luac.1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="Hello-Word"><a href="#Hello-Word" class="headerlink" title="Hello Word"></a>Hello Word</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello word&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="全局-局部变量"><a href="#全局-局部变量" class="headerlink" title="全局/局部变量"></a>全局/局部变量</h3><p>lua变量默认就是全局的, 注意尽量不要申请全局变量</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- test.lua</span></span><br><span class="line">a = <span class="number">5</span>				<span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">6</span>			<span class="comment">-- 局部变量 文件内有效</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a, b)			<span class="comment">-- 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span>		<span class="comment">-- 全局函数</span></span><br><span class="line">    c = <span class="number">5</span>			<span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>		<span class="comment">-- 局部变量 函数内有效</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>	<span class="comment">-- 局部函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>lua有8个基本类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nil</td>
<td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td>boolean</td>
<td>包含两个值：false和true。</td>
</tr>
<tr>
<td>number</td>
<td>表示双精度类型的实浮点数</td>
</tr>
<tr>
<td>string</td>
<td>字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td>function</td>
<td>由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td>userdata</td>
<td>表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td>thread</td>
<td>表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td>table</td>
<td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;Hello world&quot;</span>))      <span class="comment">-- string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">10.4</span>*<span class="number">3</span>))             <span class="comment">-- number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))              <span class="comment">-- function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))               <span class="comment">-- function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))               <span class="comment">-- boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))                <span class="comment">-- nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))            <span class="comment">-- string</span></span><br></pre></td></tr></table></figure>

<h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>删除作用: 对于变量和table, 将变量或者table表里的变量赋值为nil, 等同于把它们删掉</p>
<h3 id="变量作为判断条件"><a href="#变量作为判断条件" class="headerlink" title="变量作为判断条件"></a>变量作为判断条件</h3><p>作为循环/if的判断条件: <strong>有且仅有false和nil判断为false; 其它都为true, 包括0, 空字符串和空表</strong></p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>lua中没有switch分支, 只有if分支</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cond1 <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- code1</span></span><br><span class="line"><span class="keyword">elseif</span> cond2 <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- code2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- code</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>lua中没有continue语句, 但是有break语句</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">20</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">-- some code</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">3</span> <span class="keyword">do</span>			<span class="comment">-- i从1到5, 每次递增1</span></span><br><span class="line">    <span class="built_in">print</span>(i)			<span class="comment">-- 1 2 3</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">3</span>, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)			<span class="comment">-- 3 2 1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="comment">-- some code</span></span><br><span class="line"><span class="keyword">until</span> condition			<span class="comment">-- 条件为false时循环</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(num)</span></span>			<span class="comment">-- 全局函数, 返回值为nil</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(num)</span></span>	<span class="comment">-- 局部函数</span></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> test = <span class="function"><span class="keyword">function</span><span class="params">(num)</span></span>	<span class="comment">-- 与上面的代码相同</span></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> test = <span class="function"><span class="keyword">function</span><span class="params">(num)</span></span>	<span class="comment">-- 返回多值</span></span><br><span class="line">    <span class="keyword">return</span> num, num * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a, b = test(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> _, t = test(<span class="number">3</span>)		<span class="comment">-- 丢弃部分返回值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> t = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unpack</span>(t)		<span class="comment">-- return t是返回一个表</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> _, a, b = test()</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span>			<span class="comment">-- 传入的参数以table存入, arg[&quot;n&quot;]为参数个数, 会取到n</span></span><br><span class="line">        <span class="built_in">print</span>(k, v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(&#123;...&#125;) <span class="keyword">do</span> 		<span class="comment">-- &#123;...&#125;是用传入参数组成的数组</span></span><br><span class="line">        <span class="built_in">print</span>(i, v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;参数个数为&quot;</span>..#<span class="built_in">arg</span>)			 <span class="comment">-- lua5.3.5测试这里总是正确, 即使中间有nil, 长度也正确; 如果不正确, 试试select(&quot;#&quot;, ...)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><p><code>[[ ]]</code>包含的字符串原样输出, 包括换行, 空白, 引号, 转义字符</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">&quot;lua&quot;</span>				<span class="comment">-- lua</span></span><br><span class="line">string2 = <span class="string">&#x27;lua&#x27;</span>				<span class="comment">-- lua</span></span><br><span class="line">string3 = <span class="string">[[&quot;lua数据&quot;\nss]]</span>	   <span class="comment">-- &quot;lua数据&quot;\nss</span></span><br><span class="line">string4 = string1..<span class="string">&quot;&amp;&amp;&quot;</span>		<span class="comment">-- lua&amp;&amp; (字符串拼接, 每次拼接需要重新申请空间)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 大量字符串拼接时不要使用<code>..</code>, 每次重新申请空间带来的开销很大, 可以用<code>table.insert()</code>先保存到数组, 再<code>table.concat()</code>合并</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">upper</span>(<span class="string">&quot;Lua&quot;</span>)			<span class="comment">-- LUA</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">lower</span>(<span class="string">&quot;Lua&quot;</span>)			<span class="comment">-- lua</span></span><br><span class="line"><span class="comment">--[[ string.gsub(main, find, replace, num) 替换字符串</span></span><br><span class="line"><span class="comment">main为要操作的字符串, find为被替换字符串, replace用来替换的字符串, num替换次数(忽略则全替换)</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="number">3</span>) <span class="comment">-- zzza 3</span></span><br><span class="line"><span class="comment">--[[ string.find(str, substr, [init, [end]]</span>)</span><br><span class="line">init为索引</span><br><span class="line">]]</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;Hello lua user&quot;</span>, <span class="string">&quot;lua&quot;</span>) <span class="comment">-- 7 9</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">reverse</span>(<span class="string">&quot;lua&quot;</span>) <span class="comment">-- aul</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>) <span class="comment">-- abcd</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;ABCD&quot;</span>,<span class="number">4</span>) <span class="comment">-- 68 (D的ASCII)</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;ABC&quot;</span>) <span class="comment">-- 65 (A的ASCII)</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">len</span>(<span class="string">&quot;str&quot;</span>) <span class="comment">-- 3 计算字符串长度, 字节数</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">rep</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">2</span>) <span class="comment">-- abcabc 字符串的n个拷贝</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">gmatch</span>(str, pattern) <span class="comment">-- 每次调用, 则查找下一个模式匹配</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">match</span>(str, pattern init) <span class="comment">-- 返回第一个匹配, init搜寻起始点</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(formatstr, ...) <span class="comment">-- 字符串格式化</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><p>详细: <a href="https://www.runoob.com/lua/lua-strings.html">lua字符串</a></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">&quot;Lua&quot;</span></span><br><span class="line">string2 = <span class="string">&quot;Tutorial&quot;</span></span><br><span class="line">number1 = <span class="number">10</span></span><br><span class="line">number2 = <span class="number">20</span></span><br><span class="line"><span class="comment">-- 基本字符串格式化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;基本格式化 %s %s&quot;</span>,string1,string2))</span><br><span class="line"><span class="comment">-- 日期格式化</span></span><br><span class="line"><span class="built_in">date</span> = <span class="number">2</span>; month = <span class="number">1</span>; year = <span class="number">2014</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;日期格式化 %02d/%02d/%03d&quot;</span>, <span class="built_in">date</span>, month, year))</span><br><span class="line"><span class="comment">-- 十进制格式化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%.4f&quot;</span>,<span class="number">1</span>/<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">基本格式化 Lua Tutorial</span><br><span class="line">日期格式化 <span class="number">02</span>/<span class="number">01</span>/<span class="number">2014</span></span><br><span class="line"><span class="number">0.3333</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h4><p>支持模式的方法</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">find</span>(s, pattern[, init[, plain]])</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">match</span>(s, pattern[, init])</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">gmatch</span>(s, pattern)</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">gsub</span>(s, pattern, repl[, n])</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&#x27;2015-5-12 13:53&#x27;</span>, <span class="string">&#x27;%d+-%d+-%d+&#x27;</span>)	<span class="comment">-- 2015-5-12</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&#x27;2015-5-12 13:53&#x27;</span>, <span class="string">&#x27;(%d+)-(%d+)-(%d+)&#x27;</span>) <span class="comment">-- 2015 5 12</span></span><br></pre></td></tr></table></figure>

<p>详细: <a href="http://note.youdao.com/noteshare?id=949d9f95814d47328f770da9aa2a2cbb&sub=D0E03ABA00CE49529B4CD226F73CE48E">Lua的字符串匹配与正则表达式</a></p>
<h2 id="表与数组"><a href="#表与数组" class="headerlink" title="表与数组"></a>表与数组</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125; 	<span class="comment">-- 空表, 空数组</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&quot;lua&quot;</span> 	<span class="comment">-- 指定值</span></span><br><span class="line">t = <span class="literal">nil</span> 		<span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">local</span> t1 = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="string">&quot;lua&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wow&quot;</span> = <span class="string">&quot;ss&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&quot;lua&quot;</span></span><br><span class="line">t[<span class="string">&quot;wow&quot;</span>] = <span class="string">&quot;ss&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="string">&quot;1&quot;</span>])	<span class="comment">-- nil</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="string">&quot;wow&quot;</span>]) <span class="comment">-- ss</span></span><br><span class="line"><span class="built_in">print</span>(t.wow)	<span class="comment">-- ss</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>lua中数组下标从1开始</strong></p>
<p>数组是以数字为下标的表, 但是表不一定是数组!</p>
<p>数组长度: <code>#t</code>, <code>table.getn(t)</code>, 如果<strong>中途有下标跳跃则长度统计中断, 有nil值, 如果nil不为最后一个元素, 则也不影响</strong></p>
<p>这两个操作只能求数组长度, 不要用来求表长度!!</p>
<p>只有以数字作为下标, 才能成为数组</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="string">&quot;lua&quot;</span>, <span class="number">333</span>, <span class="string">&quot;ss&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#t)				<span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">getn</span>(t))	<span class="comment">-- 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">33</span>,</span><br><span class="line">    [<span class="string">&quot;ww&quot;</span>] = <span class="string">&quot;ss&quot;</span>,		<span class="comment">-- 表数据, 和数组无关, 最好不要混合使用!</span></span><br><span class="line">    [<span class="number">2</span>] = <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(#t)				<span class="comment">-- 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">getn</span>(t))	<span class="comment">-- 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#t)				<span class="comment">-- 2</span></span><br><span class="line">t[<span class="number">4</span>] = <span class="number">4</span>				<span class="comment">-- 相当于local t = &#123;1, 2, nil, 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(#t)				<span class="comment">-- 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="number">1</span>,			<span class="comment">-- 下标跳跃, 统计中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(#t)				<span class="comment">-- 2</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">3</span>])				<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>pairs 表遍历, 所有key和value都能遍历到, 无论key是数字还是字符串</p>
<p>ipairs 数组遍历, 只能遍历从1开始的连续数字下标, 中断的数字下标和字符串下标都不会遍历到</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;</span><br><span class="line">    [<span class="string">&quot;aa&quot;</span>] = <span class="string">&quot;at&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;bb&quot;</span>] = <span class="string">&quot;bt&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;cc&quot;</span>] = <span class="string">&quot;ct&quot;</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="string">&quot;3t&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(k), k, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">number	<span class="number">3</span>	<span class="number">3</span>t	</span><br><span class="line"><span class="built_in">string</span>	cc	ct	</span><br><span class="line"><span class="built_in">string</span>	aa	at	</span><br><span class="line"><span class="built_in">string</span>	bb	bt</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="string">&quot;1t&quot;</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="string">&quot;2t&quot;</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="string">&quot;3t&quot;</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="string">&quot;5t&quot;</span>,		<span class="comment">-- 中断的下标</span></span><br><span class="line">    [<span class="string">&quot;aa&quot;</span>] = at,	<span class="comment">-- 字符串下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 输出</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1</span>t	</span><br><span class="line"><span class="number">2</span>	<span class="number">2</span>t	</span><br><span class="line"><span class="number">3</span>	<span class="number">3</span>t</span><br></pre></td></tr></table></figure>

<h3 id="table常用函数"><a href="#table常用函数" class="headerlink" title="table常用函数"></a>table常用函数</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">concat</span> (<span class="built_in">table</span> [, sep [, start [, <span class="keyword">end</span>]]]) <span class="comment">-- 将table数组部分从start到end位置元素以sep分隔符连接起来</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span> (<span class="built_in">table</span>, [pos,] value) <span class="comment">-- 在数组的pos位置(默认尾部)插入一个元素</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span> (<span class="built_in">table</span> [, pos]) <span class="comment">-- 删除数组指定位置(默认尾部)一个元素, 后续元素前移 (连续删除, 要倒序遍历)</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span> (<span class="built_in">table</span> [, comp]) <span class="comment">-- 使用比较函数comp从小到大排序数组</span></span><br></pre></td></tr></table></figure>

<h2 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h2><h3 id="设置和获取元表"><a href="#设置和获取元表" class="headerlink" title="设置和获取元表"></a>设置和获取元表</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">table</span>, metatable) 		<span class="comment">-- 设置table的元表为metatable</span></span><br><span class="line"><span class="built_in">getmetatable</span>(<span class="built_in">table</span>)					<span class="comment">-- 获取元表</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">-- 相当于如下操作</span></span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line">mymetatable = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(mytable, mymetatable)</span><br></pre></td></tr></table></figure>

<h3 id="index"><a href="#index" class="headerlink" title="__index"></a>__index</h3><p>metatable最常用键</p>
<p>通过key访问table时, 如果table中key没有对应value, 则寻找metatable的<code>__index</code>键(假如有metatable); 如果<code>__index</code>是一个表, 则在表中查找; 如果<code>__index</code>是一个函数, 则调用函数, 返回函数返回值</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">        <span class="built_in">__index</span> = &#123;[<span class="string">&quot;aa&quot;</span>] = <span class="string">&quot;ss&quot;</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="built_in">print</span>(t[<span class="string">&quot;aa&quot;</span>])	<span class="comment">-- ss</span></span><br><span class="line"><span class="built_in">print</span>(t.aa)		<span class="comment">-- ss</span></span><br><span class="line"><span class="built_in">print</span>(t.bb)		<span class="comment">-- nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">        <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, key)</span></span></span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t[<span class="string">&quot;aa&quot;</span>])	<span class="comment">-- aa</span></span><br><span class="line"><span class="built_in">print</span>(t.aa)		<span class="comment">-- aa</span></span><br></pre></td></tr></table></figure>

<h3 id="newindex"><a href="#newindex" class="headerlink" title="__newindex"></a>__newindex</h3><p><code>__newindex</code>用于更新表</p>
<p>给表的一个<strong>缺少的索引</strong>赋值, 解释器先查找<code>__newindex</code>, 如果存在, 则更新<code>__newindex</code>表或者调用<code>__newindex</code>函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> st = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> t = <span class="built_in">setmetatable</span>(&#123;[<span class="string">&quot;aa&quot;</span>] = <span class="string">&quot;ss&quot;</span>&#125;, &#123;</span><br><span class="line">        <span class="built_in">__newindex</span> = st</span><br><span class="line">    &#125;)</span><br><span class="line">t.aa = <span class="string">&quot;ass&quot;</span></span><br><span class="line">t.bb = <span class="string">&quot;bss&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t.aa)		<span class="comment">-- ass</span></span><br><span class="line"><span class="built_in">print</span>(t.bb)		<span class="comment">-- nil</span></span><br><span class="line"><span class="built_in">print</span>(st.aa)	<span class="comment">-- nil</span></span><br><span class="line"><span class="built_in">print</span>(st.bb)	<span class="comment">-- bss</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">        <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, key, value)</span></span></span><br><span class="line">            <span class="built_in">print</span>(key, value)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;)</span><br><span class="line">t.aa = <span class="string">&quot;ss&quot;</span>		<span class="comment">-- aa ss</span></span><br></pre></td></tr></table></figure>

<h3 id="rawset-rawget"><a href="#rawset-rawget" class="headerlink" title="rawset rawget"></a>rawset rawget</h3><p>如果一个表有元表, 但是又想绕开元表中的<code>__index</code> <code>__newindex</code>, 则用rawset和rawget函数, 表示只对表进行操作, 不动用元表</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rawset</span>(<span class="built_in">table</span>, key, value) 	<span class="comment">-- 设置table的key索引对应值, 绕过元表__index</span></span><br><span class="line"><span class="built_in">rawget</span>(<span class="built_in">table</span>, key)			<span class="comment">-- 获取table的key索引对应值, 绕过元表__newindex</span></span><br></pre></td></tr></table></figure>

<h3 id="为表添加操作符"><a href="#为表添加操作符" class="headerlink" title="为表添加操作符"></a>为表添加操作符</h3><table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>__add</code></td>
<td>对应的运算符 <code>+</code></td>
</tr>
<tr>
<td><code>__sub</code></td>
<td>对应的运算符 <code>-</code></td>
</tr>
<tr>
<td><code>__mul</code></td>
<td>对应的运算符 <code>*</code></td>
</tr>
<tr>
<td><code>__div</code></td>
<td>对应的运算符 <code>/</code></td>
</tr>
<tr>
<td><code>__mod</code></td>
<td>对应的运算符 <code>%</code></td>
</tr>
<tr>
<td><code>__unm</code></td>
<td>对应的运算符 <code>-</code></td>
</tr>
<tr>
<td><code> __concat</code></td>
<td>对应的运算符 <code>..</code></td>
</tr>
<tr>
<td><code> __eq</code></td>
<td>对应的运算符 <code>==</code></td>
</tr>
<tr>
<td><code> __lt</code></td>
<td>对应的运算符 <code>&lt;</code></td>
</tr>
<tr>
<td><code> __le</code></td>
<td>对应的运算符 <code>&lt;=</code></td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">        <span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, another)</span></span></span><br><span class="line">            <span class="comment">-- add operation</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">self</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="built_in">print</span>(t + t)</span><br></pre></td></tr></table></figure>

<h3 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h3><p>可以让表对象直接像方法一样调用</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;</span><br><span class="line">        <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, ...)</span></span></span><br><span class="line">            <span class="built_in">print</span>(...)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;__call&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="built_in">print</span>(t(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">-- 输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">__call</span></span><br></pre></td></tr></table></figure>

<h3 id="tostring"><a href="#tostring" class="headerlink" title="__tostring"></a>__tostring</h3><p>修改表的输出行为</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = <span class="built_in">setmetatable</span>(&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ss&quot;</span>&#125;, &#123;</span><br><span class="line">    <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="keyword">local</span> temp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">self</span>) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">insert</span>(temp, v)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>..<span class="built_in">table</span>.<span class="built_in">concat</span>(temp, <span class="string">&quot;,&quot;</span>)..<span class="string">&quot;]&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(t)		<span class="comment">-- [a, aa, ss]</span></span><br></pre></td></tr></table></figure>



<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>单个Lua虚拟机只能工作在一个线程下, 如果真的想在lua中使用多线程, 可以看看lua多线程库<a href="https://github.com/LuaLanes/lanes">Lanes</a>, <a href="https://github.com/effil/effil">Effil</a>. 当然了, 多线程容易增加出错概率, 尽量不要用多线程</p>
<p>任意时刻, 只有一个协同程序在运行, 并且运行的协程只有明确的被要求挂起时才会挂起 (同步的多线程)</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>coroutine.create()</td>
<td>创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用</td>
</tr>
<tr>
<td>coroutine.resume()</td>
<td>重启 coroutine，和 create 配合使用</td>
</tr>
<tr>
<td>coroutine.yield()</td>
<td>挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果</td>
</tr>
<tr>
<td>coroutine.status()</td>
<td>查看 coroutine 的状态  注：coroutine 的状态有三种：dead，suspended，running，具体什么时候有这样的状态请参考下面的程序</td>
</tr>
<tr>
<td>coroutine.wrap（）</td>
<td>创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复</td>
</tr>
<tr>
<td>coroutine.running()</td>
<td>返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 corouting 的线程号</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建协程</span></span><br><span class="line"><span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i * i)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- 运行协程, 传入参数</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>) 		<span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- 协程运行结束, 回到当前协程</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))		<span class="comment">-- dead</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- wrap创建的协程运行时如同调用一个函数, 注意不要与正常函数混淆</span></span><br><span class="line"><span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i * i)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- 像函数一样调用</span></span><br><span class="line">co(<span class="number">2</span>)							<span class="comment">-- 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))		<span class="comment">-- dead</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用协程创建一个类似python中的生成器</span></span><br><span class="line"><span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(count)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">running</span>())</span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">local</span> j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;count: &quot;</span>..count)</span><br><span class="line">        count = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(j)	<span class="comment">-- yield也可以没有参数</span></span><br><span class="line">        i, j = j, i + j</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">running</span>())</span><br><span class="line"><span class="comment">-- 头一次resume通过函数参数传入</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>))</span><br><span class="line"><span class="comment">-- 之后resume的传入参数通过yield的返回值获取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">4</span>))</span><br><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">suspended</span><br><span class="line">thread: <span class="number">0000000000</span>eb5e68        <span class="literal">true</span></span><br><span class="line">thread: <span class="number">0000000000</span>ebeee8        <span class="literal">false</span></span><br><span class="line">count: <span class="number">1</span></span><br><span class="line"><span class="literal">true</span>    <span class="number">1</span></span><br><span class="line">count: <span class="number">2</span></span><br><span class="line"><span class="literal">true</span>    <span class="number">1</span></span><br><span class="line">count: <span class="number">3</span></span><br><span class="line"><span class="literal">true</span>    <span class="number">2</span></span><br><span class="line">count: <span class="number">4</span></span><br><span class="line"><span class="literal">true</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p><a href="https://www.runoob.com/lua/lua-file-io.html">https://www.runoob.com/lua/lua-file-io.html</a></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>检查第一个参数, 若不为true, 则将第二个参数作为错误信息抛出</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a,b)</span></span></span><br><span class="line">   <span class="built_in">assert</span>(<span class="built_in">type</span>(a) == <span class="string">&quot;number&quot;</span>, <span class="string">&quot;a 不是一个数字&quot;</span>)</span><br><span class="line">   <span class="built_in">assert</span>(<span class="built_in">type</span>(b) == <span class="string">&quot;number&quot;</span>, <span class="string">&quot;b 不是一个数字&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">add(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- 输出</span></span><br><span class="line">lua: test.lua:<span class="number">3</span>: b 不是一个数字</span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">    [C]: <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> &#x27;<span class="title">assert</span>&#x27;</span></span><br><span class="line"><span class="function">    <span class="title">test.lua</span>:3: <span class="title">in</span> <span class="title">local</span> &#x27;<span class="title">add</span>&#x27;</span></span><br><span class="line"><span class="function">    <span class="title">test.lua</span>:6: <span class="title">in</span> <span class="title">main</span> <span class="title">chunk</span></span></span><br><span class="line"><span class="function">    [<span class="title">C</span>]: <span class="title">in</span> ?</span></span><br></pre></td></tr></table></figure>

<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">error</span> (message [, level])</span><br></pre></td></tr></table></figure>

<p>终止正在执行的函数, 并将message内容作为错误信息 (error函数永不返回)</p>
<p>level:</p>
<ul>
<li>1 默认, 调用error的位置(文件+行号)</li>
<li>2 指出调用error的函数</li>
<li>0 不添加错误位置信息</li>
</ul>
<h3 id="pcall-amp-xpcall-amp-debug"><a href="#pcall-amp-xpcall-amp-debug" class="headerlink" title="pcall &amp; xpcall &amp; debug"></a>pcall &amp; xpcall &amp; debug</h3><h4 id="pcall"><a href="#pcall" class="headerlink" title="pcall"></a>pcall</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 接收一个函数和要传给它的参数, 返回true或者false, errorinfo</span></span><br><span class="line"><span class="built_in">pcall</span>(func, ...)</span><br></pre></td></tr></table></figure>

<p>pcall以保护模式运行函数, 但pcall返回时已经销毁了调用栈部分内容</p>
<h4 id="xpcall"><a href="#xpcall" class="headerlink" title="xpcall"></a>xpcall</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">xpcall</span>(func, err_handler, ...)</span><br></pre></td></tr></table></figure>

<p>额外接受一个错误处理函数, 发生错误时, 在调用栈展开之前调用错误处理函数, 于是可以在这个函数中使用debug库获取关于错误的额外信息</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">xpcall</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;error...&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">	<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>())</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    <span class="number">333</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 输出</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">        test.lua:<span class="number">8</span>: <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> &lt;<span class="title">test.lua</span>:6&gt;</span></span><br><span class="line"><span class="function">        [<span class="title">C</span>]: <span class="title">in</span> <span class="title">function</span> &#x27;<span class="title">error</span>&#x27;</span></span><br><span class="line"><span class="function">        <span class="title">test.lua</span>:4: <span class="title">in</span> <span class="title">function</span> &lt;<span class="title">test.lua</span>:2&gt;</span></span><br><span class="line"><span class="function">        [<span class="title">C</span>]: <span class="title">in</span> <span class="title">function</span> &#x27;<span class="title">xpcall</span>&#x27;</span></span><br><span class="line"><span class="function">        <span class="title">test.lua</span>:1: <span class="title">in</span> <span class="title">main</span> <span class="title">chunk</span></span></span><br><span class="line"><span class="function">        [<span class="title">C</span>]: <span class="title">in</span> ?</span></span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><a href="https://www.runoob.com/lua/lua-debug.html">https://www.runoob.com/lua/lua-debug.html</a></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>lua自动垃圾回收采用古老的解决循环引用情况的标记清扫法(Mark-and-Sweep)</p>
<ul>
<li><p>Mark (标记阶段)</p>
<p>默认情况下, 所有变量都标记为”可回收”, 回收时, 从根节点<code>_G</code>出发, 可达对象标记为”不可回收”</p>
</li>
<li><p>Sweep (清扫阶段)</p>
<p>遍历所有现存对象, 将标志位是”可回收”的对象释放, 同时将标记为”不可回收”的对象重新标记为”可回收”为下次gc做准备</p>
</li>
</ul>
<h3 id="G"><a href="#G" class="headerlink" title="_G"></a>_G</h3><p>lua中<code>_G</code>是一张表, 包含了所有的全局函数, 全局变量, 包括对自身的引用</p>
<h3 id="collectgarbage函数"><a href="#collectgarbage函数" class="headerlink" title="collectgarbage函数"></a>collectgarbage函数</h3><p>collectgarbage函数提供了垃圾回收操作的相关功能</p>
<p>停止垃圾回收；<br> 重启垃圾回收；<br> 强制执行一次回收循环；<br> 强制执行一步垃圾回收；<br> 获取Lua占用的内存；<br> 以及两个影响垃圾回收频率和步幅的参数。</p>
<h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><h3 id="模块定义和加载"><a href="#模块定义和加载" class="headerlink" title="模块定义和加载"></a>模块定义和加载</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- test.lua</span></span><br><span class="line"><span class="keyword">local</span> mymodule = &#123;&#125;</span><br><span class="line">mymodule.MAX_NUM = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mymodule.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- some code</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> mymodule</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- main.lua</span></span><br><span class="line"><span class="keyword">local</span> my = <span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">my.func1()</span><br></pre></td></tr></table></figure>

<p>也可以在模块中直接定义为全局变量, 然后require之后直接使用, 不用接受require返回值</p>
<h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;模块名&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先查找package.loaded表, 检测是否被加载过, 如果加载过, 则require返回保存的值; 否则进行下面的步骤</p>
</li>
<li><p>在package的searchers表中, 有四个加载器, require按照顺序执行加载器, 找到了, 则成功返回, 没有就继续找</p>
<ul>
<li>预加载器 package.preload[modname], 一些特殊模块有预加载器</li>
<li>lua加载器查找package.path</li>
<li>c加载器查找package.cpath</li>
<li>一体化加载器</li>
</ul>
</li>
</ol>
<p>加载成功后</p>
<p>在package.loaded[‘mod’]中记录模块模块返回值, 如果模块没有返回值, 则设置为true;</p>
<p>在同一lua虚拟机中, 多次require同一模块, 模块只被加载一次, 得到的是同一个table, 并且任何地方修改table值, 其它地方引用的table也会改变</p>
<p>详细: <a href="https://blog.csdn.net/zxm342698145/article/details/80607072">lua require加载机制</a></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>lua中没有专门的类机制, 只有table可以用, 所以在lua中, 面向对象也是用table和元表来实现</p>
<h3 id="冒号语法糖"><a href="#冒号语法糖" class="headerlink" title="冒号语法糖"></a>冒号语法糖</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t.MAX_NUM = <span class="number">30</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t:show</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 上面的定义相当于</span></span><br><span class="line">t.show = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line">t:show()</span><br><span class="line"><span class="comment">-- 相当于</span></span><br><span class="line">t.show(t)</span><br></pre></td></tr></table></figure>

<h3 id="用元表实现继承"><a href="#用元表实现继承" class="headerlink" title="用元表实现继承"></a>用元表实现继承</h3><p>self参数的合理利用, 实现”动态绑定”, 然后元表和<code>__index</code>实现继承父类数据效果</p>
<p>// todo</p>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
</search>
